// ==UserScript==
// @name         Project DTRF
// @version      v1.0
// @description  Private Mod by RaZoshi
// @author       RaZoshi
// @match        *://moomoo.io/*
// @match        *://sandbox.moomoo.io/*
// @match        *://dev.moomoo.io/*
// @grant        none
// @icon         https://1.bp.blogspot.com/_gx12Su4zZ3Q/TP0uAfekGgI/AAAAAAAAAKg/FEYfjxkgJF4/s1600/Digital+Universe+%2528114%2529.JPG
// @require      https://greasyfork.org/scripts/423602-msgpack/code/msgpack.js
// @require      http://code.jquery.com/jquery-3.3.1.min.js
// @require      https://code.jquery.com/ui/1.12.0/jquery-ui.min.js
// @require      https://cdnjs.cloudflare.com/ajax/libs/jquery-confirm/3.3.0/jquery-confirm.min.js
// @require      https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js
// ==/UserScript==
//visuals


//bundle
!function (modules) {
    /* (webpack)/bootstrap */
    var installedModules = {};
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
            return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: !1,
            exports: {}
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports;
    }
    __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function (exports, name, getter) {
        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
            enumerable: !0,
            get: getter
        });
    }, __webpack_require__.r = function (exports) {
        'undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(exports, '__esModule', { value: !0 });
    }, __webpack_require__.t = function (value, mode) {
        if (1 & mode && (value = __webpack_require__(value)), 8 & mode)
            return value;
        if (4 & mode && 'object' == typeof value && value && value.__esModule)
            return value;
        var ns = Object.create(null);
        if (__webpack_require__.r(ns), Object.defineProperty(ns, 'default', {
                enumerable: !0,
                value: value
            }), 2 & mode && 'string' != typeof value)
            for (var key in value)
                __webpack_require__.d(ns, key, function (key) {
                    return value[key];
                }.bind(null, key));
        return ns;
    }, __webpack_require__.n = function (module) {
        var getter = module && module.__esModule ? function () {
            return module.default;
        } : function () {
            return module;
        };
        return __webpack_require__.d(getter, 'a', getter), getter;
    }, __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }, __webpack_require__.p = '', __webpack_require__(__webpack_require__.s = 2);
}([
    function (module, t, i) {
        /* 0: ./src/js/config.js */
        (function (process) {
            module.exports.maxScreenWidth = 1920, module.exports.maxScreenHeight = 1080, module.exports.serverUpdateRate = 9, module.exports.maxPlayers = process && -1 != process.argv.indexOf('--largeserver') ? 80 : 40, module.exports.maxPlayersHard = module.exports.maxPlayers + 10, module.exports.collisionDepth = 6, module.exports.minimapRate = 3000, module.exports.colGrid = 500, module.exports.clientSendRate = 5, module.exports.healthBarWidth = 70, module.exports.healthBarPad = 5, module.exports.iconPadding = 15, module.exports.iconPad = 0.9, module.exports.deathFadeout = 3000, module.exports.crownIconScale = 60, module.exports.crownPad = 35, module.exports.chatCountdown = 3000, module.exports.chatCooldown = 500, module.exports.inSandbox = process && 'mm_exp' === process.env.VULTR_SCHEME, module.exports.maxAge = 100, module.exports.gatherAngle = Math.PI / 2.6, module.exports.gatherWiggle = 10, module.exports.hitReturnRatio = 0.25, module.exports.hitAngle = Math.PI / 2, module.exports.playerScale = 35, module.exports.playerSpeed = 0.0016, module.exports.playerDecel = 0.993, module.exports.nameY = 34, module.exports.skinColors = [
                '#bf8f54',
                '#cbb091',
                '#896c4b',
                '#fadadc',
                '#ececec',
                '#c37373',
                '#4c4c4c',
                '#ecaff7',
                '#738cc3',
                '#8bc373'
            ], module.exports.animalCount = 7, module.exports.aiTurnRandom = 0.06, module.exports.cowNames = [
                'Sid',
                'Steph',
                'Bmoe',
                'Romn',
                'Jononthecool',
                'Fiona',
                'Vince',
                'Nathan',
                'Nick',
                'Flappy',
                'Ronald',
                'Otis',
                'Pepe',
                'Mc Donald',
                'Theo',
                'Fabz',
                'Oliver',
                'Jeff',
                'Jimmy',
                'Helena',
                'Reaper',
                'Ben',
                'Alan',
                'Naomi',
                'XYZ',
                'Clever',
                'Jeremy',
                'Mike',
                'Destined',
                'Stallion',
                'Allison',
                'Meaty',
                'Sophia',
                'Vaja',
                'Joey',
                'Pendy',
                'Murdoch',
                'Theo',
                'Jared',
                'July',
                'Sonia',
                'Mel',
                'Dexter',
                'Quinn',
                'Milky'
            ], module.exports.shieldAngle = Math.PI / 3, module.exports.weaponVariants = [
                {
                    id: 0,
                    src: '',
                    xp: 0,
                    val: 1
                },
                {
                    id: 1,
                    src: '_g',
                    xp: 3000,
                    val: 1.1
                },
                {
                    id: 2,
                    src: '_d',
                    xp: 7000,
                    val: 1.18
                },
                {
                    id: 3,
                    src: '_r',
                    poison: !0,
                    xp: 12000,
                    val: 1.18
                }
            ], module.exports.fetchVariant = function (player) {
                for (var tmpXP = player.weaponXP[player.weaponIndex] || 0, i = module.exports.weaponVariants.length - 1; i >= 0; --i)
                    if (tmpXP >= module.exports.weaponVariants[i].xp)
                        return module.exports.weaponVariants[i];
            }, module.exports.resourceTypes = [
                'wood',
                'food',
                'stone',
                'points'
            ], module.exports.areaCount = 7, module.exports.treesPerArea = 9, module.exports.bushesPerArea = 3, module.exports.totalRocks = 32, module.exports.goldOres = 7, module.exports.riverWidth = 724, module.exports.riverPadding = 114, module.exports.waterCurrent = 0.0011, module.exports.waveSpeed = 0.0001, module.exports.waveMax = 1.3, module.exports.treeScales = [
                150,
                160,
                165,
                175
            ], module.exports.bushScales = [
                80,
                85,
                95
            ], module.exports.rockScales = [
                80,
                85,
                90
            ], module.exports.snowBiomeTop = 2400, module.exports.snowSpeed = 0.75, module.exports.maxNameLength = 15, module.exports.mapScale = 14400, module.exports.mapPingScale = 40, module.exports.mapPingTime = 2200;
        }.call(this, i(5)));
    },
    function (module, t) {
        /* 1: ./node_modules/charenc/charenc.js */
        var charenc = {
            utf8: {
                stringToBytes: function (str) {
                    return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
                },
                bytesToString: function (bytes) {
                    return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
                }
            },
            bin: {
                stringToBytes: function (str) {
                    for (var bytes = [], i = 0; i < str.length; i++)
                        bytes.push(255 & str.charCodeAt(i));
                    return bytes;
                },
                bytesToString: function (bytes) {
                    for (var str = [], i = 0; i < bytes.length; i++)
                        str.push(String.fromCharCode(bytes[i]));
                    return str.join('');
                }
            }
        };
        module.exports = charenc;
    },
    function (e, t, __webpack_require__) {
        /* 2: ./src/js/app.js */
        'use strict';
        window.loadedScript = !0;
        var isProd = '127.0.0.1' !== location.hostname && !location.hostname.startsWith('192.168.');
        __webpack_require__(3);
        var io = __webpack_require__(4), UTILS = __webpack_require__(6), animText = __webpack_require__(7), config = __webpack_require__(0), GameObject = __webpack_require__(8), items = __webpack_require__(9), ObjectManager = (__webpack_require__(10), __webpack_require__(11)), Player = __webpack_require__(12), store = __webpack_require__(19), Projectile = __webpack_require__(20), ProjectileManager = __webpack_require__(21), SoundManager = __webpack_require__(22).obj, textManager = new animText.TextManager(), vultrClient = new (__webpack_require__(23))('moomoo.io', 3000, config.maxPlayers, 5, !1);
        vultrClient.debugLog = !1;
        var startedConnecting = !1;
        function connectSocketIfReady() {
            didLoad && captchaReady && (startedConnecting = !0, isProd ? window.grecaptcha.execute('6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ', { action: 'homepage' }).then(function (token) {
                connectSocket(token);
            }) : connectSocket(null));
        }
        function connectSocket(token) {
            vultrClient.start(function (address, port, gameIndex) {
                var wsAddress = (isProd ? 'wss' : 'ws') + '://' + address + ':8008/?gameIndex=' + gameIndex;
                token && (wsAddress += '&token=' + encodeURIComponent(token)), io.connect(wsAddress, function (error) {
                    pingSocket(), setInterval(() => pingSocket(), 2500), error ? disconnect(error) : (enterGameButton.onclick = UTILS.checkTrusted(function () {
                        !function () {
                            var validGame = ++preAdGameCount > 1, validTime = Date.now() - preAdLastShowTime > preAdInterval;
                            validGame && validTime ? (preAdLastShowTime = Date.now(), showPreAd()) : enterGame();
                        }();
                    }), UTILS.hookTouchEvents(enterGameButton), promoImageButton.onclick = UTILS.checkTrusted(function () {
                        openLink('https://krunker.io/?play=SquidGame_KB');
                    }), UTILS.hookTouchEvents(promoImageButton), joinPartyButton.onclick = UTILS.checkTrusted(function () {
                        setTimeout(function () {
                            !function () {
                                var currentKey = serverBrowser.value, key = prompt('party key', currentKey);
                                key && (window.onbeforeunload = void 0, window.location.href = '/?server=' + key);
                            }();
                        }, 10);
                    }), UTILS.hookTouchEvents(joinPartyButton), settingsButton.onclick = UTILS.checkTrusted(function () {
                        guideCard.classList.contains('showing') ? (guideCard.classList.remove('showing'), settingsButtonTitle.innerText = 'Settings') : (guideCard.classList.add('showing'), settingsButtonTitle.innerText = 'Close');
                    }), UTILS.hookTouchEvents(settingsButton), allianceButton.onclick = UTILS.checkTrusted(function () {
                        resetMoveDir(), 'block' != allianceMenu.style.display ? showAllianceMenu() : allianceMenu.style.display = 'none';
                    }), UTILS.hookTouchEvents(allianceButton), storeButton.onclick = UTILS.checkTrusted(function () {
                        'block' != storeMenu.style.display ? (storeMenu.style.display = 'block', allianceMenu.style.display = 'none', closeChat(), generateStoreList()) : storeMenu.style.display = 'none';
                    }), UTILS.hookTouchEvents(storeButton), chatButton.onclick = UTILS.checkTrusted(function () {
                        toggleChat();
                    }), UTILS.hookTouchEvents(chatButton), mapDisplay.onclick = UTILS.checkTrusted(function () {
                        sendMapPing();
                    }), UTILS.hookTouchEvents(mapDisplay), function () {
                        for (var i = 0; i < icons.length; ++i) {
                            var tmpSprite = new Image();
                            tmpSprite.onload = function () {
                                this.isLoaded = !0;
                            }, tmpSprite.src = '.././img/icons/' + icons[i] + '.png', iconSprites[icons[i]] = tmpSprite;
                        }
                    }(), loadingText.style.display = 'none', menuCardHolder.style.display = 'block', nameInput.value = getSavedVal('moo_name') || '', function () {
                        var savedNativeValue = getSavedVal('native_resolution');
                        setUseNativeResolution(savedNativeValue ? 'true' == savedNativeValue : 'undefined' != typeof cordova), showPing = 'true' == getSavedVal('show_ping'), pingDisplay.hidden = !showPing, getSavedVal('moo_moosic'), setInterval(function () {
                            window.cordova && (document.getElementById('downloadButtonContainer').classList.add('cordova'), document.getElementById('mobileDownloadButtonContainer').classList.add('cordova'));
                        }, 1000), updateSkinColorPicker(), UTILS.removeAllChildren(actionBar);
                        for (var i = 0; i < items.weapons.length + items.list.length; ++i)
                            !function (i) {
                                UTILS.generateElement({
                                    id: 'actionBarItem' + i,
                                    class: 'actionBarItem',
                                    style: 'display:none',
                                    onmouseout: function () {
                                        showItemInfo();
                                    },
                                    parent: actionBar
                                });
                            }(i);
                        for (i = 0; i < items.list.length + items.weapons.length; ++i)
                            !function (i) {
                                var tmpCanvas = document.createElement('canvas');
                                tmpCanvas.width = tmpCanvas.height = 66;
                                var tmpContext = tmpCanvas.getContext('2d');
                                if (tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2), tmpContext.imageSmoothingEnabled = !1, tmpContext.webkitImageSmoothingEnabled = !1, tmpContext.mozImageSmoothingEnabled = !1, items.weapons[i]) {
                                    tmpContext.rotate(Math.PI / 4 + Math.PI);
                                    var tmpSprite = new Image();
                                    toolSprites[items.weapons[i].src] = tmpSprite, tmpSprite.onload = function () {
                                        this.isLoaded = !0;
                                        var tmpPad = 1 / (this.height / this.width), tmpMlt = items.weapons[i].iPad || 1;
                                        tmpContext.drawImage(this, -tmpCanvas.width * tmpMlt * config.iconPad * tmpPad / 2, -tmpCanvas.height * tmpMlt * config.iconPad / 2, tmpCanvas.width * tmpMlt * tmpPad * config.iconPad, tmpCanvas.height * tmpMlt * config.iconPad), tmpContext.fillStyle = 'rgba(0, 0, 70, 0.1)', tmpContext.globalCompositeOperation = 'source-atop', tmpContext.fillRect(-tmpCanvas.width / 2, -tmpCanvas.height / 2, tmpCanvas.width, tmpCanvas.height), document.getElementById('actionBarItem' + i).style.backgroundImage = 'url(' + tmpCanvas.toDataURL() + ')';
                                    }, tmpSprite.src = '.././img/weapons/' + items.weapons[i].src + '.png', (tmpUnit = document.getElementById('actionBarItem' + i)).onmouseover = UTILS.checkTrusted(function () {
                                        showItemInfo(items.weapons[i], !0);
                                    }), tmpUnit.onclick = UTILS.checkTrusted(function () {
                                        selectToBuild(i, !0);
                                    }), UTILS.hookTouchEvents(tmpUnit);
                                } else {
                                    tmpSprite = getItemSprite(items.list[i - items.weapons.length], !0);
                                    var tmpUnit, tmpScale = Math.min(tmpCanvas.width - config.iconPadding, tmpSprite.width);
                                    tmpContext.globalAlpha = 1, tmpContext.drawImage(tmpSprite, -tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale), tmpContext.fillStyle = 'rgba(0, 0, 70, 0.1)', tmpContext.globalCompositeOperation = 'source-atop', tmpContext.fillRect(-tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale), document.getElementById('actionBarItem' + i).style.backgroundImage = 'url(' + tmpCanvas.toDataURL() + ')', (tmpUnit = document.getElementById('actionBarItem' + i)).onmouseover = UTILS.checkTrusted(function () {
                                        showItemInfo(items.list[i - items.weapons.length]);
                                    }), tmpUnit.onclick = UTILS.checkTrusted(function () {
                                        selectToBuild(i - items.weapons.length);
                                    }), UTILS.hookTouchEvents(tmpUnit);
                                }
                            }(i);
                        nameInput.ontouchstart = UTILS.checkTrusted(function (e) {
                            e.preventDefault();
                            var newValue = prompt('enter name', e.currentTarget.value);
                            newValue && (e.currentTarget.value = newValue.slice(0, 15));
                        }), nativeResolutionCheckbox.checked = useNativeResolution, nativeResolutionCheckbox.onchange = UTILS.checkTrusted(function (e) {
                            setUseNativeResolution(e.target.checked);
                        }), showPingCheckbox.checked = showPing, showPingCheckbox.onchange = UTILS.checkTrusted(function (e) {
                            showPing = showPingCheckbox.checked, pingDisplay.hidden = !showPing, saveVal('show_ping', showPing ? 'true' : 'false');
                        });
                    }());
                }, {
                    id: setInitData,
                    d: disconnect,
                    1: setupGame,
                    2: addPlayer,
                    4: removePlayer,
                    33: updatePlayers,
                    5: updateLeaderboard,
                    6: loadGameObject,
                    a: loadAI,
                    aa: animateAI,
                    7: gatherAnimation,
                    8: wiggleGameObject,
                    sp: shootTurret,
                    9: updatePlayerValue,
                    h: updateHealth,
                    11: killPlayer,
                    12: killObject,
                    13: killObjects,
                    14: updateItemCounts,
                    15: updateAge,
                    16: updateUpgrades,
                    17: updateItems,
                    18: addProjectile,
                    19: remProjectile,
                    20: serverShutdownNotice,
                    ac: addAlliance,
                    ad: deleteAlliance,
                    an: allianceNotification,
                    st: setPlayerTeam,
                    sa: setAlliancePlayers,
                    us: updateStoreItems,
                    ch: receiveChat,
                    mm: updateMinimap,
                    t: showText,
                    p: pingMap,
                    pp: pingSocketResponse
                }), setupServerStatus(), setTimeout(() => updateServerList(), 3000);
            }, function (error) {
                console.error('Vultr error:', error), alert('Error:\n' + error), disconnect('disconnected');
            });
        }
        var canStore, Sound = new SoundManager(config, UTILS), mathPI = Math.PI, mathPI2 = 2 * mathPI;
        function saveVal(name, val) {
            canStore && localStorage.setItem(name, val);
        }
        function getSavedVal(name) {
            return canStore ? localStorage.getItem(name) : null;
        }
        Math.lerpAngle = function (value1, value2, amount) {
            Math.abs(value2 - value1) > mathPI && (value1 > value2 ? value2 += mathPI2 : value1 += mathPI2);
            var value = value2 + (value1 - value2) * amount;
            return value >= 0 && value <= mathPI2 ? value : value % mathPI2;
        }, CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            return w < 2 * r && (r = w / 2), h < 2 * r && (r = h / 2), r < 0 && (r = 0), this.beginPath(), this.moveTo(x + r, y), this.arcTo(x + w, y, x + w, y + h, r), this.arcTo(x + w, y + h, x, y + h, r), this.arcTo(x, y + h, x, y, r), this.arcTo(x, y, x + w, y, r), this.closePath(), this;
        }, 'undefined' != typeof Storage && (canStore = !0);
        var useNativeResolution, showPing, delta, now, lastSent, attackState, player, playerSID, tmpObj, camX, camY, tmpDir, screenWidth, screenHeight, moofoll = getSavedVal('moofoll'), pixelDensity = 1, lastUpdate = Date.now(), ais = [], players = [], alliances = [], gameObjects = [], projectiles = [], projectileManager = new ProjectileManager(Projectile, projectiles, players, ais, objectManager, items, config, UTILS), AiManager = __webpack_require__(35), AI = __webpack_require__(36), aiManager = new AiManager(ais, AI, players, items, null, config, UTILS), waterMult = 1, waterPlus = 0, mouseX = 0, mouseY = 0, controllingTouch = {
                id: -1,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0
            }, attackingTouch = {
                id: -1,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0
            }, skinColor = 0, maxScreenWidth = config.maxScreenWidth, maxScreenHeight = config.maxScreenHeight, inGame = !1, mainMenu = (document.getElementById('ad-container'), document.getElementById('mainMenu')), enterGameButton = document.getElementById('enterGame'), promoImageButton = document.getElementById('promoImg'), partyButton = document.getElementById('partyButton'), joinPartyButton = document.getElementById('joinPartyButton'), settingsButton = document.getElementById('settingsButton'), settingsButtonTitle = settingsButton.getElementsByTagName('span')[0], allianceButton = document.getElementById('allianceButton'), storeButton = document.getElementById('storeButton'), chatButton = document.getElementById('chatButton'), gameCanvas = document.getElementById('gameCanvas'), mainContext = gameCanvas.getContext('2d'), serverBrowser = document.getElementById('serverBrowser'), nativeResolutionCheckbox = document.getElementById('nativeResolution'), showPingCheckbox = document.getElementById('showPing'), pingDisplay = (document.getElementById('playMusic'), document.getElementById('pingDisplay')), shutdownDisplay = document.getElementById('shutdownDisplay'), menuCardHolder = document.getElementById('menuCardHolder'), guideCard = document.getElementById('guideCard'), loadingText = document.getElementById('loadingText'), gameUI = document.getElementById('gameUI'), actionBar = document.getElementById('actionBar'), scoreDisplay = document.getElementById('scoreDisplay'), foodDisplay = document.getElementById('foodDisplay'), woodDisplay = document.getElementById('woodDisplay'), stoneDisplay = document.getElementById('stoneDisplay'), killCounter = document.getElementById('killCounter'), leaderboardData = document.getElementById('leaderboardData'), nameInput = document.getElementById('nameInput'), itemInfoHolder = document.getElementById('itemInfoHolder'), ageText = document.getElementById('ageText'), ageBarBody = document.getElementById('ageBarBody'), upgradeHolder = document.getElementById('upgradeHolder'), upgradeCounter = document.getElementById('upgradeCounter'), allianceMenu = document.getElementById('allianceMenu'), allianceHolder = document.getElementById('allianceHolder'), allianceManager = document.getElementById('allianceManager'), mapDisplay = document.getElementById('mapDisplay'), diedText = document.getElementById('diedText'), skinColorHolder = document.getElementById('skinColorHolder'), mapContext = mapDisplay.getContext('2d');
        mapDisplay.width = 300, mapDisplay.height = 300;
        var storeMenu = document.getElementById('storeMenu'), storeHolder = document.getElementById('storeHolder'), noticationDisplay = document.getElementById('noticationDisplay'), hats = store.hats, accessories = store.accessories, objectManager = new ObjectManager(GameObject, gameObjects, UTILS, config), outlineColor = '#525252', darkOutlineColor = '#3d3f42';
        function setInitData(data) {
            alliances = data.teams;
        }
        var featuredYoutuber = document.getElementById('featuredYoutube'), youtuberList = [
                {
                    name: 'RaZoshi',
                    link: 'https://youtube.com/@razoshi'
                },

            ], tmpYoutuber = youtuberList[UTILS.randInt(0, youtuberList.length - 1)];
        featuredYoutuber.innerHTML = '<a target=\'_blank\' class=\'ytLink\' href=\'' + tmpYoutuber.link + '\'><i class=\'material-icons\' style=\'vertical-align: top;\'>&#xE064;</i> ' + tmpYoutuber.name + '</a>';
        var inWindow = !0, didLoad = !1, captchaReady = !1;
        function disconnect(reason) {
            io.close(), showLoadingText(reason);
        }
        function showLoadingText(text) {
            mainMenu.style.display = 'block', gameUI.style.display = 'none', menuCardHolder.style.display = 'none', diedText.style.display = 'none', loadingText.style.display = 'block', loadingText.innerHTML = text + '<a href=\'javascript:window.location.href=window.location.href\' class=\'ytLink\'>reload</a>';
        }
        window.onblur = function () {
            inWindow = !1;
        }, window.onfocus = function () {
            inWindow = !0, player && player.alive && resetMoveDir();
        }, window.onload = function () {
            didLoad = !0, connectSocketIfReady(), setTimeout(function () {
                startedConnecting || (alert('Captcha failed to load'), window.location.reload());
            }, 20000);
        }, window.captchaCallback = function () {
            captchaReady = !0, connectSocketIfReady();
        }, gameCanvas.oncontextmenu = function () {
            return !1;
        };
        function setupServerStatus() {
            var altServerText, altServerURL, tmpHTML = '', overallTotal = 0;
            for (var region in vultrClient.servers) {
                for (var serverList = vultrClient.servers[region], totalPlayers = 0, i = 0; i < serverList.length; i++)
                    for (var j = 0; j < serverList[i].games.length; j++)
                        totalPlayers += serverList[i].games[j].playerCount;
                overallTotal += totalPlayers;
                var regionName = vultrClient.regionInfo[region].name;
                tmpHTML += '<option disabled>' + regionName + ' - ' + totalPlayers + ' players</option>';
                for (var serverIndex = 0; serverIndex < serverList.length; serverIndex++)
                    for (var server = serverList[serverIndex], gameIndex = 0; gameIndex < server.games.length; gameIndex++) {
                        var game = server.games[gameIndex], adjustedIndex = 1 * server.index + gameIndex + 1, isSelected = vultrClient.server && vultrClient.server.region === server.region && vultrClient.server.index === server.index && vultrClient.gameIndex == gameIndex, serverLabel = regionName + ' ' + adjustedIndex + ' [' + Math.min(game.playerCount, config.maxPlayers) + '/' + config.maxPlayers + ']';
                        let altServerText = vultrClient.stripRegion(region) + ':' + serverIndex + ':' + gameIndex;
                        isSelected && (partyButton.getElementsByTagName('span')[0].innerText = altServerText), tmpHTML += '<option value=\'' + altServerText + '\' ' + (isSelected ? 'selected' : '') + '>' + serverLabel + '</option>';
                    }
                tmpHTML += '<option disabled></option>';
            }
            tmpHTML += '<option disabled>All Servers - ' + overallTotal + ' players</option>', serverBrowser.innerHTML = tmpHTML, 'sandbox.moomoo.io' == location.hostname ? (altServerText = 'Back to MooMoo', altServerURL = '//moomoo.io/') : (altServerText = 'Try the sandbox', altServerURL = '//sandbox.moomoo.io/'), document.getElementById('altServer').innerHTML = '<a href=\'' + altServerURL + '\'>' + altServerText + '<i class=\'material-icons\' style=\'font-size:10px;vertical-align:middle\'>arrow_forward_ios</i></a>';
        }
        function updateServerList() {
            var xmlhttp = new XMLHttpRequest();
            xmlhttp.onreadystatechange = function () {
                4 == this.readyState && (200 == this.status ? (window.vultr = JSON.parse(this.responseText), vultrClient.processServers(vultr.servers), setupServerStatus()) : console.error('Failed to load server data with status code:', this.status));
            }, xmlhttp.open('GET', '/serverData', !0), xmlhttp.send();
        }
        serverBrowser.addEventListener('change', UTILS.checkTrusted(function () {
            let parts = serverBrowser.value.split(':');
            vultrClient.switchServer(parts[0], parts[1], parts[2]);
        }));
        var preAdInterval = 300000, preAdLastShowTime = 0, preAdGameCount = 0;
        function showPreAd() {
            if (!window.adsbygoogle)
                return console.log('Failed to load video ad API'), void enterGame();
            window.adsbygoogle.push({
                type: 'next',
                adBreakDone: () => {
                    enterGame();
                }
            });
        }
        function showItemInfo(item, isWeapon, isStoreItem) {
            if (player && item)
                if (UTILS.removeAllChildren(itemInfoHolder), itemInfoHolder.classList.add('visible'), UTILS.generateElement({
                        id: 'itemInfoName',
                        text: UTILS.capitalizeFirst(item.name),
                        parent: itemInfoHolder
                    }), UTILS.generateElement({
                        id: 'itemInfoDesc',
                        text: item.desc,
                        parent: itemInfoHolder
                    }), isStoreItem);
                else if (isWeapon)
                    UTILS.generateElement({
                        class: 'itemInfoReq',
                        text: item.type ? 'secondary' : 'primary',
                        parent: itemInfoHolder
                    });
                else {
                    for (var i = 0; i < item.req.length; i += 2)
                        UTILS.generateElement({
                            class: 'itemInfoReq',
                            html: item.req[i] + '<span class=\'itemInfoReqVal\'> x' + item.req[i + 1] + '</span>',
                            parent: itemInfoHolder
                        });
                    item.group.limit && UTILS.generateElement({
                        class: 'itemInfoLmt',
                        text: (player.itemCounts[item.group.id] || 0) + '/' + item.group.limit,
                        parent: itemInfoHolder
                    });
                }
            else
                itemInfoHolder.classList.remove('visible');
        }
        window.adsbygoogle && adsbygoogle.push({ preloadAdBreaks: 'on' }), window.showPreAd = showPreAd;
        var lastDeath, minimapData, mapMarker, allianceNotifications = [], alliancePlayers = [];
        window.isAlly = function(id){
            for(let i = 0;i < alliancePlayers.length;i+=2){
                if(id == alliancePlayers[i]){
                    return true;
                }
            }
        }
let hue = 0;

let replaceInterval = setInterval(() => {
if (CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = ((oldFunc) => function() { if (this.fillStyle == "#8ecc51") this.fillStyle = `hsl(${hue}, 100%, 50%)`; return oldFunc.call(this, ...arguments); })(CanvasRenderingContext2D.prototype.roundRect);
  clearInterval(replaceInterval);
}}, 10);

function changeHue() {
  hue += Math.random() * 3;
}

setInterval(changeHue, 10);

        function allianceNotification(sid, name) {
            allianceNotifications.push({
                sid: sid,
                name: name
            }), updateNotifications();
        }
        function updateNotifications() {
            if (allianceNotifications[0]) {
                var tmpN = allianceNotifications[0];
                UTILS.removeAllChildren(noticationDisplay), noticationDisplay.style.display = 'block', UTILS.generateElement({
                    class: 'notificationText',
                    text: tmpN.name,
                    parent: noticationDisplay
                }), UTILS.generateElement({
                    class: 'notifButton',
                    html: '<i class=\'material-icons\' style=\'font-size:28px;color:#cc5151;\'>&#xE14C;</i>',
                    parent: noticationDisplay,
                    onclick: function () {
                        aJoinReq(0);
                    },
                    hookTouch: !0
                }), UTILS.generateElement({
                    class: 'notifButton',
                    html: '<i class=\'material-icons\' style=\'font-size:28px;color:#8ecc51;\'>&#xE876;</i>',
                    parent: noticationDisplay,
                    onclick: function () {
                        aJoinReq(1);
                    },
                    hookTouch: !0
                });
            } else
                noticationDisplay.style.display = 'none';
        }
        function addAlliance(data) {
            alliances.push(data), 'block' == allianceMenu.style.display && showAllianceMenu();
        }
        function setPlayerTeam(team, isOwner) {
            player && (player.team = team, player.isOwner = isOwner, 'block' == allianceMenu.style.display && showAllianceMenu());
        }
        function setAlliancePlayers(data) {
            alliancePlayers = data, 'block' == allianceMenu.style.display && showAllianceMenu();
        }
        function deleteAlliance(sid) {
            for (var i = alliances.length - 1; i >= 0; i--)
                alliances[i].sid == sid && alliances.splice(i, 1);
            'block' == allianceMenu.style.display && showAllianceMenu();
        }
        function showAllianceMenu() {
            if (player && player.alive) {
                if (closeChat(), storeMenu.style.display = 'none', allianceMenu.style.display = 'block', UTILS.removeAllChildren(allianceHolder), player.team)
                    for (var i = 0; i < alliancePlayers.length; i += 2)
                        !function (i) {
                            var tmp = UTILS.generateElement({
                                class: 'allianceItem',
                                style: 'color:' + (alliancePlayers[i] == player.sid ? '#fff' : 'rgba(255,255,255,0.6)'),
                                text: alliancePlayers[i + 1],
                                parent: allianceHolder
                            });
                            player.isOwner && alliancePlayers[i] != player.sid && UTILS.generateElement({
                                class: 'joinAlBtn',
                                text: 'Kick',
                                onclick: function () {
                                    kickFromClan(alliancePlayers[i]);
                                },
                                hookTouch: !0,
                                parent: tmp
                            });
                        }(i);
                else if (alliances.length)
                    for (i = 0; i < alliances.length; ++i)
                        !function (i) {
                            var tmp = UTILS.generateElement({
                                class: 'allianceItem',
                                style: 'color:' + (alliances[i].sid == player.team ? '#fff' : 'rgba(255,255,255,0.6)'),
                                text: alliances[i].sid,
                                parent: allianceHolder
                            });
                            UTILS.generateElement({
                                class: 'joinAlBtn',
                                text: 'Join',
                                onclick: function () {
                                    sendJoin(i);
                                },
                                hookTouch: !0,
                                parent: tmp
                            });
                        }(i);
                else
                    UTILS.generateElement({
                        class: 'allianceItem',
                        text: 'No Tribes Yet',
                        parent: allianceHolder
                    });
                UTILS.removeAllChildren(allianceManager), player.team ? UTILS.generateElement({
                    class: 'allianceButtonM',
                    style: 'width: 360px',
                    text: player.isOwner ? 'Delete Tribe' : 'Leave Tribe',
                    onclick: function () {
                        leaveAlliance();
                    },
                    hookTouch: !0,
                    parent: allianceManager
                }) : (UTILS.generateElement({
                    tag: 'input',
                    type: 'text',
                    id: 'allianceInput',
                    maxLength: 7,
                    placeholder: 'unique name',
                    ontouchstart: function (ev) {
                        ev.preventDefault();
                        var newValue = prompt('unique name', ev.currentTarget.value);
                        ev.currentTarget.value = newValue.slice(0, 7);
                    },
                    parent: allianceManager
                }), UTILS.generateElement({
                    tag: 'div',
                    class: 'allianceButtonM',
                    style: 'width: 140px;',
                    text: 'Create',
                    onclick: function () {
                        createAlliance();
                    },
                    hookTouch: !0,
                    parent: allianceManager
                }));
            }
        }
        function aJoinReq(join) {
            io.send('11', allianceNotifications[0].sid, join), allianceNotifications.splice(0, 1), updateNotifications();
        }
        function kickFromClan(sid) {
            io.send('12', sid);
        }
        function sendJoin(index) {
            io.send('10', alliances[index].sid);
        }
        function createAlliance() {
            io.send('8', document.getElementById('allianceInput').value);
        }
        function leaveAlliance() {
            allianceNotifications = [], updateNotifications(), io.send('9');
        }
        var tmpPing, mapPings = [];
        function pingMap(x, y) {
            for (var i = 0; i < mapPings.length; ++i)
                if (!mapPings[i].active) {
                    tmpPing = mapPings[i];
                    break;
                }
            tmpPing || (tmpPing = new function () {
                this.init = function (x, y) {
                    this.scale = 0, this.x = x, this.y = y, this.active = !0;
                }, this.update = function (ctxt, delta) {
                    this.active && (this.scale += 0.05 * delta, this.scale >= config.mapPingScale ? this.active = !1 : (ctxt.globalAlpha = 1 - Math.max(0, this.scale / config.mapPingScale), ctxt.beginPath(), ctxt.arc(this.x / config.mapScale * mapDisplay.width, this.y / config.mapScale * mapDisplay.width, this.scale, 0, 2 * Math.PI), ctxt.stroke()));
                };
            }(), mapPings.push(tmpPing)), tmpPing.init(x, y);
        }
        function updateMinimap(data) {
            minimapData = data;
        }
        var currentStoreIndex = 0;
        function updateStoreItems(type, id, index) {
            index ? type ? player.tailIndex = id : player.tails[id] = 1 : type ? player.skinIndex = id : player.skins[id] = 1, 'block' == storeMenu.style.display && generateStoreList();
        }
        function generateStoreList() {
            if (player) {
                UTILS.removeAllChildren(storeHolder);
                for (var index = currentStoreIndex, tmpArray = index ? accessories : hats, i = 0; i < tmpArray.length; ++i)
                    tmpArray[i].dontSell || function (i) {
                        var tmp = UTILS.generateElement({
                            id: 'storeDisplay' + i,
                            class: 'storeItem',
                            onmouseout: function () {
                                showItemInfo();
                            },
                            onmouseover: function () {
                                showItemInfo(tmpArray[i], !1, !0);
                            },
                            parent: storeHolder
                        });
                        UTILS.hookTouchEvents(tmp, !0), UTILS.generateElement({
                            tag: 'img',
                            class: 'hatPreview',
                            src: '../img/' + (index ? 'accessories/access_' : 'hats/hat_') + tmpArray[i].id + (tmpArray[i].topSprite ? '_p' : '') + '.png',
                            parent: tmp
                        }), UTILS.generateElement({
                            tag: 'span',
                            text: tmpArray[i].name,
                            parent: tmp
                        }), (index ? player.tails[tmpArray[i].id] : player.skins[tmpArray[i].id]) ? (index ? player.tailIndex : player.skinIndex) == tmpArray[i].id ? UTILS.generateElement({
                            class: 'joinAlBtn',
                            style: 'margin-top: 5px',
                            text: 'Unequip',
                            onclick: function () {
                                storeEquip(0, index);
                            },
                            hookTouch: !0,
                            parent: tmp
                        }) : UTILS.generateElement({
                            class: 'joinAlBtn',
                            style: 'margin-top: 5px',
                            text: 'Equip',
                            onclick: function () {
                                storeEquip(tmpArray[i].id, index);
                            },
                            hookTouch: !0,
                            parent: tmp
                        }) : (UTILS.generateElement({
                            class: 'joinAlBtn',
                            style: 'margin-top: 5px',
                            text: 'Buy',
                            onclick: function () {
                                storeBuy(tmpArray[i].id, index);
                            },
                            hookTouch: !0,
                            parent: tmp
                        }), UTILS.generateElement({
                            tag: 'span',
                            class: 'itemPrice',
                            text: tmpArray[i].price,
                            parent: tmp
                        }));
                    }(i);
            }
        }
        function storeEquip(id, index) {
            io.send('13c', 0, id, index);
        }
        function storeBuy(id, index) {
            io.send('13c', 1, id, index);
        }
        function hideAllWindows() {
            storeMenu.style.display = 'none', allianceMenu.style.display = 'none', closeChat();
        }
        function updateItems(data, wpn) {
            data && (wpn ? player.weapons = data : player.items = data);
            for (var i = 0; i < items.list.length; ++i) {
                var tmpI = items.weapons.length + i;
                document.getElementById('actionBarItem' + tmpI).style.display = player.items.indexOf(items.list[i].id) >= 0 ? 'inline-block' : 'none';
            }
            for (i = 0; i < items.weapons.length; ++i)
                document.getElementById('actionBarItem' + i).style.display = player.weapons[items.weapons[i].type] == items.weapons[i].id ? 'inline-block' : 'none';
        }
        function setUseNativeResolution(useNative) {
            useNativeResolution = useNative, pixelDensity = useNative && window.devicePixelRatio || 1, nativeResolutionCheckbox.checked = useNative, saveVal('native_resolution', useNative.toString()), resize();
        }
        function updateSkinColorPicker() {
            for (var tmpHTML = '', i = 0; i < config.skinColors.length; ++i)
                tmpHTML += i == skinColor ? '<div class=\'skinColorItem activeSkin\' style=\'background-color:' + config.skinColors[i] + '\' onclick=\'selectSkinColor(' + i + ')\'></div>' : '<div class=\'skinColorItem\' style=\'background-color:' + config.skinColors[i] + '\' onclick=\'selectSkinColor(' + i + ')\'></div>';
            skinColorHolder.innerHTML = tmpHTML;
        }
        var chatBox = document.getElementById('chatBox'), chatHolder = document.getElementById('chatHolder');
        function toggleChat() {
            usingTouch ? setTimeout(function () {
                var chatMessage = prompt('chat message');
                chatMessage && sendChat(chatMessage);
            }, 1) : 'block' == chatHolder.style.display ? (chatBox.value && sendChat(chatBox.value), closeChat()) : (storeMenu.style.display = 'none', allianceMenu.style.display = 'none', chatHolder.style.display = 'block', chatBox.focus(), resetMoveDir()), chatBox.value = '';
        }
        function sendChat(message) {
            io.send('ch', message.slice(0, 30));
        }
        function closeChat() {
            chatBox.value = '', chatHolder.style.display = 'none';
        }
        var usingTouch, lastDir, profanityList = [
                'cunt',
                'whore',
                'fuck',
                'shit',
                'faggot',
                'nigger',
                'nigga',
                'dick',
                'vagina',
                'minge',
                'cock',
                'rape',
                'cum',
                'sex',
                'tits',
                'penis',
                'clit',
                'pussy',
                'meatcurtain',
                'jizz',
                'prune',
                'douche',
                'wanker',
                'damn',
                'bitch',
                'dick',
                'fag',
                'bastard'
            ];
        function receiveChat(sid, message) {
            var tmpPlayer = findPlayerBySID(sid);
            tmpPlayer && (tmpPlayer.chatMessage = function (text) {
                for (var tmpString, i = 0; i < profanityList.length; ++i)
                    if (text.indexOf(profanityList[i]) > -1) {
                        tmpString = '';
                        for (var y = 0; y < profanityList[i].length; ++y)
                            tmpString += tmpString.length ? 'o' : 'M';
                        var re = new RegExp(profanityList[i], 'g');
                        text = text.replace(re, tmpString);
                    }
                return text;
            }(message), tmpPlayer.chatCountdown = config.chatCountdown);
        }
        function resize() {
            screenWidth = window.innerWidth, screenHeight = window.innerHeight;
            var scaleFillNative = Math.max(screenWidth / maxScreenWidth, screenHeight / maxScreenHeight) * pixelDensity;
            gameCanvas.width = screenWidth * pixelDensity, gameCanvas.height = screenHeight * pixelDensity, gameCanvas.style.width = screenWidth + 'px', gameCanvas.style.height = screenHeight + 'px', mainContext.setTransform(scaleFillNative, 0, 0, scaleFillNative, (screenWidth * pixelDensity - maxScreenWidth * scaleFillNative) / 2, (screenHeight * pixelDensity - maxScreenHeight * scaleFillNative) / 2);
        }
        function setUsingTouch(using) {
            (usingTouch = using) ? guideCard.classList.add('touch') : guideCard.classList.remove('touch');
        }
        function touchEnd(ev) {
            ev.preventDefault(), ev.stopPropagation(), setUsingTouch(!0);
            for (var i = 0; i < ev.changedTouches.length; i++) {
                var t = ev.changedTouches[i];
                t.identifier == controllingTouch.id ? (controllingTouch.id = -1, sendMoveDir()) : t.identifier == attackingTouch.id && (attackingTouch.id = -1, player.buildIndex >= 0 && (attackState = 1, sendAtckState()), attackState = 0, sendAtckState());
            }
        }
        function getAttackDir() {
            return player ? (-1 != attackingTouch.id ? lastDir = Math.atan2(attackingTouch.currentY - attackingTouch.startY, attackingTouch.currentX - attackingTouch.startX) : player.lockDir || usingTouch || (lastDir = Math.atan2(mouseY - screenHeight / 2, mouseX - screenWidth / 2)), UTILS.fixTo(lastDir || 0, 2)) : 0;
        }
        window.addEventListener('resize', UTILS.checkTrusted(resize)), resize(), setUsingTouch(!1), window.setUsingTouch = setUsingTouch, gameCanvas.addEventListener('touchmove', UTILS.checkTrusted(function (ev) {
            ev.preventDefault(), ev.stopPropagation(), setUsingTouch(!0);
            for (var i = 0; i < ev.changedTouches.length; i++) {
                var t = ev.changedTouches[i];
                t.identifier == controllingTouch.id ? (controllingTouch.currentX = t.pageX, controllingTouch.currentY = t.pageY, sendMoveDir()) : t.identifier == attackingTouch.id && (attackingTouch.currentX = t.pageX, attackingTouch.currentY = t.pageY, attackState = 1);
            }
        }), !1), gameCanvas.addEventListener('touchstart', UTILS.checkTrusted(function (ev) {
            if (!inGame)
                return ev.preventDefault(), !1;
            ev.preventDefault(), ev.stopPropagation(), setUsingTouch(!0);
            for (var i = 0; i < ev.changedTouches.length; i++) {
                var t = ev.changedTouches[i];
                t.pageX < document.body.scrollWidth / 2 && -1 == controllingTouch.id ? (controllingTouch.id = t.identifier, controllingTouch.startX = controllingTouch.currentX = t.pageX, controllingTouch.startY = controllingTouch.currentY = t.pageY, sendMoveDir()) : t.pageX > document.body.scrollWidth / 2 && -1 == attackingTouch.id && (attackingTouch.id = t.identifier, attackingTouch.startX = attackingTouch.currentX = t.pageX, attackingTouch.startY = attackingTouch.currentY = t.pageY, player.buildIndex < 0 && (attackState = 1, sendAtckState()));
            }
        }), !1), gameCanvas.addEventListener('touchend', UTILS.checkTrusted(touchEnd), !1), gameCanvas.addEventListener('touchcancel', UTILS.checkTrusted(touchEnd), !1), gameCanvas.addEventListener('touchleave', UTILS.checkTrusted(touchEnd), !1), gameCanvas.addEventListener('mousemove', function (e) {
            e.preventDefault(), e.stopPropagation(), setUsingTouch(!1), mouseX = e.clientX, mouseY = e.clientY;
        }, !1), gameCanvas.addEventListener('mousedown', function (e) {
            setUsingTouch(!1), 1 != attackState && (attackState = 1, sendAtckState());
        }, !1), gameCanvas.addEventListener('mouseup', function (e) {
            setUsingTouch(!1), 0 != attackState && (attackState = 0, sendAtckState());
        }, !1);
        var keys = {}, moveKeys = {
                87: [
                    0,
                    -1
                ],
                38: [
                    0,
                    -1
                ],
                83: [
                    0,
                    1
                ],
                40: [
                    0,
                    1
                ],
                65: [
                    -1,
                    0
                ],
                37: [
                    -1,
                    0
                ],
                68: [
                    1,
                    0
                ],
                39: [
                    1,
                    0
                ]
            };
        function resetMoveDir() {
            keys = {}, io.send('rmd');
        }
        function keysActive() {
            return 'block' != allianceMenu.style.display && 'block' != chatHolder.style.display;
        }
        function sendAtckState() {
            player && player.alive && io.send('c', attackState, player.buildIndex >= 0 ? getAttackDir() : null);
        }
        window.addEventListener('keydown', UTILS.checkTrusted(function (event) {
            var keyNum = event.which || event.keyCode || 0;
            27 == keyNum ? hideAllWindows() : player && player.alive && keysActive() && (keys[keyNum] || (keys[keyNum] = 1, 69 == keyNum ? io.send('7', 1) : 67 == keyNum ? (mapMarker || (mapMarker = {}), mapMarker.x = player.x, mapMarker.y = player.y) : 88 == keyNum ? (player.lockDir = player.lockDir ? 0 : 1, io.send('7', 0)) : null != player.weapons[keyNum - 49] ? selectToBuild(player.weapons[keyNum - 49], !0) : null != player.items[keyNum - 49 - player.weapons.length] ? selectToBuild(player.items[keyNum - 49 - player.weapons.length]) : 81 == keyNum ? selectToBuild(player.items[0]) : 82 == keyNum ? sendMapPing() : moveKeys[keyNum] ? sendMoveDir() : 32 == keyNum && (attackState = 1, sendAtckState())));
        })), window.addEventListener('keyup', UTILS.checkTrusted(function (event) {
            if (player && player.alive) {
                var keyNum = event.which || event.keyCode || 0;
                13 == keyNum ? toggleChat() : keysActive() && keys[keyNum] && (keys[keyNum] = 0, moveKeys[keyNum] ? sendMoveDir() : 32 == keyNum && (attackState = 0, sendAtckState()));
            }
        }));
        var lastMoveDir = void 0;
        function sendMoveDir() {
            var newMoveDir = function () {
                var dx = 0, dy = 0;
                if (-1 != controllingTouch.id)
                    dx += controllingTouch.currentX - controllingTouch.startX, dy += controllingTouch.currentY - controllingTouch.startY;
                else
                    for (var key in moveKeys) {
                        var tmpDir = moveKeys[key];
                        dx += !!keys[key] * tmpDir[0], dy += !!keys[key] * tmpDir[1];
                    }
                return 0 == dx && 0 == dy ? void 0 : UTILS.fixTo(Math.atan2(dy, dx), 2);
            }();
            (null == lastMoveDir || null == newMoveDir || Math.abs(newMoveDir - lastMoveDir) > 0.3) && (io.send('33', newMoveDir), lastMoveDir = newMoveDir);
        }
        function sendMapPing() {
            io.send('14', 1);
        }
        function selectToBuild(index, wpn) {
            io.send('5', index, wpn);
        }
        function enterGame() {
            window.FRVR && window.FRVR.tracker.levelStart('game_start'), saveVal('moo_name', nameInput.value), !inGame && io.connected && (inGame = !0, Sound.stop('menu'), showLoadingText('Loading...'), io.send('sp', {
                name: nameInput.value,
                moofoll: moofoll,
                skin: skinColor
            })), function () {
                var cookieIcon = document.getElementById('ot-sdk-btn-floating');
                cookieIcon && (cookieIcon.style.display = 'none');
            }();
        }
        var firstSetup = !0;
        function setupGame(yourSID) {
            loadingText.style.display = 'none', menuCardHolder.style.display = 'block', mainMenu.style.display = 'none', keys = {}, playerSID = yourSID, attackState = 0, inGame = !0, firstSetup && (firstSetup = !1, gameObjects.length = 0);
        }
        function showText(x, y, value, type) {
            textManager.showText(x, y, 50, 0.18, 500, Math.abs(value), value >= 0 ? '#fff' : '#8ecc51');
        }
        var deathTextScale = 99999;
        function killPlayer() {
            inGame = !1, function () {
                var cookieIcon = document.getElementById('ot-sdk-btn-floating');
                cookieIcon && (cookieIcon.style.display = 'block');
            }();
            try {
                factorem.refreshAds([2], !0);
            } catch (e) {
            }
            gameUI.style.display = 'none', hideAllWindows(), lastDeath = {
                x: player.x,
                y: player.y
            }, loadingText.style.display = 'none', diedText.style.display = 'block', diedText.style.fontSize = '0px', deathTextScale = 0, setTimeout(function () {
                menuCardHolder.style.display = 'block', mainMenu.style.display = 'block', diedText.style.display = 'none';
                killNum = 0;
            }, config.deathFadeout), updateServerList();
        }
        function killObjects(sid) {
            player && objectManager.removeAllItems(sid);
        }
        function killObject(sid) {
            objectManager.disableBySid(sid);
        }
        let killNum = 0;
        function updateStatusDisplay() {
            scoreDisplay.innerText = player.points,
                foodDisplay.innerText = player.food,
                woodDisplay.innerText = player.wood,
                stoneDisplay.innerText = player.stone
            if(player.kills > killCounter.innerText){
                killNum++;
                io.send("ch", "omg - GG");
            }
            killCounter.innerText = player.kills;
        }
        var iconSprites = {}, icons = [
                'crown',
                'skull'
            ], tmpList = [];
        function updateUpgrades(points, age) {
            if (player.upgradePoints = points, player.upgrAge = age, points > 0) {
                tmpList.length = 0, UTILS.removeAllChildren(upgradeHolder);
                for (var i = 0; i < items.weapons.length; ++i)
                    items.weapons[i].age == age && (null == items.weapons[i].pre || player.weapons.indexOf(items.weapons[i].pre) >= 0) && (UTILS.generateElement({
                        id: 'upgradeItem' + i,
                        class: 'actionBarItem',
                        onmouseout: function () {
                            showItemInfo();
                        },
                        parent: upgradeHolder
                    }).style.backgroundImage = document.getElementById('actionBarItem' + i).style.backgroundImage, tmpList.push(i));
                for (i = 0; i < items.list.length; ++i)
                    if (items.list[i].age == age && (null == items.list[i].pre || player.items.indexOf(items.list[i].pre) >= 0)) {
                        var tmpI = items.weapons.length + i;
                        UTILS.generateElement({
                            id: 'upgradeItem' + tmpI,
                            class: 'actionBarItem',
                            onmouseout: function () {
                                showItemInfo();
                            },
                            parent: upgradeHolder
                        }).style.backgroundImage = document.getElementById('actionBarItem' + tmpI).style.backgroundImage, tmpList.push(tmpI);
                    }
                for (i = 0; i < tmpList.length; i++)
                    !function (i) {
                        var tmpItem = document.getElementById('upgradeItem' + i);
                        tmpItem.onmouseover = function () {
                            items.weapons[i] ? showItemInfo(items.weapons[i], !0) : showItemInfo(items.list[i - items.weapons.length]);
                        }, tmpItem.onclick = UTILS.checkTrusted(function () {
                            io.send('6', i);
                        }), UTILS.hookTouchEvents(tmpItem);
                    }(tmpList[i]);
                tmpList.length ? (upgradeHolder.style.display = 'block', upgradeCounter.style.display = 'block', upgradeCounter.innerHTML = 'SELECT ITEMS (' + points + ')') : (upgradeHolder.style.display = 'none', upgradeCounter.style.display = 'none', showItemInfo());
            } else
                upgradeHolder.style.display = 'none', upgradeCounter.style.display = 'none', showItemInfo();
        }
        function updateAge(xp, mxp, age) {
            null != xp && (player.XP = xp), null != mxp && (player.maxXP = mxp), null != age && (player.age = age), age == config.maxAge ? (ageText.innerHTML = 'MAX AGE', ageBarBody.style.width = '100%') : (ageText.innerHTML = 'AGE ' + player.age, ageBarBody.style.width = player.XP / player.maxXP * 100 + '%');
        }
        function updateLeaderboard(data) {
            UTILS.removeAllChildren(leaderboardData);
            for (var tmpC = 1, i = 0; i < data.length; i += 3)
                !function (i) {
                    UTILS.generateElement({
                        class: 'leaderHolder',
                        parent: leaderboardData,
                        children: [
                            UTILS.generateElement({
                                class: 'leaderboardItem',
                                style: 'color:' + (data[i] == playerSID ? '#fff' : 'rgba(255,255,255,0.6)'),
                                text: tmpC + '. ' + ('' != data[i + 1] ? data[i + 1] : 'unknown')
                            }),
                            UTILS.generateElement({
                                class: 'leaderScore',
                                text: UTILS.kFormat(data[i + 2]) || '0'
                            })
                        ]
                    });
                }(i), tmpC++;
        }
        let lastAttackDir = null;
        function renderControl(startX, startY, currentX, currentY) {
            mainContext.save(), mainContext.setTransform(1, 0, 0, 1, 0, 0), mainContext.scale(pixelDensity, pixelDensity);
            var controlRadius = 50;
            mainContext.beginPath(), mainContext.arc(startX, startY, controlRadius, 0, 2 * Math.PI, !1), mainContext.closePath(), mainContext.fillStyle = 'rgba(255, 255, 255, 0.3)', mainContext.fill(), controlRadius = 50;
            var offsetX = currentX - startX, offsetY = currentY - startY, mag = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2)), divisor = mag > controlRadius ? mag / controlRadius : 1;
            offsetX /= divisor, offsetY /= divisor, mainContext.beginPath(), mainContext.arc(startX + offsetX, startY + offsetY, 0.5 * controlRadius, 0, 2 * Math.PI, !1), mainContext.closePath(), mainContext.fillStyle = 'white', mainContext.fill(), mainContext.restore();
        }
        function renderProjectiles(layer, xOffset, yOffset) {
            for (var i = 0; i < projectiles.length; ++i)
                (tmpObj = projectiles[i]).active && tmpObj.layer == layer && (tmpObj.update(delta), tmpObj.active && isOnScreen(tmpObj.x - xOffset, tmpObj.y - yOffset, tmpObj.scale) && (mainContext.save(), mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset), mainContext.rotate(tmpObj.dir), renderProjectile(0, 0, tmpObj, mainContext, 1), mainContext.restore()));
        }
        var projectileSprites = {};
        function renderProjectile(x, y, obj, ctxt, debug) {
            if (obj.src) {
                var tmpSrc = items.projectiles[obj.indx].src, tmpSprite = projectileSprites[tmpSrc];
                tmpSprite || ((tmpSprite = new Image()).onload = function () {
                    this.isLoaded = !0;
                }, tmpSprite.src = '.././img/weapons/' + tmpSrc + '.png', projectileSprites[tmpSrc] = tmpSprite), tmpSprite.isLoaded && ctxt.drawImage(tmpSprite, x - obj.scale / 2, y - obj.scale / 2, obj.scale, obj.scale);
            } else
                1 == obj.indx && (ctxt.fillStyle = '#939393', renderCircle(x, y, obj.scale, ctxt));
        }
        function renderWaterBodies(xOffset, yOffset, ctxt, padding) {
            var tmpW = config.riverWidth + padding, tmpY = config.mapScale / 2 - yOffset - tmpW / 2;
            tmpY < maxScreenHeight && tmpY + tmpW > 0 && ctxt.fillRect(0, tmpY, maxScreenWidth, tmpW);
        }
        function renderGameObjects(layer, xOffset, yOffset) {
            for (var tmpSprite, tmpX, tmpY, i = 0; i < gameObjects.length; ++i)
                (tmpObj = gameObjects[i]).active && (tmpX = tmpObj.x + tmpObj.xWiggle - xOffset, tmpY = tmpObj.y + tmpObj.yWiggle - yOffset, 0 == layer && tmpObj.update(delta), tmpObj.layer == layer && isOnScreen(tmpX, tmpY, tmpObj.scale + (tmpObj.blocker || 0)) && (mainContext.globalAlpha = tmpObj.hideFromEnemy ? 0.6 : 1, tmpObj.isItem ? (tmpSprite = getItemSprite(tmpObj), mainContext.save(), mainContext.translate(tmpX, tmpY), mainContext.rotate(tmpObj.dir), mainContext.drawImage(tmpSprite, -tmpSprite.width / 2, -tmpSprite.height / 2), tmpObj.blocker && (mainContext.strokeStyle = '#db6e6e', mainContext.globalAlpha = 0.3, mainContext.lineWidth = 6, renderCircle(0, 0, tmpObj.blocker, mainContext, !1, !0)), mainContext.restore()) : (tmpSprite = getResSprite(tmpObj), mainContext.drawImage(tmpSprite, tmpX - tmpSprite.width / 2, tmpY - tmpSprite.height / 2))));
        }
        function gatherAnimation(sid, didHit, index) {
            (tmpObj = findPlayerBySID(sid)) && tmpObj.startAnim(didHit, index);
        }
        function renderPlayers(xOffset, yOffset, zIndex) {
            mainContext.globalAlpha = 1;
            for (var i = 0; i < players.length; ++i)
                (tmpObj = players[i]).zIndex == zIndex && (tmpObj.animate(delta), tmpObj.visible && (tmpObj.skinRot += 0.002 * delta, tmpDir = (tmpObj == player ? getAttackDir() : tmpObj.dir) + tmpObj.dirPlus, mainContext.save(), mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset), mainContext.rotate(tmpDir), renderPlayer(tmpObj, mainContext), mainContext.restore()));
        }
        function renderPlayer(e, t) {
            (t = t || mainContext).lineWidth = 5.5, t.lineJoin = 'miter';
            var i = Math.PI / 4 * (items.weapons[e.weaponIndex].armS || 1), n = e.buildIndex < 0 && items.weapons[e.weaponIndex].hndS || 1, s = e.buildIndex < 0 && items.weapons[e.weaponIndex].hndD || 1;
            if (e.tailIndex > 0 && function (index, ctxt, owner) {
                    if (!(tmpSkin = accessSprites[index])) {
                        var tmpImage = new Image();
                        tmpImage.onload = function () {
                            this.isLoaded = !0, this.onload = null;
                        }, tmpImage.src = '.././img/accessories/access_' + index + '.png', accessSprites[index] = tmpImage, tmpSkin = tmpImage;
                    }
                    var tmpObj = accessPointers[index];
                    if (!tmpObj) {
                        for (var i = 0; i < accessories.length; ++i)
                            if (accessories[i].id == index) {
                                tmpObj = accessories[i];
                                break;
                            }
                        accessPointers[index] = tmpObj;
                    }
                    tmpSkin.isLoaded && (ctxt.save(), ctxt.translate(-20 - (tmpObj.xOff || 0), 0), tmpObj.spin && ctxt.rotate(owner.skinRot), ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale), ctxt.restore());
                }(e.tailIndex, t, e), e.buildIndex < 0 && !items.weapons[e.weaponIndex].aboveHand && (renderTool(items.weapons[e.weaponIndex], config.weaponVariants[e.weaponVariant].src, e.scale, 0, t), null == items.weapons[e.weaponIndex].projectile || items.weapons[e.weaponIndex].hideProjectile || renderProjectile(e.scale, 0, items.projectiles[items.weapons[e.weaponIndex].projectile], mainContext)), t.fillStyle = config.skinColors[e.skinColor], renderCircle(e.scale * Math.cos(i), e.scale * Math.sin(i), 14), renderCircle(e.scale * s * Math.cos(-i * n), e.scale * s * Math.sin(-i * n), 14), e.buildIndex < 0 && items.weapons[e.weaponIndex].aboveHand && (renderTool(items.weapons[e.weaponIndex], config.weaponVariants[e.weaponVariant].src, e.scale, 0, t), null == items.weapons[e.weaponIndex].projectile || items.weapons[e.weaponIndex].hideProjectile || renderProjectile(e.scale, 0, items.projectiles[items.weapons[e.weaponIndex].projectile], mainContext)), e.buildIndex >= 0) {
                var o = getItemSprite(items.list[e.buildIndex]);
                t.drawImage(o, e.scale - items.list[e.buildIndex].holdOffset, -o.width / 2);
            }
            renderCircle(0, 0, e.scale, t), e.skinIndex > 0 && (t.rotate(Math.PI / 2), function renderSkin(index, ctxt, parentSkin, owner) {
                if (!(tmpSkin = skinSprites[index])) {
                    var tmpImage = new Image();
                    tmpImage.onload = function () {
                        this.isLoaded = !0, this.onload = null;
                    }, tmpImage.src = '.././img/hats/hat_' + index + '.png', skinSprites[index] = tmpImage, tmpSkin = tmpImage;
                }
                var tmpObj = parentSkin || skinPointers[index];
                if (!tmpObj) {
                    for (var i = 0; i < hats.length; ++i)
                        if (hats[i].id == index) {
                            tmpObj = hats[i];
                            break;
                        }
                    skinPointers[index] = tmpObj;
                }
                tmpSkin.isLoaded && ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale), !parentSkin && tmpObj.topSprite && (ctxt.save(), ctxt.rotate(owner.skinRot), renderSkin(index + '_top', ctxt, tmpObj, owner), ctxt.restore());
            }(e.skinIndex, t, null, e));
        }
        var tmpSkin, skinSprites = {}, skinPointers = {}, accessSprites = {}, accessPointers = {}, toolSprites = {};
        function renderTool(obj, variant, x, y, ctxt) {
            var tmpSrc = obj.src + (variant || ''), tmpSprite = toolSprites[tmpSrc];
            tmpSprite || ((tmpSprite = new Image()).onload = function () {
                this.isLoaded = !0;
            }, tmpSprite.src = '.././img/weapons/' + tmpSrc + '.png', toolSprites[tmpSrc] = tmpSprite), tmpSprite.isLoaded && ctxt.drawImage(tmpSprite, x + obj.xOff - obj.length / 2, y + obj.yOff - obj.width / 2, obj.length, obj.width);
        }
        var gameObjectSprites = {};
        function getResSprite(obj) {
            var biomeID = obj.y >= config.mapScale - config.snowBiomeTop ? 2 : obj.y <= config.snowBiomeTop ? 1 : 0, tmpIndex = obj.type + '_' + obj.scale + '_' + biomeID, tmpSprite = gameObjectSprites[tmpIndex];
            if (!tmpSprite) {
                var tmpCanvas = document.createElement('canvas');
                tmpCanvas.width = tmpCanvas.height = 2.1 * obj.scale + 5.5;
                var tmpContext = tmpCanvas.getContext('2d');
                if (tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2), tmpContext.rotate(UTILS.randFloat(0, Math.PI)), tmpContext.strokeStyle = outlineColor, tmpContext.lineWidth = 5.5, 0 == obj.type)
                    for (var tmpScale, i = 0; i < 2; ++i)
                        renderStar(tmpContext, 7, tmpScale = tmpObj.scale * (i ? 0.5 : 1), 0.7 * tmpScale), tmpContext.fillStyle = biomeID ? i ? '#fff' : '#e3f1f4' : i ? '#b4db62' : '#9ebf57', tmpContext.fill(), i || tmpContext.stroke();
                else if (1 == obj.type)
                    if (2 == biomeID)
                        tmpContext.fillStyle = '#606060', renderStar(tmpContext, 6, 0.3 * obj.scale, 0.71 * obj.scale), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = '#89a54c', renderCircle(0, 0, 0.55 * obj.scale, tmpContext), tmpContext.fillStyle = '#a5c65b', renderCircle(0, 0, 0.3 * obj.scale, tmpContext, !0);
                    else {
                        var tmpRange;
                        !function (ctxt, spikes, outer, inner) {
                            var tmpOuter, rot = Math.PI / 2 * 3, step = Math.PI / 6;
                            ctxt.beginPath(), ctxt.moveTo(0, -inner);
                            for (var i = 0; i < 6; i++)
                                tmpOuter = UTILS.randInt(outer + 0.9, 1.2 * outer), ctxt.quadraticCurveTo(Math.cos(rot + step) * tmpOuter, Math.sin(rot + step) * tmpOuter, Math.cos(rot + 2 * step) * inner, Math.sin(rot + 2 * step) * inner), rot += 2 * step;
                            ctxt.lineTo(0, -inner), ctxt.closePath();
                        }(tmpContext, 0, tmpObj.scale, 0.7 * tmpObj.scale), tmpContext.fillStyle = biomeID ? '#e3f1f4' : '#89a54c', tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = biomeID ? '#6a64af' : '#c15555';
                        var rotVal = mathPI2 / 4;
                        for (i = 0; i < 4; ++i)
                            renderCircle((tmpRange = UTILS.randInt(tmpObj.scale / 3.5, tmpObj.scale / 2.3)) * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(10, 12), tmpContext);
                    }
                else
                    2 != obj.type && 3 != obj.type || (tmpContext.fillStyle = 2 == obj.type ? 2 == biomeID ? '#938d77' : '#939393' : '#e0c655', renderStar(tmpContext, 3, obj.scale, obj.scale), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = 2 == obj.type ? 2 == biomeID ? '#b2ab90' : '#bcbcbc' : '#ebdca3', renderStar(tmpContext, 3, 0.55 * obj.scale, 0.65 * obj.scale), tmpContext.fill());
                tmpSprite = tmpCanvas, gameObjectSprites[tmpIndex] = tmpSprite;
            }
            return tmpSprite;
        }
        var itemSprites = [];
        function getItemSprite(obj, asIcon) {
            var tmpSprite = itemSprites[obj.id];
            if (!tmpSprite || asIcon) {
                var tmpCanvas = document.createElement('canvas');
                tmpCanvas.width = tmpCanvas.height = 2.5 * obj.scale + 5.5 + (items.list[obj.id].spritePadding || 0);
                var tmpContext = tmpCanvas.getContext('2d');
                if (tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2), tmpContext.rotate(asIcon ? 0 : Math.PI / 2), tmpContext.strokeStyle = outlineColor, tmpContext.lineWidth = 5.5 * (asIcon ? tmpCanvas.width / 81 : 1), 'apple' == obj.name) {
                    tmpContext.fillStyle = '#c15555', renderCircle(0, 0, obj.scale, tmpContext), tmpContext.fillStyle = '#89a54c';
                    var leafDir = -Math.PI / 2;
                    !function (x, y, l, r, ctxt) {
                        var endX = x + 25 * Math.cos(r), endY = y + 25 * Math.sin(r);
                        ctxt.moveTo(x, y), ctxt.beginPath(), ctxt.quadraticCurveTo((x + endX) / 2 + 10 * Math.cos(r + Math.PI / 2), (y + endY) / 2 + 10 * Math.sin(r + Math.PI / 2), endX, endY), ctxt.quadraticCurveTo((x + endX) / 2 - 10 * Math.cos(r + Math.PI / 2), (y + endY) / 2 - 10 * Math.sin(r + Math.PI / 2), x, y), ctxt.closePath(), ctxt.fill(), ctxt.stroke();
                    }(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir), 0, leafDir + Math.PI / 2, tmpContext);
                } else if ('cookie' == obj.name) {
                    tmpContext.fillStyle = '#cca861', renderCircle(0, 0, obj.scale, tmpContext), tmpContext.fillStyle = '#937c4b';
                    for (var rotVal = mathPI2 / (chips = 4), i = 0; i < chips; ++i)
                        renderCircle((tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7)) * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(4, 5), tmpContext, !0);
                } else if ('cheese' == obj.name) {
                    var chips, tmpRange;
                    for (tmpContext.fillStyle = '#f4f3ac', renderCircle(0, 0, obj.scale, tmpContext), tmpContext.fillStyle = '#c3c28b', rotVal = mathPI2 / (chips = 4), i = 0; i < chips; ++i)
                        renderCircle((tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7)) * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(4, 5), tmpContext, !0);
                } else if ('wood wall' == obj.name || 'stone wall' == obj.name || 'castle wall' == obj.name) {
                    tmpContext.fillStyle = 'castle wall' == obj.name ? '#83898e' : 'wood wall' == obj.name ? '#a5974c' : '#939393';
                    var sides = 'castle wall' == obj.name ? 4 : 3;
                    renderStar(tmpContext, sides, 1.1 * obj.scale, 1.1 * obj.scale), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = 'castle wall' == obj.name ? '#9da4aa' : 'wood wall' == obj.name ? '#c9b758' : '#bcbcbc', renderStar(tmpContext, sides, 0.65 * obj.scale, 0.65 * obj.scale), tmpContext.fill();
                } else if ('spikes' == obj.name || 'greater spikes' == obj.name || 'poison spikes' == obj.name || 'spinning spikes' == obj.name) {
                    tmpContext.fillStyle = 'poison spikes' == obj.name ? '#7b935d' : '#939393';
                    var tmpScale = 0.6 * obj.scale;
                    renderStar(tmpContext, 'spikes' == obj.name ? 5 : 6, obj.scale, tmpScale), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = '#a5974c', renderCircle(0, 0, tmpScale, tmpContext), tmpContext.fillStyle = '#c9b758', renderCircle(0, 0, tmpScale / 2, tmpContext, !0);
                } else if ('windmill' == obj.name || 'faster windmill' == obj.name || 'power mill' == obj.name)
                    tmpContext.fillStyle = '#a5974c', renderCircle(0, 0, obj.scale, tmpContext), tmpContext.fillStyle = '#c9b758', renderRectCircle(0, 0, 1.5 * obj.scale, 29, 4, tmpContext), tmpContext.fillStyle = '#a5974c', renderCircle(0, 0, 0.5 * obj.scale, tmpContext);
                else if ('mine' == obj.name)
                    tmpContext.fillStyle = '#939393', renderStar(tmpContext, 3, obj.scale, obj.scale), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = '#bcbcbc', renderStar(tmpContext, 3, 0.55 * obj.scale, 0.65 * obj.scale), tmpContext.fill();
                else if ('sapling' == obj.name)
                    for (i = 0; i < 2; ++i)
                        renderStar(tmpContext, 7, tmpScale = obj.scale * (i ? 0.5 : 1), 0.7 * tmpScale), tmpContext.fillStyle = i ? '#b4db62' : '#9ebf57', tmpContext.fill(), i || tmpContext.stroke();
                else if ('pit trap' == obj.name)
                    tmpContext.fillStyle = '#a5974c', renderStar(tmpContext, 3, 1.1 * obj.scale, 1.1 * obj.scale), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = outlineColor, renderStar(tmpContext, 3, 0.65 * obj.scale, 0.65 * obj.scale), tmpContext.fill();
                else if ('boost pad' == obj.name)
                    tmpContext.fillStyle = '#7e7f82', renderRect(0, 0, 2 * obj.scale, 2 * obj.scale, tmpContext), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = '#dbd97d', function (s, ctx) {
                        ctx = ctx || mainContext;
                        var h = s * (Math.sqrt(3) / 2);
                        ctx.beginPath(), ctx.moveTo(0, -h / 2), ctx.lineTo(-s / 2, h / 2), ctx.lineTo(s / 2, h / 2), ctx.lineTo(0, -h / 2), ctx.fill(), ctx.closePath();
                    }(1 * obj.scale, tmpContext);
                else if ('turret' == obj.name)
                    tmpContext.fillStyle = '#a5974c', renderCircle(0, 0, obj.scale, tmpContext), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = '#939393', renderRect(0, -25, 0.9 * obj.scale, 50, tmpContext), renderCircle(0, 0, 0.6 * obj.scale, tmpContext), tmpContext.fill(), tmpContext.stroke();
                else if ('platform' == obj.name) {
                    tmpContext.fillStyle = '#cebd5f';
                    var tmpS = 2 * obj.scale, tmpW = tmpS / 4, tmpX = -obj.scale / 2;
                    for (i = 0; i < 4; ++i)
                        renderRect(tmpX - tmpW / 2, 0, tmpW, 2 * obj.scale, tmpContext), tmpContext.fill(), tmpContext.stroke(), tmpX += tmpS / 4;
                } else
                    'healing pad' == obj.name ? (tmpContext.fillStyle = '#7e7f82', renderRect(0, 0, 2 * obj.scale, 2 * obj.scale, tmpContext), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = '#db6e6e', renderRectCircle(0, 0, 0.65 * obj.scale, 20, 4, tmpContext, !0)) : 'spawn pad' == obj.name ? (tmpContext.fillStyle = '#7e7f82', renderRect(0, 0, 2 * obj.scale, 2 * obj.scale, tmpContext), tmpContext.fill(), tmpContext.stroke(), tmpContext.fillStyle = '#71aad6', renderCircle(0, 0, 0.6 * obj.scale, tmpContext)) : 'blocker' == obj.name ? (tmpContext.fillStyle = '#7e7f82', renderCircle(0, 0, obj.scale, tmpContext), tmpContext.fill(), tmpContext.stroke(), tmpContext.rotate(Math.PI / 4), tmpContext.fillStyle = '#db6e6e', renderRectCircle(0, 0, 0.65 * obj.scale, 20, 4, tmpContext, !0)) : 'teleporter' == obj.name && (tmpContext.fillStyle = '#7e7f82', renderCircle(0, 0, obj.scale, tmpContext), tmpContext.fill(), tmpContext.stroke(), tmpContext.rotate(Math.PI / 4), tmpContext.fillStyle = '#d76edb', renderCircle(0, 0, 0.5 * obj.scale, tmpContext, !0));
                tmpSprite = tmpCanvas, asIcon || (itemSprites[obj.id] = tmpSprite);
            }
            return tmpSprite;
        }
        function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
            (tmpContext = tmpContext || mainContext).beginPath(), tmpContext.arc(x, y, scale, 0, 2 * Math.PI), dontFill || tmpContext.fill(), dontStroke || tmpContext.stroke();
        }
        function renderStar(ctxt, spikes, outer, inner) {
            var x, y, rot = Math.PI / 2 * 3, step = Math.PI / spikes;
            ctxt.beginPath(), ctxt.moveTo(0, -outer);
            for (var i = 0; i < spikes; i++)
                x = Math.cos(rot) * outer, y = Math.sin(rot) * outer, ctxt.lineTo(x, y), rot += step, x = Math.cos(rot) * inner, y = Math.sin(rot) * inner, ctxt.lineTo(x, y), rot += step;
            ctxt.lineTo(0, -outer), ctxt.closePath();
        }
        function renderRect(x, y, w, h, ctxt, stroke) {
            ctxt.fillRect(x - w / 2, y - h / 2, w, h), stroke || ctxt.strokeRect(x - w / 2, y - h / 2, w, h);
        }
        function renderRectCircle(x, y, s, sw, seg, ctxt, stroke) {
            ctxt.save(), ctxt.translate(x, y), seg = Math.ceil(seg / 2);
            for (var i = 0; i < seg; i++)
                renderRect(0, 0, 2 * s, sw, ctxt, stroke), ctxt.rotate(Math.PI / seg);
            ctxt.restore();
        }
        function loadGameObject(data) {
            for (var i = 0; i < data.length;)
                objectManager.add(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], items.list[data[i + 6]], !0, data[i + 7] >= 0 ? { sid: data[i + 7] } : null), i += 8;
        }
        function wiggleGameObject(dir, sid) {
            (tmpObj = findObjectBySid(sid)) && (tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir), tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir));
        }
        function shootTurret(sid, dir) {
            (tmpObj = findObjectBySid(sid)) && (tmpObj.dir = dir, tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir + Math.PI), tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir + Math.PI));
        }
        function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
            inWindow && (projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer).sid = sid);
        }
        function remProjectile(sid, range) {
            for (var i = 0; i < projectiles.length; ++i)
                projectiles[i].sid == sid && (projectiles[i].range = range);
        }
        function animateAI(sid) {
            (tmpObj = findAIBySID(sid)) && tmpObj.startAnim();
        }
        function loadAI(data) {
            for (var i = 0; i < ais.length; ++i)
                ais[i].forcePos = !ais[i].visible, ais[i].visible = !1;
            if (data) {
                var tmpTime = Date.now();
                for (i = 0; i < data.length;)
                    (tmpObj = findAIBySID(data[i])) ? (tmpObj.index = data[i + 1], tmpObj.t1 = void 0 === tmpObj.t2 ? tmpTime : tmpObj.t2, tmpObj.t2 = tmpTime, tmpObj.x1 = tmpObj.x, tmpObj.y1 = tmpObj.y, tmpObj.x2 = data[i + 2], tmpObj.y2 = data[i + 3], tmpObj.d1 = void 0 === tmpObj.d2 ? data[i + 4] : tmpObj.d2, tmpObj.d2 = data[i + 4], tmpObj.health = data[i + 5], tmpObj.dt = 0, tmpObj.visible = !0) : ((tmpObj = aiManager.spawn(data[i + 2], data[i + 3], data[i + 4], data[i + 1])).x2 = tmpObj.x, tmpObj.y2 = tmpObj.y, tmpObj.d2 = tmpObj.dir, tmpObj.health = data[i + 5], aiManager.aiTypes[data[i + 1]].name || (tmpObj.name = config.cowNames[data[i + 6]]), tmpObj.forcePos = !0, tmpObj.sid = data[i], tmpObj.visible = !0), i += 7;
            }
        }
        var aiSprites = {};
        function renderAI(obj, ctxt) {
            var tmpIndx = obj.index, tmpSprite = aiSprites[tmpIndx];
            if (!tmpSprite) {
                var tmpImg = new Image();
                tmpImg.onload = function () {
                    this.isLoaded = !0, this.onload = null;
                }, tmpImg.src = '.././img/animals/' + obj.src + '.png', tmpSprite = tmpImg, aiSprites[tmpIndx] = tmpSprite;
            }
            if (tmpSprite.isLoaded) {
                var tmpScale = 1.2 * obj.scale * (obj.spriteMlt || 1);
                ctxt.drawImage(tmpSprite, -tmpScale, -tmpScale, 2 * tmpScale, 2 * tmpScale);
            }
        }
        function isOnScreen(x, y, s) {
            return x + s >= 0 && x - s <= maxScreenWidth && y + s >= 0 && y - s <= maxScreenHeight;
        }
        function addPlayer(data, isYou) {
            var tmpPlayer = function (id) {
                for (var i = 0; i < players.length; ++i)
                    if (players[i].id == id)
                        return players[i];
                return null;
            }(data[0]);
            tmpPlayer ||
                (tmpPlayer = new Player(data[0], data[1], config, UTILS, projectileManager, objectManager, players, ais, items, hats, accessories),
                 players.push(tmpPlayer)),
                tmpPlayer.spawn(isYou ? moofoll : null),
                tmpPlayer.visible = !1,
                tmpPlayer.x2 = void 0,
                tmpPlayer.y2 = void 0,
                tmpPlayer.clownCounter = 0,
                tmpPlayer.setData(data),
                isYou && (camX = (player = tmpPlayer).x,
                          camY = player.y,
                          updateItems(),
                          updateStatusDisplay(),
                          updateAge(),
                          updateUpgrades(0),
                          gameUI.style.display = 'block');
        }
        function removePlayer(id) {
            for (var i = 0; i < players.length; i++)
                if (players[i].id == id) {
                    players.splice(i, 1);
                    break;
                }
        }
        function updateItemCounts(index, value) {
            player && (player.itemCounts[index] = value);
        }
        function updatePlayerValue(index, value, updateView) {
            player && (player[index] = value, updateView && updateStatusDisplay());
        }
        function updateHealth(sid, value) {
            (tmpObj = findPlayerBySID(sid)) && (shameCounterF(value, tmpObj), tmpObj.health = value);
        }
        function shameCounterF(value, tmpObj){
            let d = value - tmpObj.health;
            if(d > 0){
                if (tmpObj.gotTime) {
                    if (gameTick - tmpObj.gotTime <= 1) {
                        tmpObj.clownCounter++;
                    } else {
                        tmpObj.clownCounter = Math.max(0, tmpObj.clownCounter - 2);
                    }
                }
                tmpObj.gotTime = 0;
            } else {
                tmpObj.gotTime = gameTick;
            }
        }
        var gameTick = 0;
        var nEy;
        var nEs;
        function updatePlayers(data) {
            gameTick++;
            nEs = [];
            nEy = [];
            for (var tmpTime = Date.now(), i = 0; i < players.length; ++i)
                players[i].forcePos = !players[i].visible, players[i].visible = !1;
            for (i = 0; i < data.length;)
                (tmpObj = findPlayerBySID(data[i]))
            && (tmpObj.t1 = void 0 === tmpObj.t2 ? tmpTime : tmpObj.t2,
                tmpObj.t2 = tmpTime,
                tmpObj.x1 = tmpObj.x,
                tmpObj.y1 = tmpObj.y,
                tmpObj.x2 = data[i + 1],
                tmpObj.y2 = data[i + 2],
                tmpObj.d1 = void 0 === tmpObj.d2 ? data[i + 3] : tmpObj.d2,
                tmpObj.d2 = data[i + 3],
                tmpObj.dt = 0,
                tmpObj.buildIndex = data[i + 4],
                tmpObj.weaponIndex = data[i + 5],
                tmpObj.weaponVariant = data[i + 6],
                tmpObj.team = data[i + 7],
                tmpObj.isLeader = data[i + 8],
                tmpObj.skinIndex = data[i + 9],
                tmpObj.tailIndex = data[i + 10],
                tmpObj.iconIndex = data[i + 11],
                tmpObj.zIndex = data[i + 12],
                tmpObj.visible = !0,
                (tmpObj == player || tmpObj.team && tmpObj.team == player.team) ? doWeaponStuff() : nEs.push(data.slice(i, i + 13))),
                    i += 13;
            nEs.length && (nEs = nEs.sort((a,b) => findDist(a, player) - findDist(b, player)), nEy = nEs[0]);
        }
        function findDist(a, b){
            return Math.sqrt(Math.pow((b.y2-a[2]),2)+Math.pow((b.x2-a[1]),2));
        }
        function doWeaponStuff(){
            if(tmpObj.skinIndex == 45){
                tmpObj.clownCounter = '8';
            }else if(isNaN(tmpObj.clownCounter)){
                tmpObj.clownCounter = 0;
            }
        }
        function findPlayerBySID(sid) {
            for (var i = 0; i < players.length; ++i)
                if (players[i].sid == sid)
                    return players[i];
            return null;
        }
        function findAIBySID(sid) {
            for (var i = 0; i < ais.length; ++i)
                if (ais[i].sid == sid)
                    return ais[i];
            return null;
        }
        function findObjectBySid(sid) {
            for (var i = 0; i < gameObjects.length; ++i)
                if (gameObjects[i].sid == sid)
                    return gameObjects[i];
            return null;
        }
        var lastPing = -1;
        function pingSocketResponse() {
            var pingTime = Date.now() - lastPing;
            window.pingTime = pingTime, pingDisplay.innerText = 'Ping: ' + pingTime + '\xA0ms';
        }
        function pingSocket() {
            lastPing = Date.now(), io.send('pp');
        }
        function serverShutdownNotice(countdown) {
            if (!(countdown < 0)) {
                var minutes = Math.floor(countdown / 60), seconds = countdown % 60;
                seconds = ('0' + seconds).slice(-2), shutdownDisplay.innerText = 'Server restarting in ' + minutes + ':' + seconds, shutdownDisplay.hidden = !1;
            }
        }
        function openLink(link) {
            window.open(link, '_blank');
        }
        window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
            window.setTimeout(callback, 1000 / 60);
        }, function () {
            var tmpMid = config.mapScale / 2;
            objectManager.add(0, tmpMid, tmpMid + 200, 0, config.treeScales[3], 0), objectManager.add(1, tmpMid, tmpMid - 480, 0, config.treeScales[3], 0), objectManager.add(2, tmpMid + 300, tmpMid + 450, 0, config.treeScales[3], 0), objectManager.add(3, tmpMid - 950, tmpMid - 130, 0, config.treeScales[2], 0), objectManager.add(4, tmpMid - 750, tmpMid - 400, 0, config.treeScales[3], 0), objectManager.add(5, tmpMid - 700, tmpMid + 400, 0, config.treeScales[2], 0), objectManager.add(6, tmpMid + 800, tmpMid - 200, 0, config.treeScales[3], 0), objectManager.add(7, tmpMid - 260, tmpMid + 340, 0, config.bushScales[3], 1), objectManager.add(8, tmpMid + 760, tmpMid + 310, 0, config.bushScales[3], 1), objectManager.add(9, tmpMid - 800, tmpMid + 100, 0, config.bushScales[3], 1), objectManager.add(10, tmpMid - 800, tmpMid + 300, 0, items.list[4].scale, items.list[4].id, items.list[10]), objectManager.add(11, tmpMid + 650, tmpMid - 390, 0, items.list[4].scale, items.list[4].id, items.list[10]), objectManager.add(12, tmpMid - 400, tmpMid - 450, 0, config.rockScales[2], 2);
        }(), function e() {
            now = Date.now(), delta = now - lastUpdate, lastUpdate = now, function () {
                if (player && (!lastSent || now - lastSent >= 1000 / config.clientSendRate)) {
                    lastSent = now;
                    const attackDir = getAttackDir();
                    lastAttackDir !== attackDir && (lastAttackDir = attackDir, io.send('2', attackDir));
                }
                if (deathTextScale < 120 && (deathTextScale += 0.1 * delta, diedText.style.fontSize = Math.min(Math.round(deathTextScale), 120) + 'px'), player) {
                    var attackDir = UTILS.getDistance(camX, camY, player.x, player.y), tmpDir = UTILS.getDirection(player.x, player.y, camX, camY), camSpd = Math.min(0.01 * attackDir * delta, attackDir);
                    attackDir > 0.05 ? (camX += camSpd * Math.cos(tmpDir), camY += camSpd * Math.sin(tmpDir)) : (camX = player.x, camY = player.y);
                } else
                    camX = config.mapScale / 2, camY = config.mapScale / 2;
                for (var lastTime = now - 1000 / config.serverUpdateRate, i = 0; i < players.length + ais.length; ++i)
                    if ((tmpObj = players[i] || ais[i - players.length]) && tmpObj.visible)
                        if (tmpObj.forcePos)
                            tmpObj.x = tmpObj.x2, tmpObj.y = tmpObj.y2, tmpObj.dir = tmpObj.d2;
                        else {
                            var total = tmpObj.t2 - tmpObj.t1, ratio = (lastTime - tmpObj.t1) / total;
                            tmpObj.dt += delta;
                            var tmpRate = Math.min(1.7, tmpObj.dt / 170), tmpDiff = tmpObj.x2 - tmpObj.x1;
                            tmpObj.x = tmpObj.x1 + tmpDiff * tmpRate, tmpDiff = tmpObj.y2 - tmpObj.y1, tmpObj.y = tmpObj.y1 + tmpDiff * tmpRate, tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                        }
                var xOffset = camX - maxScreenWidth / 2, yOffset = camY - maxScreenHeight / 2;
                config.snowBiomeTop - yOffset <= 0 && config.mapScale - config.snowBiomeTop - yOffset >= maxScreenHeight ? (mainContext.fillStyle = '#b6db66', mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight)) : config.mapScale - config.snowBiomeTop - yOffset <= 0 ? (mainContext.fillStyle = '#dbc666', mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight)) : config.snowBiomeTop - yOffset >= maxScreenHeight ? (mainContext.fillStyle = '#fff', mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight)) : config.snowBiomeTop - yOffset >= 0 ? (mainContext.fillStyle = '#fff', mainContext.fillRect(0, 0, maxScreenWidth, config.snowBiomeTop - yOffset), mainContext.fillStyle = '#b6db66', mainContext.fillRect(0, config.snowBiomeTop - yOffset, maxScreenWidth, maxScreenHeight - (config.snowBiomeTop - yOffset))) : (mainContext.fillStyle = '#b6db66', mainContext.fillRect(0, 0, maxScreenWidth, config.mapScale - config.snowBiomeTop - yOffset), mainContext.fillStyle = '#dbc666', mainContext.fillRect(0, config.mapScale - config.snowBiomeTop - yOffset, maxScreenWidth, maxScreenHeight - (config.mapScale - config.snowBiomeTop - yOffset))), firstSetup || ((waterMult += waterPlus * config.waveSpeed * delta) >= config.waveMax ? (waterMult = config.waveMax, waterPlus = -1) : waterMult <= 1 && (waterMult = waterPlus = 1), mainContext.globalAlpha = 1, mainContext.fillStyle = '#dbc666', renderWaterBodies(xOffset, yOffset, mainContext, config.riverPadding), mainContext.fillStyle = '#91b2db', renderWaterBodies(xOffset, yOffset, mainContext, 250 * (waterMult - 1))), mainContext.lineWidth = 4, mainContext.strokeStyle = '#000', mainContext.globalAlpha = 0, mainContext.beginPath();
                for (var x = -camX; x < maxScreenWidth; x += maxScreenHeight / 18)
                    x > 0 && (mainContext.moveTo(x, 0), mainContext.lineTo(x, maxScreenHeight));
                for (var y = -camY; y < maxScreenHeight; y += maxScreenHeight / 18)
                    x > 0 && (mainContext.moveTo(0, y), mainContext.lineTo(maxScreenWidth, y));
                for (mainContext.stroke(), mainContext.globalAlpha = 1, mainContext.strokeStyle = outlineColor, renderGameObjects(-1, xOffset, yOffset), mainContext.globalAlpha = 1, mainContext.lineWidth = 5.5, renderProjectiles(0, xOffset, yOffset), renderPlayers(xOffset, yOffset, 0), mainContext.globalAlpha = 1, i = 0; i < ais.length; ++i)
                    (tmpObj = ais[i]).active && tmpObj.visible && (tmpObj.animate(delta), mainContext.save(), mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset), mainContext.rotate(tmpObj.dir + tmpObj.dirPlus - Math.PI / 2), renderAI(tmpObj, mainContext), mainContext.restore());
                if (renderGameObjects(0, xOffset, yOffset), renderProjectiles(1, xOffset, yOffset), renderGameObjects(1, xOffset, yOffset), renderPlayers(xOffset, yOffset, 1), renderGameObjects(2, xOffset, yOffset), renderGameObjects(3, xOffset, yOffset), mainContext.fillStyle = '#000', mainContext.globalAlpha = 0.09, xOffset <= 0 && mainContext.fillRect(0, 0, -xOffset, maxScreenHeight), config.mapScale - xOffset <= maxScreenWidth) {
                    var tmpY = Math.max(0, -yOffset);
                    mainContext.fillRect(config.mapScale - xOffset, tmpY, maxScreenWidth - (config.mapScale - xOffset), maxScreenHeight - tmpY);
                }
                var abc = true;
                if (yOffset <= 0 && mainContext.fillRect(-xOffset, 0, maxScreenWidth + xOffset, -yOffset), config.mapScale - yOffset <= maxScreenHeight) {
                    var tmpX = Math.max(0, -xOffset), tmpMin = 0;
                    config.mapScale - xOffset <= maxScreenWidth && (tmpMin = maxScreenWidth - (config.mapScale - xOffset)), mainContext.fillRect(tmpX, config.mapScale - yOffset, maxScreenWidth - tmpX - tmpMin, maxScreenHeight - (config.mapScale - yOffset));
                }
                for (mainContext.globalAlpha = 1, mainContext.fillStyle = 'rgba(0, 0, 70, 0.35)', mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight), mainContext.strokeStyle = darkOutlineColor, i = 0; i < players.length + ais.length; ++i)
                    if ((tmpObj = players[i] || ais[i - players.length]).visible && (10 != tmpObj.skinIndex || tmpObj == player || tmpObj.team && tmpObj.team == player.team)) {
                        if(abc){
                            for(let i = 0; i < gameObjects.length; i++){
                                if(Math.hypot(gameObjects[i].y-player.y2, gameObjects[i].x-player.x2) < 350 && gameObjects[i].active && gameObjects[i].cHealth && gameObjects[i].name && gameObjects[i].scale){
                                    gameObjects[i].cHealth > 0 &&
                                        (config.healthBarWidth,
                                         mainContext.fillStyle = darkOutlineColor,
                                         mainContext.roundRect(gameObjects[i].x - xOffset - config.healthBarWidth - config.healthBarPad, gameObjects[i].y - yOffset + gameObjects[i].scale + 5, 2 * config.healthBarWidth + 2 * config.healthBarPad, 17, 8),
                                         mainContext.fill(),
                                         mainContext.fillStyle = gameObjects[i].owner.sid == player.sid ? "rgba(0, 256, 0, .6)" : isAlly(gameObjects[i].owner.sid) ? "rgba(0, 0, 256, .6)" : "rgba(256, 0, 0, .6)",
                                         mainContext.roundRect(gameObjects[i].x - xOffset - config.healthBarWidth, gameObjects[i].y - yOffset + gameObjects[i].scale + 5 + config.healthBarPad, 2 * config.healthBarWidth * (gameObjects[i].cHealth/gameObjects[i].health), 17 - 2 * config.healthBarPad, 7),
                                         mainContext.fill())
                                }
                            }
                        }
                        var tmpText = (tmpObj.team ? '[' + tmpObj.team + '] ' : '') + (tmpObj.name || '') + (tmpObj.id ? ' <' + tmpObj.clownCounter +'/8>' : '');
                        if ('' != tmpText) {
                            if (mainContext.font = (tmpObj.nameScale || 30) + 'px Hammersmith One', mainContext.fillStyle = '#fff', mainContext.textBaseline = 'middle', mainContext.textAlign = 'center', mainContext.lineWidth = tmpObj.nameScale ? 11 : 8, mainContext.lineJoin = 'round', mainContext.strokeText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY), mainContext.fillText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY), tmpObj.isLeader && iconSprites.crown.isLoaded) {
                                var tmpS = config.crownIconScale;
                                tmpX = tmpObj.x - xOffset - tmpS / 2 - mainContext.measureText(tmpText).width / 2 - config.crownPad, mainContext.drawImage(iconSprites.crown, tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY - tmpS / 2 - 5, tmpS, tmpS);
                            }
                            1 == tmpObj.iconIndex && iconSprites.skull.isLoaded && (tmpS = config.crownIconScale, tmpX = tmpObj.x - xOffset - tmpS / 2 + mainContext.measureText(tmpText).width / 2 + config.crownPad, mainContext.drawImage(iconSprites.skull, tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY - tmpS / 2 - 5, tmpS, tmpS));
                        }
                        tmpObj.health > 0 && (config.healthBarWidth, mainContext.fillStyle = darkOutlineColor, mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY, 2 * config.healthBarWidth + 2 * config.healthBarPad, 17, 8), mainContext.fill(), mainContext.fillStyle = tmpObj == player || tmpObj.team && tmpObj.team == player.team ? '#8ecc51' : '#cc5151', mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY + config.healthBarPad, 2 * config.healthBarWidth * (tmpObj.health / tmpObj.maxHealth), 17 - 2 * config.healthBarPad, 7), mainContext.fill());
                    }
                for (textManager.update(delta, mainContext, xOffset, yOffset), i = 0; i < players.length; ++i)
                    if ((tmpObj = players[i]).visible && tmpObj.chatCountdown > 0) {
                        tmpObj.chatCountdown -= delta, tmpObj.chatCountdown <= 0 && (tmpObj.chatCountdown = 0), mainContext.font = '32px Hammersmith One';
                        var tmpSize = mainContext.measureText(tmpObj.chatMessage);
                        mainContext.textBaseline = 'middle', mainContext.textAlign = 'center', tmpX = tmpObj.x - xOffset, tmpY = tmpObj.y - tmpObj.scale - yOffset - 90;
                        var tmpW = tmpSize.width + 17;
                        mainContext.fillStyle = 'rgba(0,0,0,0.2)', mainContext.roundRect(tmpX - tmpW / 2, tmpY - 23.5, tmpW, 47, 6), mainContext.fill(), mainContext.fillStyle = '#fff', mainContext.fillText(tmpObj.chatMessage, tmpX, tmpY);
                    }
                !function (delta) {
                    if (player && player.alive) {
                        mapContext.clearRect(0, 0, mapDisplay.width, mapDisplay.height), mapContext.strokeStyle = '#fff', mapContext.lineWidth = 4;
                        for (var i = 0; i < mapPings.length; ++i)
                            (tmpPing = mapPings[i]).update(mapContext, delta);
                        if (mapContext.globalAlpha = 1, mapContext.fillStyle = '#fff', renderCircle(player.x / config.mapScale * mapDisplay.width, player.y / config.mapScale * mapDisplay.height, 7, mapContext, !0), mapContext.fillStyle = 'rgba(255,255,255,0.35)', player.team && minimapData)
                            for (i = 0; i < minimapData.length;)
                                renderCircle(minimapData[i] / config.mapScale * mapDisplay.width, minimapData[i + 1] / config.mapScale * mapDisplay.height, 7, mapContext, !0), i += 2;
                        lastDeath && (mapContext.fillStyle = '#fc5553', mapContext.font = '34px Hammersmith One', mapContext.textBaseline = 'middle', mapContext.textAlign = 'center', mapContext.fillText('x', lastDeath.x / config.mapScale * mapDisplay.width, lastDeath.y / config.mapScale * mapDisplay.height)), mapMarker && (mapContext.fillStyle = '#fff', mapContext.font = '34px Hammersmith One', mapContext.textBaseline = 'middle', mapContext.textAlign = 'center', mapContext.fillText('x', mapMarker.x / config.mapScale * mapDisplay.width, mapMarker.y / config.mapScale * mapDisplay.height));
                    }
                }(delta), -1 !== controllingTouch.id && renderControl(controllingTouch.startX, controllingTouch.startY, controllingTouch.currentX, controllingTouch.currentY), -1 !== attackingTouch.id && renderControl(attackingTouch.startX, attackingTouch.startY, attackingTouch.currentX, attackingTouch.currentY);
            }(), requestAnimFrame(e);
        }(), window.openLink = openLink, window.aJoinReq = aJoinReq, window.follmoo = function () {
            moofoll || (moofoll = !0, saveVal('moofoll', 1));
        }, window.kickFromClan = kickFromClan, window.sendJoin = sendJoin, window.leaveAlliance = leaveAlliance, window.createAlliance = createAlliance, window.storeBuy = storeBuy, window.storeEquip = storeEquip, window.showItemInfo = showItemInfo, window.selectSkinColor = function (index) {
            skinColor = index, updateSkinColorPicker();
        }, window.changeStoreIndex = function (index) {
            currentStoreIndex != index && (currentStoreIndex = index, generateStoreList());
        }, window.config = config, window.FRVR && window.FRVR.bootstrapper.complete();
    },
    function (e, t) {
        /* 3: ./src/js/libs/modernizr.js */
        !function (e, n, s) {
            function o(e, n) {
                return typeof e === n;
            }
            var i = [], r = [], f = {
                    _version: '3.5.0',
                    _config: {
                        classPrefix: '',
                        enableClasses: !0,
                        enableJSClass: !0,
                        usePrefixes: !0
                    },
                    _q: [],
                    on: function (e, n) {
                        var s = this;
                        setTimeout(function () {
                            n(s[e]);
                        }, 0);
                    },
                    addTest: function (e, n, s) {
                        r.push({
                            name: e,
                            fn: n,
                            options: s
                        });
                    },
                    addAsyncTest: function (e) {
                        r.push({
                            name: null,
                            fn: e
                        });
                    }
                }, Modernizr = function () {
                };
            Modernizr.prototype = f, Modernizr = new Modernizr();
            var l = n.documentElement, c = 'svg' === l.nodeName.toLowerCase();
            Modernizr.addTest('passiveeventlisteners', function () {
                var n = !1;
                try {
                    var s = Object.defineProperty({}, 'passive', {
                        get: function () {
                            n = !0;
                        }
                    });
                    e.addEventListener('test', null, s);
                } catch (e) {
                }
                return n;
            }), function () {
                var e, n, s, a, t, l;
                for (var c in r)
                    if (r.hasOwnProperty(c)) {
                        if (e = [], (n = r[c]).name && (e.push(n.name.toLowerCase()), n.options && n.options.aliases && n.options.aliases.length))
                            for (s = 0; s < n.options.aliases.length; s++)
                                e.push(n.options.aliases[s].toLowerCase());
                        for (a = o(n.fn, 'function') ? n.fn() : n.fn, t = 0; t < e.length; t++)
                            1 === (l = e[t].split('.')).length ? Modernizr[l[0]] = a : (!Modernizr[l[0]] || Modernizr[l[0]] instanceof Boolean || (Modernizr[l[0]] = new Boolean(Modernizr[l[0]])), Modernizr[l[0]][l[1]] = a), i.push((a ? '' : 'no-') + l.join('-'));
                    }
            }(), function (e) {
                var n = l.className, s = Modernizr._config.classPrefix || '';
                if (c && (n = n.baseVal), Modernizr._config.enableJSClass) {
                    var o = new RegExp('(^|\\s)' + s + 'no-js(\\s|$)');
                    n = n.replace(o, '$1' + s + 'js$2');
                }
                Modernizr._config.enableClasses && (n += ' ' + s + e.join(' ' + s), c ? l.className.baseVal = n : l.className = n);
            }(i), delete f.addTest, delete f.addAsyncTest;
            for (var u = 0; u < Modernizr._q.length; u++)
                Modernizr._q[u]();
            e.Modernizr = Modernizr;
        }(window, document);
    },
    function (module, t, __webpack_require__) {
        /* 4: ./src/js/libs/io-client.js */
        const {
                Encoder: Encoder,
                Decoder: Decoder
            } = __webpack_require__(37), encoder = new Encoder(), decoder = new Decoder();
        __webpack_require__(0), module.exports = {
            socket: null,
            connected: !1,
            socketId: -1,
            connect: function (address, callback, events) {
                if (!this.socket) {
                    var _this = this;
                    try {
                        var socketError = !1, socketAddress = address;
                        this.socket = new WebSocket(socketAddress), this.socket.binaryType = 'arraybuffer', this.socket.onmessage = function (message) {
                            var data = new Uint8Array(message.data), parsed = decoder.decode(data), type = parsed[0];
                            data = parsed[1], 'io-init' == type ? _this.socketId = data[0] : events[type].apply(void 0, data);
                        }, this.socket.onopen = function () {
                            _this.connected = !0, callback();
                        }, this.socket.onclose = function (event) {
                            _this.connected = !1, 4001 == event.code ? callback('Invalid Connection') : socketError || callback('disconnected');
                        }, this.socket.onerror = function (error) {
                            this.socket && this.socket.readyState != WebSocket.OPEN && (socketError = !0, console.error('Socket error', arguments), callback('Socket error'));
                        };
                    } catch (e) {
                        console.warn('Socket connection error:', e), callback(e);
                    }
                }
            },
            send: function (type) {
                var data = Array.prototype.slice.call(arguments, 1), binary = encoder.encode([
                        type,
                        data
                    ]);
                this.socket.send(binary);
            },
            socketReady: function () {
                return this.socket && this.connected;
            },
            close: function () {
                this.socket && this.socket.close();
            }
        };
    },
    function (module, t) {
        /* 5: ./node_modules/process/browser.js */
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
        }
        function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout)
                return setTimeout(fun, 0);
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
                return cachedSetTimeout = setTimeout, setTimeout(fun, 0);
            try {
                return cachedSetTimeout(fun, 0);
            } catch (t) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (t) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        !function () {
            try {
                cachedSetTimeout = 'function' == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = 'function' == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len;) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len;)
                        currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, function (marker) {
                    if (cachedClearTimeout === clearTimeout)
                        return clearTimeout(marker);
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
                        return cachedClearTimeout = clearTimeout, clearTimeout(marker);
                    try {
                        cachedClearTimeout(marker);
                    } catch (t) {
                        try {
                            return cachedClearTimeout.call(null, marker);
                        } catch (t) {
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }(timeout);
            }
        }
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {
        }
        process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var i = 1; i < arguments.length; i++)
                    args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function () {
            this.fun.apply(null, this.array);
        }, process.title = 'browser', process.browser = !0, process.env = {}, process.argv = [], process.version = '', process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, process.listeners = function (name) {
            return [];
        }, process.binding = function (name) {
            throw new Error('process.binding is not supported');
        }, process.cwd = function () {
            return '/';
        }, process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
        }, process.umask = function () {
            return 0;
        };
    },
    function (module, t) {
        /* 6: ./src/js/libs/utils.js */
        var mathABS = Math.abs, mathSQRT = (Math.cos, Math.sin, Math.pow, Math.sqrt), mathATAN2 = (mathABS = Math.abs, Math.atan2), mathPI = Math.PI;
        module.exports.randInt = function (min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }, module.exports.randFloat = function (min, max) {
            return Math.random() * (max - min + 1) + min;
        }, module.exports.lerp = function (value1, value2, amount) {
            return value1 + (value2 - value1) * amount;
        }, module.exports.decel = function (val, cel) {
            return val > 0 ? val = Math.max(0, val - cel) : val < 0 && (val = Math.min(0, val + cel)), val;
        }, module.exports.getDistance = function (x1, y1, x2, y2) {
            return mathSQRT((x2 -= x1) * x2 + (y2 -= y1) * y2);
        }, module.exports.getDirection = function (x1, y1, x2, y2) {
            return mathATAN2(y1 - y2, x1 - x2);
        }, module.exports.getAngleDist = function (a, b) {
            var p = mathABS(b - a) % (2 * mathPI);
            return p > mathPI ? 2 * mathPI - p : p;
        }, module.exports.isNumber = function (n) {
            return 'number' == typeof n && !isNaN(n) && isFinite(n);
        }, module.exports.isString = function (s) {
            return s && 'string' == typeof s;
        }, module.exports.kFormat = function (num) {
            return num > 999 ? (num / 1000).toFixed(1) + 'k' : num;
        }, module.exports.capitalizeFirst = function (string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }, module.exports.fixTo = function (n, v) {
            return parseFloat(n.toFixed(v));
        }, module.exports.sortByPoints = function (a, b) {
            return parseFloat(b.points) - parseFloat(a.points);
        }, module.exports.lineInRect = function (recX, recY, recX2, recY2, x1, y1, x2, y2) {
            var minX = x1, maxX = x2;
            if (x1 > x2 && (minX = x2, maxX = x1), maxX > recX2 && (maxX = recX2), minX < recX && (minX = recX), minX > maxX)
                return !1;
            var minY = y1, maxY = y2, dx = x2 - x1;
            if (Math.abs(dx) > 1e-7) {
                var a = (y2 - y1) / dx, b = y1 - a * x1;
                minY = a * minX + b, maxY = a * maxX + b;
            }
            if (minY > maxY) {
                var tmp = maxY;
                maxY = minY, minY = tmp;
            }
            return maxY > recY2 && (maxY = recY2), minY < recY && (minY = recY), !(minY > maxY);
        }, module.exports.containsPoint = function (element, x, y) {
            var bounds = element.getBoundingClientRect(), left = bounds.left + window.scrollX, top = bounds.top + window.scrollY, width = bounds.width, height = bounds.height;
            return x > left && x < left + width && y > top && y < top + height;
        }, module.exports.mousifyTouchEvent = function (event) {
            var touch = event.changedTouches[0];
            event.screenX = touch.screenX, event.screenY = touch.screenY, event.clientX = touch.clientX, event.clientY = touch.clientY, event.pageX = touch.pageX, event.pageY = touch.pageY;
        }, module.exports.hookTouchEvents = function (element, skipPrevent) {
            var preventDefault = !skipPrevent, isHovering = !1;
            function touchEnd(e) {
                module.exports.mousifyTouchEvent(e), window.setUsingTouch(!0), preventDefault && (e.preventDefault(), e.stopPropagation()), isHovering && (element.onclick && element.onclick(e), element.onmouseout && element.onmouseout(e), isHovering = !1);
            }
            element.addEventListener('touchstart', module.exports.checkTrusted(function (e) {
                module.exports.mousifyTouchEvent(e), window.setUsingTouch(!0), preventDefault && (e.preventDefault(), e.stopPropagation()), element.onmouseover && element.onmouseover(e), isHovering = !0;
            }), !1), element.addEventListener('touchmove', module.exports.checkTrusted(function (e) {
                module.exports.mousifyTouchEvent(e), window.setUsingTouch(!0), preventDefault && (e.preventDefault(), e.stopPropagation()), module.exports.containsPoint(element, e.pageX, e.pageY) ? isHovering || (element.onmouseover && element.onmouseover(e), isHovering = !0) : isHovering && (element.onmouseout && element.onmouseout(e), isHovering = !1);
            }), !1), element.addEventListener('touchend', module.exports.checkTrusted(touchEnd), !1), element.addEventListener('touchcancel', module.exports.checkTrusted(touchEnd), !1), element.addEventListener('touchleave', module.exports.checkTrusted(touchEnd), !1);
        }, module.exports.removeAllChildren = function (element) {
            for (; element.hasChildNodes();)
                element.removeChild(element.lastChild);
        }, module.exports.generateElement = function (config) {
            var element = document.createElement(config.tag || 'div');
            function bind(configValue, elementValue) {
                config[configValue] && (element[elementValue] = config[configValue]);
            }
            for (var key in (bind('text', 'textContent'), bind('html', 'innerHTML'), bind('class', 'className'), config)) {
                switch (key) {
                case 'tag':
                case 'text':
                case 'html':
                case 'class':
                case 'style':
                case 'hookTouch':
                case 'parent':
                case 'children':
                    continue;
                }
                element[key] = config[key];
            }
            if (element.onclick && (element.onclick = module.exports.checkTrusted(element.onclick)), element.onmouseover && (element.onmouseover = module.exports.checkTrusted(element.onmouseover)), element.onmouseout && (element.onmouseout = module.exports.checkTrusted(element.onmouseout)), config.style && (element.style.cssText = config.style), config.hookTouch && module.exports.hookTouchEvents(element), config.parent && config.parent.appendChild(element), config.children)
                for (var i = 0; i < config.children.length; i++)
                    element.appendChild(config.children[i]);
            return element;
        }, module.exports.eventIsTrusted = function (ev) {
            return !ev || 'boolean' != typeof ev.isTrusted || ev.isTrusted;
        }, module.exports.checkTrusted = function (callback) {
            return function (ev) {
                ev && ev instanceof Event && module.exports.eventIsTrusted(ev) && callback(ev);
            };
        }, module.exports.randomString = function (length) {
            for (var text = '', possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', i = 0; i < length; i++)
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            return text;
        }, module.exports.countInArray = function (array, val) {
            for (var count = 0, i = 0; i < array.length; i++)
                array[i] === val && count++;
            return count;
        };
    },
    function (module, t) {
        /* 7: ./src/js/libs/animText.js */
        module.exports.AnimText = function () {
            this.init = function (x, y, scale, speed, life, text, color) {
                this.x = x, this.y = y, this.color = color, this.scale = scale, this.startScale = this.scale, this.maxScale = 1.5 * scale, this.scaleSpeed = 0.7, this.speed = speed, this.life = life, this.text = text;
            }, this.update = function (delta) {
                this.life && (this.life -= delta, this.y -= this.speed * delta, this.scale += this.scaleSpeed * delta, this.scale >= this.maxScale ? (this.scale = this.maxScale, this.scaleSpeed *= -1) : this.scale <= this.startScale && (this.scale = this.startScale, this.scaleSpeed = 0), this.life <= 0 && (this.life = 0));
            }, this.render = function (ctxt, xOff, yOff) {
                ctxt.fillStyle = this.color, ctxt.font = this.scale + 'px Hammersmith One', ctxt.fillText(this.text, this.x - xOff, this.y - yOff);
            };
        }, module.exports.TextManager = function () {
            this.texts = [], this.update = function (delta, ctxt, xOff, yOff) {
                ctxt.textBaseline = 'middle', ctxt.textAlign = 'center';
                for (var i = 0; i < this.texts.length; ++i)
                    this.texts[i].life && (this.texts[i].update(delta), this.texts[i].render(ctxt, xOff, yOff));
            }, this.showText = function (x, y, scale, speed, life, text, color) {
                for (var tmpText, i = 0; i < this.texts.length; ++i)
                    if (!this.texts[i].life) {
                        tmpText = this.texts[i];
                        break;
                    }
                tmpText || (tmpText = new module.exports.AnimText(), this.texts.push(tmpText)), tmpText.init(x, y, scale, speed, life, text, color);
            };
        };
    },
    function (module, t) {
        /* 8: ./src/js/data/gameObject.js */
        module.exports = function (sid) {
            this.sid = sid, this.init = function (x, y, dir, scale, type, data, owner) {
                data = data || {}, this.sentTo = {}, this.gridLocations = [], this.active = !0, this.doUpdate = data.doUpdate, this.x = x, this.y = y, this.dir = dir, this.xWiggle = 0, this.yWiggle = 0, this.scale = scale, this.type = type, this.id = data.id, this.owner = owner, this.name = data.name, this.isItem = null != this.id, this.group = data.group, this.health = data.health, this.layer = 2, null != this.group ? this.layer = this.group.layer : 0 == this.type ? this.layer = 3 : 2 == this.type ? this.layer = 0 : 4 == this.type && (this.layer = -1), this.colDiv = data.colDiv || 1, this.blocker = data.blocker, this.ignoreCollision = data.ignoreCollision, this.dontGather = data.dontGather, this.hideFromEnemy = data.hideFromEnemy, this.friction = data.friction, this.projDmg = data.projDmg, this.dmg = data.dmg, this.pDmg = data.pDmg, this.pps = data.pps, this.zIndex = data.zIndex || 0, this.turnSpeed = data.turnSpeed, this.req = data.req, this.trap = data.trap, this.healCol = data.healCol, this.teleport = data.teleport, this.boostSpeed = data.boostSpeed, this.projectile = data.projectile, this.shootRange = data.shootRange, this.shootRate = data.shootRate, this.shootCount = this.shootRate, this.spawnPoint = data.spawnPoint;
            }, this.changeHealth = function (amount, doer) {
                return this.health += amount, this.health <= 0;
            }, this.getScale = function (sM, ig) {
                return sM = sM || 1, this.scale * (this.isItem || 2 == this.type || 3 == this.type || 4 == this.type ? 1 : 0.6 * sM) * (ig ? 1 : this.colDiv);
            }, this.visibleToPlayer = function (player) {
                return !this.hideFromEnemy || this.owner && (this.owner == player || this.owner.team && player.team == this.owner.team);
            }, this.update = function (delta) {
                this.active && (this.xWiggle && (this.xWiggle *= Math.pow(0.99, delta)), this.yWiggle && (this.yWiggle *= Math.pow(0.99, delta)), this.turnSpeed && (this.dir += this.turnSpeed * delta));
            };
        };
    },
    function (module, exports) {
        /* 9: ./src/js/data/items.js */
        module.exports.groups = [
            {
                id: 0,
                name: 'food',
                layer: 0
            },
            {
                id: 1,
                name: 'walls',
                place: !0,
                limit: 30,
                layer: 0
            },
            {
                id: 2,
                name: 'spikes',
                place: !0,
                limit: 15,
                layer: 0
            },
            {
                id: 3,
                name: 'mill',
                place: !0,
                limit: 7,
                layer: 1
            },
            {
                id: 4,
                name: 'mine',
                place: !0,
                limit: 1,
                layer: 0
            },
            {
                id: 5,
                name: 'trap',
                place: !0,
                limit: 6,
                layer: -1
            },
            {
                id: 6,
                name: 'booster',
                place: !0,
                limit: 12,
                layer: -1
            },
            {
                id: 7,
                name: 'turret',
                place: !0,
                limit: 2,
                layer: 1
            },
            {
                id: 8,
                name: 'watchtower',
                place: !0,
                limit: 12,
                layer: 1
            },
            {
                id: 9,
                name: 'buff',
                place: !0,
                limit: 4,
                layer: -1
            },
            {
                id: 10,
                name: 'spawn',
                place: !0,
                limit: 1,
                layer: -1
            },
            {
                id: 11,
                name: 'sapling',
                place: !0,
                limit: 2,
                layer: 0
            },
            {
                id: 12,
                name: 'blocker',
                place: !0,
                limit: 3,
                layer: -1
            },
            {
                id: 13,
                name: 'teleporter',
                place: !0,
                limit: 2,
                layer: -1
            }
        ], exports.projectiles = [
            {
                indx: 0,
                layer: 0,
                src: 'arrow_1',
                dmg: 25,
                speed: 1.6,
                scale: 103,
                range: 1000
            },
            {
                indx: 1,
                layer: 1,
                dmg: 25,
                scale: 20
            },
            {
                indx: 0,
                layer: 0,
                src: 'arrow_1',
                dmg: 35,
                speed: 2.5,
                scale: 103,
                range: 1200
            },
            {
                indx: 0,
                layer: 0,
                src: 'arrow_1',
                dmg: 30,
                speed: 2,
                scale: 103,
                range: 1200
            },
            {
                indx: 1,
                layer: 1,
                dmg: 16,
                scale: 20
            },
            {
                indx: 0,
                layer: 0,
                src: 'bullet_1',
                dmg: 50,
                speed: 3.6,
                scale: 160,
                range: 1400
            }
        ], exports.weapons = [
            {
                id: 0,
                type: 0,
                name: 'tool hammer',
                desc: 'tool for gathering all resources',
                src: 'hammer_1',
                length: 140,
                width: 140,
                xOff: -3,
                yOff: 18,
                dmg: 25,
                range: 65,
                gather: 1,
                speed: 300
            },
            {
                id: 1,
                type: 0,
                age: 2,
                name: 'hand axe',
                desc: 'gathers resources at a higher rate',
                src: 'axe_1',
                length: 140,
                width: 140,
                xOff: 3,
                yOff: 24,
                dmg: 30,
                spdMult: 1,
                range: 70,
                gather: 2,
                speed: 400
            },
            {
                id: 2,
                type: 0,
                age: 8,
                pre: 1,
                name: 'great axe',
                desc: 'deal more damage and gather more resources',
                src: 'great_axe_1',
                length: 140,
                width: 140,
                xOff: -8,
                yOff: 25,
                dmg: 35,
                spdMult: 1,
                range: 75,
                gather: 4,
                speed: 400
            },
            {
                id: 3,
                type: 0,
                age: 2,
                name: 'short sword',
                desc: 'increased attack power but slower move speed',
                src: 'sword_1',
                iPad: 1.3,
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 46,
                dmg: 35,
                spdMult: 0.85,
                range: 110,
                gather: 1,
                speed: 300
            },
            {
                id: 4,
                type: 0,
                age: 8,
                pre: 3,
                name: 'katana',
                desc: 'greater range and damage',
                src: 'samurai_1',
                iPad: 1.3,
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 59,
                dmg: 40,
                spdMult: 0.8,
                range: 118,
                gather: 1,
                speed: 300
            },
            {
                id: 5,
                type: 0,
                age: 2,
                name: 'polearm',
                desc: 'long range melee weapon',
                src: 'spear_1',
                iPad: 1.3,
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 53,
                dmg: 45,
                knock: 0.2,
                spdMult: 0.82,
                range: 142,
                gather: 1,
                speed: 700
            },
            {
                id: 6,
                type: 0,
                age: 2,
                name: 'bat',
                desc: 'fast long range melee weapon',
                src: 'bat_1',
                iPad: 1.3,
                length: 110,
                width: 180,
                xOff: -8,
                yOff: 53,
                dmg: 20,
                knock: 0.7,
                range: 110,
                gather: 1,
                speed: 300
            },
            {
                id: 7,
                type: 0,
                age: 2,
                name: 'daggers',
                desc: 'really fast short range weapon',
                src: 'dagger_1',
                iPad: 0.8,
                length: 110,
                width: 110,
                xOff: 18,
                yOff: 0,
                dmg: 20,
                knock: 0.1,
                range: 65,
                gather: 1,
                hitSlow: 0.1,
                spdMult: 1.13,
                speed: 100
            },
            {
                id: 8,
                type: 0,
                age: 2,
                name: 'stick',
                desc: 'great for gathering but very weak',
                src: 'stick_1',
                length: 140,
                width: 140,
                xOff: 3,
                yOff: 24,
                dmg: 1,
                spdMult: 1,
                range: 70,
                gather: 7,
                speed: 400
            },
            {
                id: 9,
                type: 1,
                age: 6,
                name: 'hunting bow',
                desc: 'bow used for ranged combat and hunting',
                src: 'bow_1',
                req: [
                    'wood',
                    4
                ],
                length: 120,
                width: 120,
                xOff: -6,
                yOff: 0,
                projectile: 0,
                spdMult: 0.75,
                speed: 600
            },
            {
                id: 10,
                type: 1,
                age: 6,
                name: 'great hammer',
                desc: 'hammer used for destroying structures',
                src: 'great_hammer_1',
                length: 140,
                width: 140,
                xOff: -9,
                yOff: 25,
                dmg: 10,
                spdMult: 0.88,
                range: 75,
                sDmg: 7.5,
                gather: 1,
                speed: 400
            },
            {
                id: 11,
                type: 1,
                age: 6,
                name: 'wooden shield',
                desc: 'blocks projectiles and reduces melee damage',
                src: 'shield_1',
                length: 120,
                width: 120,
                shield: 0.2,
                xOff: 6,
                yOff: 0,
                spdMult: 0.7
            },
            {
                id: 12,
                type: 1,
                age: 8,
                pre: 9,
                name: 'crossbow',
                desc: 'deals more damage and has greater range',
                src: 'crossbow_1',
                req: [
                    'wood',
                    5
                ],
                aboveHand: !0,
                armS: 0.75,
                length: 120,
                width: 120,
                xOff: -4,
                yOff: 0,
                projectile: 2,
                spdMult: 0.7,
                speed: 700
            },
            {
                id: 13,
                type: 1,
                age: 9,
                pre: 12,
                name: 'repeater crossbow',
                desc: 'high firerate crossbow with reduced damage',
                src: 'crossbow_2',
                req: [
                    'wood',
                    10
                ],
                aboveHand: !0,
                armS: 0.75,
                length: 120,
                width: 120,
                xOff: -4,
                yOff: 0,
                projectile: 3,
                spdMult: 0.7,
                speed: 230
            },
            {
                id: 14,
                type: 1,
                age: 6,
                name: 'mc grabby',
                desc: 'steals resources from enemies',
                src: 'grab_1',
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 53,
                dmg: 0,
                steal: 250,
                knock: 0.2,
                spdMult: 1.05,
                range: 125,
                gather: 0,
                speed: 700
            },
            {
                id: 15,
                type: 1,
                age: 9,
                pre: 12,
                name: 'musket',
                desc: 'slow firerate but high damage and range',
                src: 'musket_1',
                req: [
                    'stone',
                    10
                ],
                aboveHand: !0,
                rec: 0.35,
                armS: 0.6,
                hndS: 0.3,
                hndD: 1.6,
                length: 205,
                width: 205,
                xOff: 25,
                yOff: 0,
                projectile: 5,
                hideProjectile: !0,
                spdMult: 0.6,
                speed: 1500
            }
        ], module.exports.list = [
            {
                group: module.exports.groups[0],
                name: 'apple',
                desc: 'restores 20 health when consumed',
                req: [
                    'food',
                    10
                ],
                consume: function (doer) {
                    return doer.changeHealth(20, doer);
                },
                scale: 22,
                holdOffset: 15
            },
            {
                age: 3,
                group: module.exports.groups[0],
                name: 'cookie',
                desc: 'restores 40 health when consumed',
                req: [
                    'food',
                    15
                ],
                consume: function (doer) {
                    return doer.changeHealth(40, doer);
                },
                scale: 27,
                holdOffset: 15
            },
            {
                age: 7,
                group: module.exports.groups[0],
                name: 'cheese',
                desc: 'restores 30 health and another 50 over 5 seconds',
                req: [
                    'food',
                    25
                ],
                consume: function (doer) {
                    return !!(doer.changeHealth(30, doer) || doer.health < 100) && (doer.dmgOverTime.dmg = -10, doer.dmgOverTime.doer = doer, doer.dmgOverTime.time = 5, !0);
                },
                scale: 27,
                holdOffset: 15
            },
            {
                group: module.exports.groups[1],
                name: 'wood wall',
                desc: 'provides protection for your village',
                req: [
                    'wood',
                    10
                ],
                projDmg: !0,
                health: 380,
                scale: 50,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                age: 3,
                group: module.exports.groups[1],
                name: 'stone wall',
                desc: 'provides improved protection for your village',
                req: [
                    'stone',
                    25
                ],
                health: 900,
                scale: 50,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                age: 7,
                pre: 1,
                group: module.exports.groups[1],
                name: 'castle wall',
                desc: 'provides powerful protection for your village',
                req: [
                    'stone',
                    35
                ],
                health: 1500,
                scale: 52,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                group: module.exports.groups[2],
                name: 'spikes',
                desc: 'damages enemies when they touch them',
                req: [
                    'wood',
                    20,
                    'stone',
                    5
                ],
                health: 400,
                dmg: 20,
                scale: 49,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5
            },
            {
                age: 5,
                group: module.exports.groups[2],
                name: 'greater spikes',
                desc: 'damages enemies when they touch them',
                req: [
                    'wood',
                    30,
                    'stone',
                    10
                ],
                health: 500,
                dmg: 35,
                scale: 52,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5
            },
            {
                age: 9,
                pre: 1,
                group: module.exports.groups[2],
                name: 'poison spikes',
                desc: 'poisons enemies when they touch them',
                req: [
                    'wood',
                    35,
                    'stone',
                    15
                ],
                health: 600,
                dmg: 30,
                pDmg: 5,
                scale: 52,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5
            },
            {
                age: 9,
                pre: 2,
                group: module.exports.groups[2],
                name: 'spinning spikes',
                desc: 'damages enemies when they touch them',
                req: [
                    'wood',
                    30,
                    'stone',
                    20
                ],
                health: 500,
                dmg: 45,
                turnSpeed: 0.003,
                scale: 52,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5
            },
            {
                group: module.exports.groups[3],
                name: 'windmill',
                desc: 'generates gold over time',
                req: [
                    'wood',
                    50,
                    'stone',
                    10
                ],
                health: 400,
                pps: 1,
                turnSpeed: 0.0016,
                spritePadding: 25,
                iconLineMult: 12,
                scale: 45,
                holdOffset: 20,
                placeOffset: 5
            },
            {
                age: 5,
                pre: 1,
                group: module.exports.groups[3],
                name: 'faster windmill',
                desc: 'generates more gold over time',
                req: [
                    'wood',
                    60,
                    'stone',
                    20
                ],
                health: 500,
                pps: 1.5,
                turnSpeed: 0.0025,
                spritePadding: 25,
                iconLineMult: 12,
                scale: 47,
                holdOffset: 20,
                placeOffset: 5
            },
            {
                age: 8,
                pre: 1,
                group: module.exports.groups[3],
                name: 'power mill',
                desc: 'generates more gold over time',
                req: [
                    'wood',
                    100,
                    'stone',
                    50
                ],
                health: 800,
                pps: 2,
                turnSpeed: 0.005,
                spritePadding: 25,
                iconLineMult: 12,
                scale: 47,
                holdOffset: 20,
                placeOffset: 5
            },
            {
                age: 5,
                group: module.exports.groups[4],
                type: 2,
                name: 'mine',
                desc: 'allows you to mine stone',
                req: [
                    'wood',
                    20,
                    'stone',
                    100
                ],
                iconLineMult: 12,
                scale: 65,
                holdOffset: 20,
                placeOffset: 0
            },
            {
                age: 5,
                group: module.exports.groups[11],
                type: 0,
                name: 'sapling',
                desc: 'allows you to farm wood',
                req: [
                    'wood',
                    150
                ],
                iconLineMult: 12,
                colDiv: 0.5,
                scale: 110,
                holdOffset: 50,
                placeOffset: -15
            },
            {
                age: 4,
                group: module.exports.groups[5],
                name: 'pit trap',
                desc: 'pit that traps enemies if they walk over it',
                req: [
                    'wood',
                    30,
                    'stone',
                    30
                ],
                trap: !0,
                ignoreCollision: !0,
                hideFromEnemy: !0,
                health: 500,
                colDiv: 0.2,
                scale: 50,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                age: 4,
                group: module.exports.groups[6],
                name: 'boost pad',
                desc: 'provides boost when stepped on',
                req: [
                    'stone',
                    20,
                    'wood',
                    5
                ],
                ignoreCollision: !0,
                boostSpeed: 1.5,
                health: 150,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                age: 7,
                group: module.exports.groups[7],
                doUpdate: !0,
                name: 'turret',
                desc: 'defensive structure that shoots at enemies',
                req: [
                    'wood',
                    200,
                    'stone',
                    150
                ],
                health: 800,
                projectile: 1,
                shootRange: 700,
                shootRate: 2200,
                scale: 43,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                age: 7,
                group: module.exports.groups[8],
                name: 'platform',
                desc: 'platform to shoot over walls and cross over water',
                req: [
                    'wood',
                    20
                ],
                ignoreCollision: !0,
                zIndex: 1,
                health: 300,
                scale: 43,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                age: 7,
                group: module.exports.groups[9],
                name: 'healing pad',
                desc: 'standing on it will slowly heal you',
                req: [
                    'wood',
                    30,
                    'food',
                    10
                ],
                ignoreCollision: !0,
                healCol: 15,
                health: 400,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                age: 9,
                group: module.exports.groups[10],
                name: 'spawn pad',
                desc: 'you will spawn here when you die but it will dissapear',
                req: [
                    'wood',
                    100,
                    'stone',
                    100
                ],
                health: 400,
                ignoreCollision: !0,
                spawnPoint: !0,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                age: 7,
                group: module.exports.groups[12],
                name: 'blocker',
                desc: 'blocks building in radius',
                req: [
                    'wood',
                    30,
                    'stone',
                    25
                ],
                ignoreCollision: !0,
                blocker: 300,
                health: 400,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5
            },
            {
                age: 7,
                group: module.exports.groups[13],
                name: 'teleporter',
                desc: 'teleports you to a random point on the map',
                req: [
                    'wood',
                    60,
                    'stone',
                    60
                ],
                ignoreCollision: !0,
                teleport: !0,
                health: 200,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5
            }
        ];
        for (var i = 0; i < module.exports.list.length; ++i)
            module.exports.list[i].id = i, module.exports.list[i].pre && (module.exports.list[i].pre = i - module.exports.list[i].pre);
    },
    function (module, t) {
        /* 10: ./src/js/data/mapManager.js */
        module.exports = {};
        /* Please dont remove this line if you use this in your script <3 */
        console.context().log('This script is made using Illya#9999\'s bundle processor');
    },
    function (module, t) {
        /* 11: ./src/js/data/objectManager.js */
        var mathFloor = Math.floor, mathABS = Math.abs, mathCOS = Math.cos, mathSIN = Math.sin, mathSQRT = (Math.pow, Math.sqrt);
        module.exports = function (GameObject, gameObjects, UTILS, config, players, server) {
            var tmpX, tmpY;
            this.objects = gameObjects, this.grids = {}, this.updateObjects = [];
            var tmpS = config.mapScale / config.colGrid;
            this.setObjectGrids = function (obj) {
                for (var objX = Math.min(config.mapScale, Math.max(0, obj.x)), objY = Math.min(config.mapScale, Math.max(0, obj.y)), x = 0; x < config.colGrid; ++x) {
                    tmpX = x * tmpS;
                    for (var y = 0; y < config.colGrid; ++y)
                        tmpY = y * tmpS, objX + obj.scale >= tmpX && objX - obj.scale <= tmpX + tmpS && objY + obj.scale >= tmpY && objY - obj.scale <= tmpY + tmpS && (this.grids[x + '_' + y] || (this.grids[x + '_' + y] = []), this.grids[x + '_' + y].push(obj), obj.gridLocations.push(x + '_' + y));
                }
            }, this.removeObjGrid = function (obj) {
                for (var tmpIndx, i = 0; i < obj.gridLocations.length; ++i)
                    (tmpIndx = this.grids[obj.gridLocations[i]].indexOf(obj)) >= 0 && this.grids[obj.gridLocations[i]].splice(tmpIndx, 1);
            }, this.disableObj = function (obj) {
                if (obj.active = !1, server) {
                    obj.owner && obj.pps && (obj.owner.pps -= obj.pps), this.removeObjGrid(obj);
                    var tmpIndx = this.updateObjects.indexOf(obj);
                    tmpIndx >= 0 && this.updateObjects.splice(tmpIndx, 1);
                }
            }, this.hitObj = function (tmpObj, tmpDir) {
                for (var p = 0; p < players.length; ++p)
                    players[p].active && (tmpObj.sentTo[players[p].id] && (tmpObj.active ? players[p].canSee(tmpObj) && server.send(players[p].id, '8', UTILS.fixTo(tmpDir, 1), tmpObj.sid) : server.send(players[p].id, '12', tmpObj.sid)), tmpObj.active || tmpObj.owner != players[p] || players[p].changeItemCount(tmpObj.group.id, -1));
            };
            var tmpGrid, tmpObj, tmpArray = [];
            this.getGridArrays = function (xPos, yPos, s) {
                tmpX = mathFloor(xPos / tmpS), tmpY = mathFloor(yPos / tmpS), tmpArray.length = 0;
                try {
                    this.grids[tmpX + '_' + tmpY] && tmpArray.push(this.grids[tmpX + '_' + tmpY]), xPos + s >= (tmpX + 1) * tmpS && ((tmpGrid = this.grids[tmpX + 1 + '_' + tmpY]) && tmpArray.push(tmpGrid), tmpY && yPos - s <= tmpY * tmpS ? (tmpGrid = this.grids[tmpX + 1 + '_' + (tmpY - 1)]) && tmpArray.push(tmpGrid) : yPos + s >= (tmpY + 1) * tmpS && (tmpGrid = this.grids[tmpX + 1 + '_' + (tmpY + 1)]) && tmpArray.push(tmpGrid)), tmpX && xPos - s <= tmpX * tmpS && ((tmpGrid = this.grids[tmpX - 1 + '_' + tmpY]) && tmpArray.push(tmpGrid), tmpY && yPos - s <= tmpY * tmpS ? (tmpGrid = this.grids[tmpX - 1 + '_' + (tmpY - 1)]) && tmpArray.push(tmpGrid) : yPos + s >= (tmpY + 1) * tmpS && (tmpGrid = this.grids[tmpX - 1 + '_' + (tmpY + 1)]) && tmpArray.push(tmpGrid)), yPos + s >= (tmpY + 1) * tmpS && (tmpGrid = this.grids[tmpX + '_' + (tmpY + 1)]) && tmpArray.push(tmpGrid), tmpY && yPos - s <= tmpY * tmpS && (tmpGrid = this.grids[tmpX + '_' + (tmpY - 1)]) && tmpArray.push(tmpGrid);
                } catch (e) {
                }
                return tmpArray;
            }, this.add = function (sid, x, y, dir, s, type, data, setSID, owner) {
                tmpObj = null;
                for (var i = 0; i < gameObjects.length; ++i)
                    if (gameObjects[i].sid == sid) {
                        tmpObj = gameObjects[i];
                        break;
                    }
                if (!tmpObj)
                    for (i = 0; i < gameObjects.length; ++i)
                        if (!gameObjects[i].active) {
                            tmpObj = gameObjects[i];
                            break;
                        }
                tmpObj || (tmpObj = new GameObject(sid), gameObjects.push(tmpObj)), setSID && (tmpObj.sid = sid), tmpObj.init(x, y, dir, s, type, data, owner), server && (this.setObjectGrids(tmpObj), tmpObj.doUpdate && this.updateObjects.push(tmpObj));
            }, this.disableBySid = function (sid) {
                for (var i = 0; i < gameObjects.length; ++i)
                    if (gameObjects[i].sid == sid) {
                        this.disableObj(gameObjects[i]);
                        break;
                    }
            }, this.removeAllItems = function (sid, server) {
                for (var i = 0; i < gameObjects.length; ++i)
                    gameObjects[i].active && gameObjects[i].owner && gameObjects[i].owner.sid == sid && this.disableObj(gameObjects[i]);
                server && server.broadcast('13', sid);
            }, this.fetchSpawnObj = function (sid) {
                for (var tmpLoc = null, i = 0; i < gameObjects.length; ++i)
                    if ((tmpObj = gameObjects[i]).active && tmpObj.owner && tmpObj.owner.sid == sid && tmpObj.spawnPoint) {
                        tmpLoc = [
                            tmpObj.x,
                            tmpObj.y
                        ], this.disableObj(tmpObj), server.broadcast('12', tmpObj.sid), tmpObj.owner && tmpObj.owner.changeItemCount(tmpObj.group.id, -1);
                        break;
                    }
                return tmpLoc;
            }, this.checkItemLocation = function (x, y, s, sM, indx, ignoreWater, placer) {
                for (var i = 0; i < gameObjects.length; ++i) {
                    var blockS = gameObjects[i].blocker ? gameObjects[i].blocker : gameObjects[i].getScale(sM, gameObjects[i].isItem);
                    if (gameObjects[i].active && UTILS.getDistance(x, y, gameObjects[i].x, gameObjects[i].y) < s + blockS)
                        return !1;
                }
                return !(!ignoreWater && 18 != indx && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2);
            }, this.addProjectile = function (x, y, dir, range, indx) {
                for (var tmpProj, tmpData = items.projectiles[indx], i = 0; i < projectiles.length; ++i)
                    if (!projectiles[i].active) {
                        tmpProj = projectiles[i];
                        break;
                    }
                tmpProj || (tmpProj = new Projectile(players, UTILS), projectiles.push(tmpProj)), tmpProj.init(indx, x, y, dir, tmpData.speed, range, tmpData.scale);
            }, this.checkCollision = function (player, other, delta) {
                delta = delta || 1;
                var dx = player.x - other.x, dy = player.y - other.y, tmpLen = player.scale + other.scale;
                if (mathABS(dx) <= tmpLen || mathABS(dy) <= tmpLen) {
                    tmpLen = player.scale + (other.getScale ? other.getScale() : other.scale);
                    var tmpInt = mathSQRT(dx * dx + dy * dy) - tmpLen;
                    if (tmpInt <= 0) {
                        if (other.ignoreCollision)
                            !other.trap || player.noTrap || other.owner == player || other.owner && other.owner.team && other.owner.team == player.team ? other.boostSpeed ? (player.xVel += delta * other.boostSpeed * (other.weightM || 1) * mathCOS(other.dir), player.yVel += delta * other.boostSpeed * (other.weightM || 1) * mathSIN(other.dir)) : other.healCol ? player.healCol = other.healCol : other.teleport && (player.x = UTILS.randInt(0, config.mapScale), player.y = UTILS.randInt(0, config.mapScale)) : (player.lockMove = !0, other.hideFromEnemy = !1);
                        else {
                            var tmpDir = UTILS.getDirection(player.x, player.y, other.x, other.y);
                            if (UTILS.getDistance(player.x, player.y, other.x, other.y), other.isPlayer ? (tmpInt = -1 * tmpInt / 2, player.x += tmpInt * mathCOS(tmpDir), player.y += tmpInt * mathSIN(tmpDir), other.x -= tmpInt * mathCOS(tmpDir), other.y -= tmpInt * mathSIN(tmpDir)) : (player.x = other.x + tmpLen * mathCOS(tmpDir), player.y = other.y + tmpLen * mathSIN(tmpDir), player.xVel *= 0.75, player.yVel *= 0.75), other.dmg && other.owner != player && (!other.owner || !other.owner.team || other.owner.team != player.team)) {
                                player.changeHealth(-other.dmg, other.owner, other);
                                var tmpSpd = 1.5 * (other.weightM || 1);
                                player.xVel += tmpSpd * mathCOS(tmpDir), player.yVel += tmpSpd * mathSIN(tmpDir), !other.pDmg || player.skin && player.skin.poisonRes || (player.dmgOverTime.dmg = other.pDmg, player.dmgOverTime.time = 5, player.dmgOverTime.doer = other.owner), player.colDmg && other.health && (other.changeHealth(-player.colDmg) && this.disableObj(other), this.hitObj(other, UTILS.getDirection(player.x, player.y, other.x, other.y)));
                            }
                        }
                        return other.zIndex > player.zIndex && (player.zIndex = other.zIndex), !0;
                    }
                }
                return !1;
            };
        };
    },
    function (module, t, __webpack_require__) {
        /* 12: ./src/js/data/player.js */
        var langFilter = new (__webpack_require__(13))();
        langFilter.addWords('jew', 'black', 'baby', 'child', 'white', 'porn', 'pedo', 'trump', 'clinton', 'hitler', 'nazi', 'gay', 'pride', 'sex', 'pleasure', 'touch', 'poo', 'kids', 'rape', 'white power', 'nigga', 'nig nog', 'doggy', 'rapist', 'boner', 'nigger', 'nigg', 'finger', 'nogger', 'nagger', 'nig', 'fag', 'gai', 'pole', 'stripper', 'penis', 'vagina', 'pussy', 'nazi', 'hitler', 'stalin', 'burn', 'chamber', 'cock', 'peen', 'dick', 'spick', 'nieger', 'die', 'satan', 'n|ig', 'nlg', 'cunt', 'c0ck', 'fag', 'lick', 'condom', 'anal', 'shit', 'phile', 'little', 'kids', 'free KR', 'tiny', 'sidney', 'ass', 'kill', '.io', '(dot)', '[dot]', 'mini', 'whiore', 'whore', 'faggot', 'github', '1337', '666', 'satan', 'senpa', 'discord', 'd1scord', 'mistik', '.io', 'senpa.io', 'sidney', 'sid', 'senpaio', 'vries', 'asa');
        var mathABS = Math.abs, mathCOS = Math.cos, mathSIN = Math.sin, mathPOW = Math.pow, mathSQRT = Math.sqrt;
        module.exports = function (id, sid, config, UTILS, projectileManager, objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
            this.id = id, this.sid = sid, this.tmpScore = 0, this.team = null, this.skinIndex = 0, this.tailIndex = 0, this.hitTime = 0, this.tails = {};
            for (var i = 0; i < accessories.length; ++i)
                accessories[i].price <= 0 && (this.tails[accessories[i].id] = 1);
            for (this.skins = {}, i = 0; i < hats.length; ++i)
                hats[i].price <= 0 && (this.skins[hats[i].id] = 1);
            this.points = 0, this.dt = 0, this.hidden = !1, this.itemCounts = {}, this.isPlayer = !0, this.pps = 0, this.moveDir = void 0, this.skinRot = 0, this.lastPing = 0, this.iconIndex = 0, this.skinColor = 0, this.spawn = function (moofoll) {
                this.active = !0, this.alive = !0, this.lockMove = !1, this.lockDir = !1, this.minimapCounter = 0, this.chatCountdown = 0, this.shameCount = 0, this.shameTimer = 0, this.sentTo = {}, this.gathering = 0, this.autoGather = 0, this.animTime = 0, this.animSpeed = 0, this.mouseState = 0, this.buildIndex = -1, this.weaponIndex = 0, this.dmgOverTime = {}, this.noMovTimer = 0, this.maxXP = 300, this.XP = 0, this.age = 1, this.kills = 0, this.upgrAge = 2, this.upgradePoints = 0, this.x = 0, this.y = 0, this.zIndex = 0, this.xVel = 0, this.yVel = 0, this.slowMult = 1, this.dir = 0, this.dirPlus = 0, this.targetDir = 0, this.targetAngle = 0, this.maxHealth = 100, this.health = this.maxHealth, this.cHealth = this.health, this.scale = config.playerScale, this.speed = config.playerSpeed, this.resetMoveDir(), this.resetResources(moofoll), this.items = [
                    0,
                    3,
                    6,
                    10
                ], this.weapons = [0], this.shootCount = 0, this.weaponXP = [], this.reloads = {};
            }, this.resetMoveDir = function () {
                this.moveDir = void 0;
            }, this.resetResources = function (moofoll) {
                for (var i = 0; i < config.resourceTypes.length; ++i)
                    this[config.resourceTypes[i]] = moofoll ? 100 : 0;
            }, this.addItem = function (id) {
                var tmpItem = items.list[id];
                if (tmpItem) {
                    for (var i = 0; i < this.items.length; ++i)
                        if (items.list[this.items[i]].group == tmpItem.group)
                            return this.buildIndex == this.items[i] && (this.buildIndex = id), this.items[i] = id, !0;
                    return this.items.push(id), !0;
                }
                return !1;
            }, this.setUserData = function (data) {
                if (data) {
                    this.name = 'unknown';
                    var name = data.name + '', isProfane = !1, convertedName = (name = (name = (name = (name = name.slice(0, config.maxNameLength)).replace(/[^\w:\(\)\/? -]+/gim, ' ')).replace(/[^\x00-\x7F]/g, ' ')).trim()).toLowerCase().replace(/\s/g, '').replace(/1/g, 'i').replace(/0/g, 'o').replace(/5/g, 's');
                    for (var word of langFilter.list)
                        if (-1 != convertedName.indexOf(word)) {
                            isProfane = !0;
                            break;
                        }
                    name.length > 0 && !isProfane && (this.name = name), this.skinColor = 0, config.skinColors[data.skin] && (this.skinColor = data.skin);
                }
            }, this.getData = function () {
                return [
                    this.id,
                    this.sid,
                    this.name,
                    UTILS.fixTo(this.x, 2),
                    UTILS.fixTo(this.y, 2),
                    UTILS.fixTo(this.dir, 3),
                    this.health,
                    this.maxHealth,
                    this.scale,
                    this.skinColor
                ];
            }, this.setData = function (data) {
                this.id = data[0], this.sid = data[1], this.name = data[2], this.x = data[3], this.y = data[4], this.dir = data[5], this.health = data[6], this.maxHealth = data[7], this.scale = data[8], this.skinColor = data[9];
            };
            var timerCount = 0;
            this.update = function (delta) {
                if (this.alive) {
                    if (this.shameTimer > 0 && (this.shameTimer -= delta, this.shameTimer <= 0 && (this.shameTimer = 0, this.shameCount = 0)), (timerCount -= delta) <= 0) {
                        var regenAmount = (this.skin && this.skin.healthRegen ? this.skin.healthRegen : 0) + (this.tail && this.tail.healthRegen ? this.tail.healthRegen : 0);
                        regenAmount && this.changeHealth(regenAmount, this), this.dmgOverTime.dmg && (this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer), this.dmgOverTime.time -= 1, this.dmgOverTime.time <= 0 && (this.dmgOverTime.dmg = 0)), this.healCol && this.changeHealth(this.healCol, this), timerCount = 1000;
                    }
                    if (this.alive) {
                        if (this.slowMult < 1 && (this.slowMult += 0.0008 * delta, this.slowMult > 1 && (this.slowMult = 1)), this.noMovTimer += delta, (this.xVel || this.yVel) && (this.noMovTimer = 0), this.lockMove)
                            this.xVel = 0, this.yVel = 0;
                        else {
                            var spdMult = (this.buildIndex >= 0 ? 0.5 : 1) * (items.weapons[this.weaponIndex].spdMult || 1) * (this.skin && this.skin.spdMult || 1) * (this.tail && this.tail.spdMult || 1) * (this.y <= config.snowBiomeTop ? this.skin && this.skin.coldM ? 1 : config.snowSpeed : 1) * this.slowMult;
                            !this.zIndex && this.y >= config.mapScale / 2 - config.riverWidth / 2 && this.y <= config.mapScale / 2 + config.riverWidth / 2 && (this.skin && this.skin.watrImm ? (spdMult *= 0.75, this.xVel += 0.4 * config.waterCurrent * delta) : (spdMult *= 0.33, this.xVel += config.waterCurrent * delta));
                            var xVel = null != this.moveDir ? mathCOS(this.moveDir) : 0, yVel = null != this.moveDir ? mathSIN(this.moveDir) : 0, length = mathSQRT(xVel * xVel + yVel * yVel);
                            0 != length && (xVel /= length, yVel /= length), xVel && (this.xVel += xVel * this.speed * spdMult * delta), yVel && (this.yVel += yVel * this.speed * spdMult * delta);
                        }
                        var tmpList;
                        this.zIndex = 0, this.lockMove = !1, this.healCol = 0;
                        for (var tmpSpeed = UTILS.getDistance(0, 0, this.xVel * delta, this.yVel * delta), depth = Math.min(4, Math.max(1, Math.round(tmpSpeed / 40))), tMlt = 1 / depth, alreadyCollided = {}, i = 0; i < depth; ++i) {
                            this.xVel && (this.x += this.xVel * delta * tMlt), this.yVel && (this.y += this.yVel * delta * tMlt), tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                            for (var x = 0; x < tmpList.length; ++x) {
                                for (var y = 0; y < tmpList[x].length && (!tmpList[x][y].active || alreadyCollided[tmpList[x][y].sid] || !objectManager.checkCollision(this, tmpList[x][y], tMlt) || (alreadyCollided[tmpList[x][y].sid] = !0, this.alive)); ++y);
                                if (!this.alive)
                                    break;
                            }
                            if (!this.alive)
                                break;
                        }
                        for (i = (tmpIndx = players.indexOf(this)) + 1; i < players.length; ++i)
                            players[i] != this && players[i].alive && objectManager.checkCollision(this, players[i]);
                        if (this.xVel && (this.xVel *= mathPOW(config.playerDecel, delta), this.xVel <= 0.01 && this.xVel >= -0.01 && (this.xVel = 0)), this.yVel && (this.yVel *= mathPOW(config.playerDecel, delta), this.yVel <= 0.01 && this.yVel >= -0.01 && (this.yVel = 0)), this.x - this.scale < 0 ? this.x = this.scale : this.x + this.scale > config.mapScale && (this.x = config.mapScale - this.scale), this.y - this.scale < 0 ? this.y = this.scale : this.y + this.scale > config.mapScale && (this.y = config.mapScale - this.scale), this.buildIndex < 0)
                            if (this.reloads[this.weaponIndex] > 0)
                                this.reloads[this.weaponIndex] -= delta, this.gathering = this.mouseState;
                            else if (this.gathering || this.autoGather) {
                                var worked = !0;
                                if (null != items.weapons[this.weaponIndex].gather)
                                    this.gather(players);
                                else if (null != items.weapons[this.weaponIndex].projectile && this.hasRes(items.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0)) {
                                    this.useRes(items.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0), this.noMovTimer = 0;
                                    var tmpIndx = items.weapons[this.weaponIndex].projectile, projOffset = 2 * this.scale, aMlt = this.skin && this.skin.aMlt ? this.skin.aMlt : 1;
                                    items.weapons[this.weaponIndex].rec && (this.xVel -= items.weapons[this.weaponIndex].rec * mathCOS(this.dir), this.yVel -= items.weapons[this.weaponIndex].rec * mathSIN(this.dir)), projectileManager.addProjectile(this.x + projOffset * mathCOS(this.dir), this.y + projOffset * mathSIN(this.dir), this.dir, items.projectiles[tmpIndx].range * aMlt, items.projectiles[tmpIndx].speed * aMlt, tmpIndx, this, null, this.zIndex);
                                } else
                                    worked = !1;
                                this.gathering = this.mouseState, worked && (this.reloads[this.weaponIndex] = items.weapons[this.weaponIndex].speed * (this.skin && this.skin.atkSpd || 1));
                            }
                    }
                }
            }, this.addWeaponXP = function (amnt) {
                this.weaponXP[this.weaponIndex] || (this.weaponXP[this.weaponIndex] = 0), this.weaponXP[this.weaponIndex] += amnt;
            }, this.earnXP = function (amount) {
                this.age < config.maxAge && (this.XP += amount, this.XP >= this.maxXP ? (this.age < config.maxAge ? (this.age++, this.XP = 0, this.maxXP *= 1.2) : this.XP = this.maxXP, this.upgradePoints++, server.send(this.id, '16', this.upgradePoints, this.upgrAge), server.send(this.id, '15', this.XP, UTILS.fixTo(this.maxXP, 1), this.age)) : server.send(this.id, '15', this.XP));
            }, this.changeHealth = function (amount, doer) {
                if (amount > 0 && this.health >= this.maxHealth)
                    return !1;
                amount < 0 && this.skin && (amount *= this.skin.dmgMult || 1), amount < 0 && this.tail && (amount *= this.tail.dmgMult || 1), amount < 0 && (this.hitTime = Date.now()), this.health += amount, this.health > this.maxHealth && (amount -= this.health - this.maxHealth, this.health = this.maxHealth), this.health <= 0 && this.kill(doer);
                for (var i = 0; i < players.length; ++i)
                    this.sentTo[players[i].id] && server.send(players[i].id, 'h', this.sid, this.health);
                return !doer || !doer.canSee(this) || doer == this && amount < 0 || server.send(doer.id, 't', Math.round(this.x), Math.round(this.y), Math.round(-amount), 1), !0;
            }, this.kill = function (doer) {
                doer && doer.alive && (doer.kills++, doer.skin && doer.skin.goldSteal ? scoreCallback(doer, Math.round(this.points / 2)) : scoreCallback(doer, Math.round(100 * this.age * (doer.skin && doer.skin.kScrM ? doer.skin.kScrM : 1))), server.send(doer.id, '9', 'kills', doer.kills, 1)), this.alive = !1, server.send(this.id, '11'), iconCallback();
            }, this.addResource = function (type, amount, auto) {
                !auto && amount > 0 && this.addWeaponXP(amount), 3 == type ? scoreCallback(this, amount, !0) : (this[config.resourceTypes[type]] += amount, server.send(this.id, '9', config.resourceTypes[type], this[config.resourceTypes[type]], 1));
            }, this.changeItemCount = function (index, value) {
                this.itemCounts[index] = this.itemCounts[index] || 0, this.itemCounts[index] += value, server.send(this.id, '14', index, this.itemCounts[index]);
            }, this.buildItem = function (item) {
                var tmpS = this.scale + item.scale + (item.placeOffset || 0), tmpX = this.x + tmpS * mathCOS(this.dir), tmpY = this.y + tmpS * mathSIN(this.dir);
                if (this.canBuild(item) && !(item.consume && this.skin && this.skin.noEat) && (item.consume || objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, !1, this))) {
                    var worked = !1;
                    if (item.consume) {
                        if (this.hitTime) {
                            var timeSinceHit = Date.now() - this.hitTime;
                            this.hitTime = 0, timeSinceHit <= 120 ? (this.shameCount++, this.shameCount >= 8 && (this.shameTimer = 30000, this.shameCount = 0)) : (this.shameCount -= 2, this.shameCount <= 0 && (this.shameCount = 0));
                        }
                        this.shameTimer <= 0 && (worked = item.consume(this));
                    } else
                        worked = !0, item.group.limit && this.changeItemCount(item.group.id, 1), item.pps && (this.pps += item.pps), objectManager.add(objectManager.objects.length, tmpX, tmpY, this.dir, item.scale, item.type, item, !1, this);
                    worked && (this.useRes(item), this.buildIndex = -1);
                }
            }, this.hasRes = function (item, mult) {
                for (var i = 0; i < item.req.length;) {
                    if (this[item.req[i]] < Math.round(item.req[i + 1] * (mult || 1)))
                        return !1;
                    i += 2;
                }
                return !0;
            }, this.useRes = function (item, mult) {
                if (!config.inSandbox)
                    for (var i = 0; i < item.req.length;)
                        this.addResource(config.resourceTypes.indexOf(item.req[i]), -Math.round(item.req[i + 1] * (mult || 1))), i += 2;
            }, this.canBuild = function (item) {
                var limit = config.inSandbox ? Math.max(3 * item.group.limit, 50) : item.group.limit;
                return !(limit && this.itemCounts[item.group.id] >= limit) && (!!config.inSandbox || this.hasRes(item));
            }, this.gather = function () {
                this.noMovTimer = 0, this.slowMult -= items.weapons[this.weaponIndex].hitSlow || 0.3, this.slowMult < 0 && (this.slowMult = 0);
                for (var tmpDir, tmpObj, hitSomething, tmpVariant = config.fetchVariant(this), applyPoison = tmpVariant.poison, variantDmg = tmpVariant.val, hitObjs = {}, tmpList = objectManager.getGridArrays(this.x, this.y, items.weapons[this.weaponIndex].range), t = 0; t < tmpList.length; ++t)
                    for (var i = 0; i < tmpList[t].length; ++i)
                        if ((tmpObj = tmpList[t][i]).active && !tmpObj.dontGather && !hitObjs[tmpObj.sid] && tmpObj.visibleToPlayer(this) && UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y) - tmpObj.scale <= items.weapons[this.weaponIndex].range && (tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y), UTILS.getAngleDist(tmpDir, this.dir) <= config.gatherAngle)) {
                            if (hitObjs[tmpObj.sid] = 1, tmpObj.health) {
                                if (tmpObj.changeHealth(-items.weapons[this.weaponIndex].dmg * variantDmg * (items.weapons[this.weaponIndex].sDmg || 1) * (this.skin && this.skin.bDmg ? this.skin.bDmg : 1), this)) {
                                    for (var x = 0; x < tmpObj.req.length;)
                                        this.addResource(config.resourceTypes.indexOf(tmpObj.req[x]), tmpObj.req[x + 1]), x += 2;
                                    objectManager.disableObj(tmpObj);
                                }
                            } else {
                                this.earnXP(4 * items.weapons[this.weaponIndex].gather);
                                var count = items.weapons[this.weaponIndex].gather + (3 == tmpObj.type ? 4 : 0);
                                this.skin && this.skin.extraGold && this.addResource(3, 1), this.addResource(tmpObj.type, count);
                            }
                            hitSomething = !0, objectManager.hitObj(tmpObj, tmpDir);
                        }
                for (i = 0; i < players.length + ais.length; ++i)
                    if ((tmpObj = players[i] || ais[i - players.length]) != this && tmpObj.alive && (!tmpObj.team || tmpObj.team != this.team) && UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y) - 1.8 * tmpObj.scale <= items.weapons[this.weaponIndex].range && (tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y), UTILS.getAngleDist(tmpDir, this.dir) <= config.gatherAngle)) {
                        var stealCount = items.weapons[this.weaponIndex].steal;
                        stealCount && tmpObj.addResource && (stealCount = Math.min(tmpObj.points || 0, stealCount), this.addResource(3, stealCount), tmpObj.addResource(3, -stealCount));
                        var dmgMlt = variantDmg;
                        null != tmpObj.weaponIndex && items.weapons[tmpObj.weaponIndex].shield && UTILS.getAngleDist(tmpDir + Math.PI, tmpObj.dir) <= config.shieldAngle && (dmgMlt = items.weapons[tmpObj.weaponIndex].shield);
                        var baseDmgVal = items.weapons[this.weaponIndex].dmg, dmgVal = baseDmgVal * (this.skin && this.skin.dmgMultO ? this.skin.dmgMultO : 1) * (this.tail && this.tail.dmgMultO ? this.tail.dmgMultO : 1), tmpSpd = 0.3 * (tmpObj.weightM || 1) + (items.weapons[this.weaponIndex].knock || 0);
                        tmpObj.xVel += tmpSpd * mathCOS(tmpDir), tmpObj.yVel += tmpSpd * mathSIN(tmpDir), this.skin && this.skin.healD && this.changeHealth(dmgVal * dmgMlt * this.skin.healD, this), this.tail && this.tail.healD && this.changeHealth(dmgVal * dmgMlt * this.tail.healD, this), tmpObj.skin && tmpObj.skin.dmg && this.changeHealth(-baseDmgVal * tmpObj.skin.dmg, tmpObj), tmpObj.tail && tmpObj.tail.dmg && this.changeHealth(-baseDmgVal * tmpObj.tail.dmg, tmpObj), !(tmpObj.dmgOverTime && this.skin && this.skin.poisonDmg) || tmpObj.skin && tmpObj.skin.poisonRes || (tmpObj.dmgOverTime.dmg = this.skin.poisonDmg, tmpObj.dmgOverTime.time = this.skin.poisonTime || 1, tmpObj.dmgOverTime.doer = this), !tmpObj.dmgOverTime || !applyPoison || tmpObj.skin && tmpObj.skin.poisonRes || (tmpObj.dmgOverTime.dmg = 5, tmpObj.dmgOverTime.time = 5, tmpObj.dmgOverTime.doer = this), tmpObj.skin && tmpObj.skin.dmgK && (this.xVel -= tmpObj.skin.dmgK * mathCOS(tmpDir), this.yVel -= tmpObj.skin.dmgK * mathSIN(tmpDir)), tmpObj.changeHealth(-dmgVal * dmgMlt, this, this);
                    }
                this.sendAnimation(hitSomething ? 1 : 0);
            }, this.sendAnimation = function (hit) {
                for (var i = 0; i < players.length; ++i)
                    this.sentTo[players[i].id] && this.canSee(players[i]) && server.send(players[i].id, '7', this.sid, hit ? 1 : 0, this.weaponIndex);
            };
            var tmpRatio = 0, animIndex = 0;
            this.animate = function (delta) {
                this.animTime > 0 && (this.animTime -= delta, this.animTime <= 0 ? (this.animTime = 0, this.dirPlus = 0, tmpRatio = 0, animIndex = 0) : 0 == animIndex ? (tmpRatio += delta / (this.animSpeed * config.hitReturnRatio), this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio)), tmpRatio >= 1 && (tmpRatio = 1, animIndex = 1)) : (tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio)), this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio))));
            }, this.startAnim = function (didHit, index) {
                this.animTime = this.animSpeed = items.weapons[index].speed, this.targetAngle = didHit ? -config.hitAngle : -Math.PI, tmpRatio = 0, animIndex = 0;
            }, this.canSee = function (other) {
                if (!other)
                    return !1;
                if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer)
                    return !1;
                var dx = mathABS(other.x - this.x) - other.scale, dy = mathABS(other.y - this.y) - other.scale;
                return dx <= config.maxScreenWidth / 2 * 1.3 && dy <= config.maxScreenHeight / 2 * 1.3;
            };
        };
    },
    function (e, t, i) {
        /* 13: ./node_modules/bad-words/lib/badwords.js */
        const n = i(14).words, s = i(15).array;
        e.exports = class {
            constructor(options = {}) {
                Object.assign(this, {
                    list: options.emptyList && [] || Array.prototype.concat.apply(n, [
                        s,
                        options.list || []
                    ]),
                    exclude: options.exclude || [],
                    placeHolder: options.placeHolder || '*',
                    regex: options.regex || /[^a-zA-Z0-9|\$|\@]|\^/g,
                    replaceRegex: options.replaceRegex || /\w/g
                });
            }
            isProfane(string) {
                return this.list.filter(word => {
                    const wordExp = new RegExp(`\\b${ word.replace(/(\W)/g, '\\$1') }\\b`, 'gi');
                    return !this.exclude.includes(word.toLowerCase()) && wordExp.test(string);
                }).length > 0 || !1;
            }
            replaceWord(string) {
                return string.replace(this.regex, '').replace(this.replaceRegex, this.placeHolder);
            }
            clean(string) {
                return string.split(/\b/).map(word => this.isProfane(word) ? this.replaceWord(word) : word).join('');
            }
            addWords() {
                let words = Array.from(arguments);
                this.list.push(...words), words.map(word => word.toLowerCase()).forEach(word => {
                    this.exclude.includes(word) && this.exclude.splice(this.exclude.indexOf(word), 1);
                });
            }
            removeWords() {
                this.exclude.push(...Array.from(arguments).map(word => word.toLowerCase()));
            }
        };
    },
    function (e) {
        /* 14: ./node_modules/badwords-list/lib/index.js */
        e.exports = {
            words: [
                'ahole',
                'anus',
                'ash0le',
                'ash0les',
                'asholes',
                'ass',
                'Ass Monkey',
                'Assface',
                'assh0le',
                'assh0lez',
                'asshole',
                'assholes',
                'assholz',
                'asswipe',
                'azzhole',
                'bassterds',
                'bastard',
                'bastards',
                'bastardz',
                'basterds',
                'basterdz',
                'Biatch',
                'bitch',
                'bitches',
                'Blow Job',
                'boffing',
                'butthole',
                'buttwipe',
                'c0ck',
                'c0cks',
                'c0k',
                'Carpet Muncher',
                'cawk',
                'cawks',
                'Clit',
                'cnts',
                'cntz',
                'cock',
                'cockhead',
                'cock-head',
                'cocks',
                'CockSucker',
                'cock-sucker',
                'crap',
                'cum',
                'cunt',
                'cunts',
                'cuntz',
                'dick',
                'dild0',
                'dild0s',
                'dildo',
                'dildos',
                'dilld0',
                'dilld0s',
                'dominatricks',
                'dominatrics',
                'dominatrix',
                'dyke',
                'enema',
                'f u c k',
                'f u c k e r',
                'fag',
                'fag1t',
                'faget',
                'fagg1t',
                'faggit',
                'faggot',
                'fagg0t',
                'fagit',
                'fags',
                'fagz',
                'faig',
                'faigs',
                'fart',
                'flipping the bird',
                'fuck',
                'fucker',
                'fuckin',
                'fucking',
                'fucks',
                'Fudge Packer',
                'fuk',
                'Fukah',
                'Fuken',
                'fuker',
                'Fukin',
                'Fukk',
                'Fukkah',
                'Fukken',
                'Fukker',
                'Fukkin',
                'g00k',
                'God-damned',
                'h00r',
                'h0ar',
                'h0re',
                'hells',
                'hoar',
                'hoor',
                'hoore',
                'jackoff',
                'jap',
                'japs',
                'jerk-off',
                'jisim',
                'jiss',
                'jizm',
                'jizz',
                'knob',
                'knobs',
                'knobz',
                'kunt',
                'kunts',
                'kuntz',
                'Lezzian',
                'Lipshits',
                'Lipshitz',
                'masochist',
                'masokist',
                'massterbait',
                'masstrbait',
                'masstrbate',
                'masterbaiter',
                'masterbate',
                'masterbates',
                'Motha Fucker',
                'Motha Fuker',
                'Motha Fukkah',
                'Motha Fukker',
                'Mother Fucker',
                'Mother Fukah',
                'Mother Fuker',
                'Mother Fukkah',
                'Mother Fukker',
                'mother-fucker',
                'Mutha Fucker',
                'Mutha Fukah',
                'Mutha Fuker',
                'Mutha Fukkah',
                'Mutha Fukker',
                'n1gr',
                'nastt',
                'nigger;',
                'nigur;',
                'niiger;',
                'niigr;',
                'orafis',
                'orgasim;',
                'orgasm',
                'orgasum',
                'oriface',
                'orifice',
                'orifiss',
                'packi',
                'packie',
                'packy',
                'paki',
                'pakie',
                'paky',
                'pecker',
                'peeenus',
                'peeenusss',
                'peenus',
                'peinus',
                'pen1s',
                'penas',
                'penis',
                'penis-breath',
                'penus',
                'penuus',
                'Phuc',
                'Phuck',
                'Phuk',
                'Phuker',
                'Phukker',
                'polac',
                'polack',
                'polak',
                'Poonani',
                'pr1c',
                'pr1ck',
                'pr1k',
                'pusse',
                'pussee',
                'pussy',
                'puuke',
                'puuker',
                'queer',
                'queers',
                'queerz',
                'qweers',
                'qweerz',
                'qweir',
                'recktum',
                'rectum',
                'retard',
                'sadist',
                'scank',
                'schlong',
                'screwing',
                'semen',
                'sex',
                'sexy',
                'Sh!t',
                'sh1t',
                'sh1ter',
                'sh1ts',
                'sh1tter',
                'sh1tz',
                'shit',
                'shits',
                'shitter',
                'Shitty',
                'Shity',
                'shitz',
                'Shyt',
                'Shyte',
                'Shytty',
                'Shyty',
                'skanck',
                'skank',
                'skankee',
                'skankey',
                'skanks',
                'Skanky',
                'slag',
                'slut',
                'sluts',
                'Slutty',
                'slutz',
                'son-of-a-bitch',
                'tit',
                'turd',
                'va1jina',
                'vag1na',
                'vagiina',
                'vagina',
                'vaj1na',
                'vajina',
                'vullva',
                'vulva',
                'w0p',
                'wh00r',
                'wh0re',
                'whore',
                'xrated',
                'xxx',
                'b!+ch',
                'bitch',
                'blowjob',
                'clit',
                'arschloch',
                'fuck',
                'shit',
                'ass',
                'asshole',
                'b!tch',
                'b17ch',
                'b1tch',
                'bastard',
                'bi+ch',
                'boiolas',
                'buceta',
                'c0ck',
                'cawk',
                'chink',
                'cipa',
                'clits',
                'cock',
                'cum',
                'cunt',
                'dildo',
                'dirsa',
                'ejakulate',
                'fatass',
                'fcuk',
                'fuk',
                'fux0r',
                'hoer',
                'hore',
                'jism',
                'kawk',
                'l3itch',
                'l3i+ch',
                'lesbian',
                'masturbate',
                'masterbat*',
                'masterbat3',
                'motherfucker',
                's.o.b.',
                'mofo',
                'nazi',
                'nigga',
                'nigger',
                'nutsack',
                'phuck',
                'pimpis',
                'pusse',
                'pussy',
                'scrotum',
                'sh!t',
                'shemale',
                'shi+',
                'sh!+',
                'slut',
                'smut',
                'teets',
                'tits',
                'boobs',
                'b00bs',
                'teez',
                'testical',
                'testicle',
                'titt',
                'w00se',
                'jackoff',
                'wank',
                'whoar',
                'whore',
                '*damn',
                '*dyke',
                '*fuck*',
                '*shit*',
                '@$$',
                'amcik',
                'andskota',
                'arse*',
                'assrammer',
                'ayir',
                'bi7ch',
                'bitch*',
                'bollock*',
                'breasts',
                'butt-pirate',
                'cabron',
                'cazzo',
                'chraa',
                'chuj',
                'Cock*',
                'cunt*',
                'd4mn',
                'daygo',
                'dego',
                'dick*',
                'dike*',
                'dupa',
                'dziwka',
                'ejackulate',
                'Ekrem*',
                'Ekto',
                'enculer',
                'faen',
                'fag*',
                'fanculo',
                'fanny',
                'feces',
                'feg',
                'Felcher',
                'ficken',
                'fitt*',
                'Flikker',
                'foreskin',
                'Fotze',
                'Fu(*',
                'fuk*',
                'futkretzn',
                'gook',
                'guiena',
                'h0r',
                'h4x0r',
                'hell',
                'helvete',
                'hoer*',
                'honkey',
                'Huevon',
                'hui',
                'injun',
                'jizz',
                'kanker*',
                'kike',
                'klootzak',
                'kraut',
                'knulle',
                'kuk',
                'kuksuger',
                'Kurac',
                'kurwa',
                'kusi*',
                'kyrpa*',
                'lesbo',
                'mamhoon',
                'masturbat*',
                'merd*',
                'mibun',
                'monkleigh',
                'mouliewop',
                'muie',
                'mulkku',
                'muschi',
                'nazis',
                'nepesaurio',
                'nigger*',
                'orospu',
                'paska*',
                'perse',
                'picka',
                'pierdol*',
                'pillu*',
                'pimmel',
                'piss*',
                'pizda',
                'poontsee',
                'poop',
                'porn',
                'p0rn',
                'pr0n',
                'preteen',
                'pula',
                'pule',
                'puta',
                'puto',
                'qahbeh',
                'queef*',
                'rautenberg',
                'schaffer',
                'scheiss*',
                'schlampe',
                'schmuck',
                'screw',
                'sh!t*',
                'sharmuta',
                'sharmute',
                'shipal',
                'shiz',
                'skribz',
                'skurwysyn',
                'sphencter',
                'spic',
                'spierdalaj',
                'splooge',
                'suka',
                'b00b*',
                'testicle*',
                'titt*',
                'twat',
                'vittu',
                'wank*',
                'wetback*',
                'wichser',
                'wop*',
                'yed',
                'zabourah'
            ]
        };
    },
    function (module, t, __webpack_require__) {
        /* 15: ./node_modules/badwords-list/lib/object.js */
        module.exports = {
            object: __webpack_require__(16),
            array: __webpack_require__(17),
            regex: __webpack_require__(18)
        };
    },
    function (module, t) {
        /* 16: ./node_modules/badwords-list/lib/array.js */
        module.exports = {
            '4r5e': 1,
            '5h1t': 1,
            '5hit': 1,
            a55: 1,
            anal: 1,
            anus: 1,
            ar5e: 1,
            arrse: 1,
            arse: 1,
            ass: 1,
            'ass-fucker': 1,
            asses: 1,
            assfucker: 1,
            assfukka: 1,
            asshole: 1,
            assholes: 1,
            asswhole: 1,
            a_s_s: 1,
            'b!tch': 1,
            b00bs: 1,
            b17ch: 1,
            b1tch: 1,
            ballbag: 1,
            balls: 1,
            ballsack: 1,
            bastard: 1,
            beastial: 1,
            beastiality: 1,
            bellend: 1,
            bestial: 1,
            bestiality: 1,
            'bi+ch': 1,
            biatch: 1,
            bitch: 1,
            bitcher: 1,
            bitchers: 1,
            bitches: 1,
            bitchin: 1,
            bitching: 1,
            bloody: 1,
            'blow job': 1,
            blowjob: 1,
            blowjobs: 1,
            boiolas: 1,
            bollock: 1,
            bollok: 1,
            boner: 1,
            boob: 1,
            boobs: 1,
            booobs: 1,
            boooobs: 1,
            booooobs: 1,
            booooooobs: 1,
            breasts: 1,
            buceta: 1,
            bugger: 1,
            bum: 1,
            'bunny fucker': 1,
            butt: 1,
            butthole: 1,
            buttmuch: 1,
            buttplug: 1,
            c0ck: 1,
            c0cksucker: 1,
            'carpet muncher': 1,
            cawk: 1,
            chink: 1,
            cipa: 1,
            cl1t: 1,
            clit: 1,
            clitoris: 1,
            clits: 1,
            cnut: 1,
            cock: 1,
            'cock-sucker': 1,
            cockface: 1,
            cockhead: 1,
            cockmunch: 1,
            cockmuncher: 1,
            cocks: 1,
            cocksuck: 1,
            cocksucked: 1,
            cocksucker: 1,
            cocksucking: 1,
            cocksucks: 1,
            cocksuka: 1,
            cocksukka: 1,
            cok: 1,
            cokmuncher: 1,
            coksucka: 1,
            coon: 1,
            cox: 1,
            crap: 1,
            cum: 1,
            cummer: 1,
            cumming: 1,
            cums: 1,
            cumshot: 1,
            cunilingus: 1,
            cunillingus: 1,
            cunnilingus: 1,
            cunt: 1,
            cuntlick: 1,
            cuntlicker: 1,
            cuntlicking: 1,
            cunts: 1,
            cyalis: 1,
            cyberfuc: 1,
            cyberfuck: 1,
            cyberfucked: 1,
            cyberfucker: 1,
            cyberfuckers: 1,
            cyberfucking: 1,
            d1ck: 1,
            damn: 1,
            dick: 1,
            dickhead: 1,
            dildo: 1,
            dildos: 1,
            dink: 1,
            dinks: 1,
            dirsa: 1,
            dlck: 1,
            'dog-fucker': 1,
            doggin: 1,
            dogging: 1,
            donkeyribber: 1,
            doosh: 1,
            duche: 1,
            dyke: 1,
            ejaculate: 1,
            ejaculated: 1,
            ejaculates: 1,
            ejaculating: 1,
            ejaculatings: 1,
            ejaculation: 1,
            ejakulate: 1,
            'f u c k': 1,
            'f u c k e r': 1,
            f4nny: 1,
            fag: 1,
            fagging: 1,
            faggitt: 1,
            faggot: 1,
            faggs: 1,
            fagot: 1,
            fagots: 1,
            fags: 1,
            fanny: 1,
            fannyflaps: 1,
            fannyfucker: 1,
            fanyy: 1,
            fatass: 1,
            fcuk: 1,
            fcuker: 1,
            fcuking: 1,
            feck: 1,
            fecker: 1,
            felching: 1,
            fellate: 1,
            fellatio: 1,
            fingerfuck: 1,
            fingerfucked: 1,
            fingerfucker: 1,
            fingerfuckers: 1,
            fingerfucking: 1,
            fingerfucks: 1,
            fistfuck: 1,
            fistfucked: 1,
            fistfucker: 1,
            fistfuckers: 1,
            fistfucking: 1,
            fistfuckings: 1,
            fistfucks: 1,
            flange: 1,
            fook: 1,
            fooker: 1,
            fuck: 1,
            fucka: 1,
            fucked: 1,
            fucker: 1,
            fuckers: 1,
            fuckhead: 1,
            fuckheads: 1,
            fuckin: 1,
            fucking: 1,
            fuckings: 1,
            fuckingshitmotherfucker: 1,
            fuckme: 1,
            fucks: 1,
            fuckwhit: 1,
            fuckwit: 1,
            'fudge packer': 1,
            fudgepacker: 1,
            fuk: 1,
            fuker: 1,
            fukker: 1,
            fukkin: 1,
            fuks: 1,
            fukwhit: 1,
            fukwit: 1,
            fux: 1,
            fux0r: 1,
            f_u_c_k: 1,
            gangbang: 1,
            gangbanged: 1,
            gangbangs: 1,
            gaylord: 1,
            gaysex: 1,
            goatse: 1,
            God: 1,
            'god-dam': 1,
            'god-damned': 1,
            goddamn: 1,
            goddamned: 1,
            hardcoresex: 1,
            hell: 1,
            heshe: 1,
            hoar: 1,
            hoare: 1,
            hoer: 1,
            homo: 1,
            hore: 1,
            horniest: 1,
            horny: 1,
            hotsex: 1,
            'jack-off': 1,
            jackoff: 1,
            jap: 1,
            'jerk-off': 1,
            jism: 1,
            jiz: 1,
            jizm: 1,
            jizz: 1,
            kawk: 1,
            knob: 1,
            knobead: 1,
            knobed: 1,
            knobend: 1,
            knobhead: 1,
            knobjocky: 1,
            knobjokey: 1,
            kock: 1,
            kondum: 1,
            kondums: 1,
            kum: 1,
            kummer: 1,
            kumming: 1,
            kums: 1,
            kunilingus: 1,
            'l3i+ch': 1,
            l3itch: 1,
            labia: 1,
            lust: 1,
            lusting: 1,
            m0f0: 1,
            m0fo: 1,
            m45terbate: 1,
            ma5terb8: 1,
            ma5terbate: 1,
            masochist: 1,
            'master-bate': 1,
            masterb8: 1,
            'masterbat*': 1,
            masterbat3: 1,
            masterbate: 1,
            masterbation: 1,
            masterbations: 1,
            masturbate: 1,
            'mo-fo': 1,
            mof0: 1,
            mofo: 1,
            mothafuck: 1,
            mothafucka: 1,
            mothafuckas: 1,
            mothafuckaz: 1,
            mothafucked: 1,
            mothafucker: 1,
            mothafuckers: 1,
            mothafuckin: 1,
            mothafucking: 1,
            mothafuckings: 1,
            mothafucks: 1,
            'mother fucker': 1,
            motherfuck: 1,
            motherfucked: 1,
            motherfucker: 1,
            motherfuckers: 1,
            motherfuckin: 1,
            motherfucking: 1,
            motherfuckings: 1,
            motherfuckka: 1,
            motherfucks: 1,
            muff: 1,
            mutha: 1,
            muthafecker: 1,
            muthafuckker: 1,
            muther: 1,
            mutherfucker: 1,
            n1gga: 1,
            n1gger: 1,
            nazi: 1,
            nigg3r: 1,
            nigg4h: 1,
            nigga: 1,
            niggah: 1,
            niggas: 1,
            niggaz: 1,
            nigger: 1,
            niggers: 1,
            nob: 1,
            'nob jokey': 1,
            nobhead: 1,
            nobjocky: 1,
            nobjokey: 1,
            numbnuts: 1,
            nutsack: 1,
            orgasim: 1,
            orgasims: 1,
            orgasm: 1,
            orgasms: 1,
            p0rn: 1,
            pawn: 1,
            pecker: 1,
            penis: 1,
            penisfucker: 1,
            phonesex: 1,
            phuck: 1,
            phuk: 1,
            phuked: 1,
            phuking: 1,
            phukked: 1,
            phukking: 1,
            phuks: 1,
            phuq: 1,
            pigfucker: 1,
            pimpis: 1,
            piss: 1,
            pissed: 1,
            pisser: 1,
            pissers: 1,
            pisses: 1,
            pissflaps: 1,
            pissin: 1,
            pissing: 1,
            pissoff: 1,
            poop: 1,
            porn: 1,
            porno: 1,
            pornography: 1,
            pornos: 1,
            prick: 1,
            pricks: 1,
            pron: 1,
            pube: 1,
            pusse: 1,
            pussi: 1,
            pussies: 1,
            pussy: 1,
            pussys: 1,
            rectum: 1,
            retard: 1,
            rimjaw: 1,
            rimming: 1,
            's hit': 1,
            's.o.b.': 1,
            sadist: 1,
            schlong: 1,
            screwing: 1,
            scroat: 1,
            scrote: 1,
            scrotum: 1,
            semen: 1,
            sex: 1,
            'sh!+': 1,
            'sh!t': 1,
            sh1t: 1,
            shag: 1,
            shagger: 1,
            shaggin: 1,
            shagging: 1,
            shemale: 1,
            'shi+': 1,
            shit: 1,
            shitdick: 1,
            shite: 1,
            shited: 1,
            shitey: 1,
            shitfuck: 1,
            shitfull: 1,
            shithead: 1,
            shiting: 1,
            shitings: 1,
            shits: 1,
            shitted: 1,
            shitter: 1,
            shitters: 1,
            shitting: 1,
            shittings: 1,
            shitty: 1,
            skank: 1,
            slut: 1,
            sluts: 1,
            smegma: 1,
            smut: 1,
            snatch: 1,
            'son-of-a-bitch': 1,
            spac: 1,
            spunk: 1,
            s_h_i_t: 1,
            t1tt1e5: 1,
            t1tties: 1,
            teets: 1,
            teez: 1,
            testical: 1,
            testicle: 1,
            tit: 1,
            titfuck: 1,
            tits: 1,
            titt: 1,
            tittie5: 1,
            tittiefucker: 1,
            titties: 1,
            tittyfuck: 1,
            tittywank: 1,
            titwank: 1,
            tosser: 1,
            turd: 1,
            tw4t: 1,
            twat: 1,
            twathead: 1,
            twatty: 1,
            twunt: 1,
            twunter: 1,
            v14gra: 1,
            v1gra: 1,
            vagina: 1,
            viagra: 1,
            vulva: 1,
            w00se: 1,
            wang: 1,
            wank: 1,
            wanker: 1,
            wanky: 1,
            whoar: 1,
            whore: 1,
            willies: 1,
            willy: 1,
            xrated: 1,
            xxx: 1
        };
    },
    function (module, t) {
        /* 17: ./node_modules/badwords-list/lib/regexp.js */
        module.exports = [
            '4r5e',
            '5h1t',
            '5hit',
            'a55',
            'anal',
            'anus',
            'ar5e',
            'arrse',
            'arse',
            'ass',
            'ass-fucker',
            'asses',
            'assfucker',
            'assfukka',
            'asshole',
            'assholes',
            'asswhole',
            'a_s_s',
            'b!tch',
            'b00bs',
            'b17ch',
            'b1tch',
            'ballbag',
            'balls',
            'ballsack',
            'bastard',
            'beastial',
            'beastiality',
            'bellend',
            'bestial',
            'bestiality',
            'bi+ch',
            'biatch',
            'bitch',
            'bitcher',
            'bitchers',
            'bitches',
            'bitchin',
            'bitching',
            'bloody',
            'blow job',
            'blowjob',
            'blowjobs',
            'boiolas',
            'bollock',
            'bollok',
            'boner',
            'boob',
            'boobs',
            'booobs',
            'boooobs',
            'booooobs',
            'booooooobs',
            'breasts',
            'buceta',
            'bugger',
            'bum',
            'bunny fucker',
            'butt',
            'butthole',
            'buttmuch',
            'buttplug',
            'c0ck',
            'c0cksucker',
            'carpet muncher',
            'cawk',
            'chink',
            'cipa',
            'cl1t',
            'clit',
            'clitoris',
            'clits',
            'cnut',
            'cock',
            'cock-sucker',
            'cockface',
            'cockhead',
            'cockmunch',
            'cockmuncher',
            'cocks',
            'cocksuck',
            'cocksucked',
            'cocksucker',
            'cocksucking',
            'cocksucks',
            'cocksuka',
            'cocksukka',
            'cok',
            'cokmuncher',
            'coksucka',
            'coon',
            'cox',
            'crap',
            'cum',
            'cummer',
            'cumming',
            'cums',
            'cumshot',
            'cunilingus',
            'cunillingus',
            'cunnilingus',
            'cunt',
            'cuntlick',
            'cuntlicker',
            'cuntlicking',
            'cunts',
            'cyalis',
            'cyberfuc',
            'cyberfuck',
            'cyberfucked',
            'cyberfucker',
            'cyberfuckers',
            'cyberfucking',
            'd1ck',
            'damn',
            'dick',
            'dickhead',
            'dildo',
            'dildos',
            'dink',
            'dinks',
            'dirsa',
            'dlck',
            'dog-fucker',
            'doggin',
            'dogging',
            'donkeyribber',
            'doosh',
            'duche',
            'dyke',
            'ejaculate',
            'ejaculated',
            'ejaculates',
            'ejaculating',
            'ejaculatings',
            'ejaculation',
            'ejakulate',
            'f u c k',
            'f u c k e r',
            'f4nny',
            'fag',
            'fagging',
            'faggitt',
            'faggot',
            'faggs',
            'fagot',
            'fagots',
            'fags',
            'fanny',
            'fannyflaps',
            'fannyfucker',
            'fanyy',
            'fatass',
            'fcuk',
            'fcuker',
            'fcuking',
            'feck',
            'fecker',
            'felching',
            'fellate',
            'fellatio',
            'fingerfuck',
            'fingerfucked',
            'fingerfucker',
            'fingerfuckers',
            'fingerfucking',
            'fingerfucks',
            'fistfuck',
            'fistfucked',
            'fistfucker',
            'fistfuckers',
            'fistfucking',
            'fistfuckings',
            'fistfucks',
            'flange',
            'fook',
            'fooker',
            'fuck',
            'fucka',
            'fucked',
            'fucker',
            'fuckers',
            'fuckhead',
            'fuckheads',
            'fuckin',
            'fucking',
            'fuckings',
            'fuckingshitmotherfucker',
            'fuckme',
            'fucks',
            'fuckwhit',
            'fuckwit',
            'fudge packer',
            'fudgepacker',
            'fuk',
            'fuker',
            'fukker',
            'fukkin',
            'fuks',
            'fukwhit',
            'fukwit',
            'fux',
            'fux0r',
            'f_u_c_k',
            'gangbang',
            'gangbanged',
            'gangbangs',
            'gaylord',
            'gaysex',
            'goatse',
            'God',
            'god-dam',
            'god-damned',
            'goddamn',
            'goddamned',
            'hardcoresex',
            'hell',
            'heshe',
            'hoar',
            'hoare',
            'hoer',
            'homo',
            'hore',
            'horniest',
            'horny',
            'hotsex',
            'jack-off',
            'jackoff',
            'jap',
            'jerk-off',
            'jism',
            'jiz',
            'jizm',
            'jizz',
            'kawk',
            'knob',
            'knobead',
            'knobed',
            'knobend',
            'knobhead',
            'knobjocky',
            'knobjokey',
            'kock',
            'kondum',
            'kondums',
            'kum',
            'kummer',
            'kumming',
            'kums',
            'kunilingus',
            'l3i+ch',
            'l3itch',
            'labia',
            'lust',
            'lusting',
            'm0f0',
            'm0fo',
            'm45terbate',
            'ma5terb8',
            'ma5terbate',
            'masochist',
            'master-bate',
            'masterb8',
            'masterbat*',
            'masterbat3',
            'masterbate',
            'masterbation',
            'masterbations',
            'masturbate',
            'mo-fo',
            'mof0',
            'mofo',
            'mothafuck',
            'mothafucka',
            'mothafuckas',
            'mothafuckaz',
            'mothafucked',
            'mothafucker',
            'mothafuckers',
            'mothafuckin',
            'mothafucking',
            'mothafuckings',
            'mothafucks',
            'mother fucker',
            'motherfuck',
            'motherfucked',
            'motherfucker',
            'motherfuckers',
            'motherfuckin',
            'motherfucking',
            'motherfuckings',
            'motherfuckka',
            'motherfucks',
            'muff',
            'mutha',
            'muthafecker',
            'muthafuckker',
            'muther',
            'mutherfucker',
            'n1gga',
            'n1gger',
            'nazi',
            'nigg3r',
            'nigg4h',
            'nigga',
            'niggah',
            'niggas',
            'niggaz',
            'nigger',
            'niggers',
            'nob',
            'nob jokey',
            'nobhead',
            'nobjocky',
            'nobjokey',
            'numbnuts',
            'nutsack',
            'orgasim',
            'orgasims',
            'orgasm',
            'orgasms',
            'p0rn',
            'pawn',
            'pecker',
            'penis',
            'penisfucker',
            'phonesex',
            'phuck',
            'phuk',
            'phuked',
            'phuking',
            'phukked',
            'phukking',
            'phuks',
            'phuq',
            'pigfucker',
            'pimpis',
            'piss',
            'pissed',
            'pisser',
            'pissers',
            'pisses',
            'pissflaps',
            'pissin',
            'pissing',
            'pissoff',
            'poop',
            'porn',
            'porno',
            'pornography',
            'pornos',
            'prick',
            'pricks',
            'pron',
            'pube',
            'pusse',
            'pussi',
            'pussies',
            'pussy',
            'pussys',
            'rectum',
            'retard',
            'rimjaw',
            'rimming',
            's hit',
            's.o.b.',
            'sadist',
            'schlong',
            'screwing',
            'scroat',
            'scrote',
            'scrotum',
            'semen',
            'sex',
            'sh!+',
            'sh!t',
            'sh1t',
            'shag',
            'shagger',
            'shaggin',
            'shagging',
            'shemale',
            'shi+',
            'shit',
            'shitdick',
            'shite',
            'shited',
            'shitey',
            'shitfuck',
            'shitfull',
            'shithead',
            'shiting',
            'shitings',
            'shits',
            'shitted',
            'shitter',
            'shitters',
            'shitting',
            'shittings',
            'shitty',
            'skank',
            'slut',
            'sluts',
            'smegma',
            'smut',
            'snatch',
            'son-of-a-bitch',
            'spac',
            'spunk',
            's_h_i_t',
            't1tt1e5',
            't1tties',
            'teets',
            'teez',
            'testical',
            'testicle',
            'tit',
            'titfuck',
            'tits',
            'titt',
            'tittie5',
            'tittiefucker',
            'titties',
            'tittyfuck',
            'tittywank',
            'titwank',
            'tosser',
            'turd',
            'tw4t',
            'twat',
            'twathead',
            'twatty',
            'twunt',
            'twunter',
            'v14gra',
            'v1gra',
            'vagina',
            'viagra',
            'vulva',
            'w00se',
            'wang',
            'wank',
            'wanker',
            'wanky',
            'whoar',
            'whore',
            'willies',
            'willy',
            'xrated',
            'xxx'
        ];
    },
    function (module, t) {
        /* 18: ./src/js/data/store.js */
        module.exports = /\b(4r5e|5h1t|5hit|a55|anal|anus|ar5e|arrse|arse|ass|ass-fucker|asses|assfucker|assfukka|asshole|assholes|asswhole|a_s_s|b!tch|b00bs|b17ch|b1tch|ballbag|balls|ballsack|bastard|beastial|beastiality|bellend|bestial|bestiality|bi\+ch|biatch|bitch|bitcher|bitchers|bitches|bitchin|bitching|bloody|blow job|blowjob|blowjobs|boiolas|bollock|bollok|boner|boob|boobs|booobs|boooobs|booooobs|booooooobs|breasts|buceta|bugger|bum|bunny fucker|butt|butthole|buttmuch|buttplug|c0ck|c0cksucker|carpet muncher|cawk|chink|cipa|cl1t|clit|clitoris|clits|cnut|cock|cock-sucker|cockface|cockhead|cockmunch|cockmuncher|cocks|cocksuck|cocksucked|cocksucker|cocksucking|cocksucks|cocksuka|cocksukka|cok|cokmuncher|coksucka|coon|cox|crap|cum|cummer|cumming|cums|cumshot|cunilingus|cunillingus|cunnilingus|cunt|cuntlick|cuntlicker|cuntlicking|cunts|cyalis|cyberfuc|cyberfuck|cyberfucked|cyberfucker|cyberfuckers|cyberfucking|d1ck|damn|dick|dickhead|dildo|dildos|dink|dinks|dirsa|dlck|dog-fucker|doggin|dogging|donkeyribber|doosh|duche|dyke|ejaculate|ejaculated|ejaculates|ejaculating|ejaculatings|ejaculation|ejakulate|f u c k|f u c k e r|f4nny|fag|fagging|faggitt|faggot|faggs|fagot|fagots|fags|fanny|fannyflaps|fannyfucker|fanyy|fatass|fcuk|fcuker|fcuking|feck|fecker|felching|fellate|fellatio|fingerfuck|fingerfucked|fingerfucker|fingerfuckers|fingerfucking|fingerfucks|fistfuck|fistfucked|fistfucker|fistfuckers|fistfucking|fistfuckings|fistfucks|flange|fook|fooker|fuck|fucka|fucked|fucker|fuckers|fuckhead|fuckheads|fuckin|fucking|fuckings|fuckingshitmotherfucker|fuckme|fucks|fuckwhit|fuckwit|fudge packer|fudgepacker|fuk|fuker|fukker|fukkin|fuks|fukwhit|fukwit|fux|fux0r|f_u_c_k|gangbang|gangbanged|gangbangs|gaylord|gaysex|goatse|God|god-dam|god-damned|goddamn|goddamned|hardcoresex|hell|heshe|hoar|hoare|hoer|homo|hore|horniest|horny|hotsex|jack-off|jackoff|jap|jerk-off|jism|jiz|jizm|jizz|kawk|knob|knobead|knobed|knobend|knobhead|knobjocky|knobjokey|kock|kondum|kondums|kum|kummer|kumming|kums|kunilingus|l3i\+ch|l3itch|labia|lust|lusting|m0f0|m0fo|m45terbate|ma5terb8|ma5terbate|masochist|master-bate|masterb8|masterbat*|masterbat3|masterbate|masterbation|masterbations|masturbate|mo-fo|mof0|mofo|mothafuck|mothafucka|mothafuckas|mothafuckaz|mothafucked|mothafucker|mothafuckers|mothafuckin|mothafucking|mothafuckings|mothafucks|mother fucker|motherfuck|motherfucked|motherfucker|motherfuckers|motherfuckin|motherfucking|motherfuckings|motherfuckka|motherfucks|muff|mutha|muthafecker|muthafuckker|muther|mutherfucker|n1gga|n1gger|nazi|nigg3r|nigg4h|nigga|niggah|niggas|niggaz|nigger|niggers|nob|nob jokey|nobhead|nobjocky|nobjokey|numbnuts|nutsack|orgasim|orgasims|orgasm|orgasms|p0rn|pawn|pecker|penis|penisfucker|phonesex|phuck|phuk|phuked|phuking|phukked|phukking|phuks|phuq|pigfucker|pimpis|piss|pissed|pisser|pissers|pisses|pissflaps|pissin|pissing|pissoff|poop|porn|porno|pornography|pornos|prick|pricks|pron|pube|pusse|pussi|pussies|pussy|pussys|rectum|retard|rimjaw|rimming|s hit|s.o.b.|sadist|schlong|screwing|scroat|scrote|scrotum|semen|sex|sh!\+|sh!t|sh1t|shag|shagger|shaggin|shagging|shemale|shi\+|shit|shitdick|shite|shited|shitey|shitfuck|shitfull|shithead|shiting|shitings|shits|shitted|shitter|shitters|shitting|shittings|shitty|skank|slut|sluts|smegma|smut|snatch|son-of-a-bitch|spac|spunk|s_h_i_t|t1tt1e5|t1tties|teets|teez|testical|testicle|tit|titfuck|tits|titt|tittie5|tittiefucker|titties|tittyfuck|tittywank|titwank|tosser|turd|tw4t|twat|twathead|twatty|twunt|twunter|v14gra|v1gra|vagina|viagra|vulva|w00se|wang|wank|wanker|wanky|whoar|whore|willies|willy|xrated|xxx)\b/gi;
    },
    function (module, t) {
        /* 19: ./src/js/data/projectile.js */
        module.exports.hats = [
            {
                id: 45,
                name: 'Shame!',
                dontSell: !0,
                price: 0,
                scale: 120,
                desc: 'hacks are for losers'
            },
            {
                id: 51,
                name: 'Moo Cap',
                price: 0,
                scale: 120,
                desc: 'coolest mooer around'
            },
            {
                id: 50,
                name: 'Apple Cap',
                price: 0,
                scale: 120,
                desc: 'apple farms remembers'
            },
            {
                id: 28,
                name: 'Moo Head',
                price: 0,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 29,
                name: 'Pig Head',
                price: 0,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 30,
                name: 'Fluff Head',
                price: 0,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 36,
                name: 'Pandou Head',
                price: 0,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 37,
                name: 'Bear Head',
                price: 0,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 38,
                name: 'Monkey Head',
                price: 0,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 44,
                name: 'Polar Head',
                price: 0,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 35,
                name: 'Fez Hat',
                price: 0,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 42,
                name: 'Enigma Hat',
                price: 0,
                scale: 120,
                desc: 'join the enigma army'
            },
            {
                id: 43,
                name: 'Blitz Hat',
                price: 0,
                scale: 120,
                desc: 'hey everybody i\'m blitz'
            },
            {
                id: 49,
                name: 'Bob XIII Hat',
                price: 0,
                scale: 120,
                desc: 'like and subscribe'
            },
            {
                id: 57,
                name: 'Pumpkin',
                price: 50,
                scale: 120,
                desc: 'Spooooky'
            },
            {
                id: 8,
                name: 'Bummle Hat',
                price: 100,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 2,
                name: 'Straw Hat',
                price: 500,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 15,
                name: 'Winter Cap',
                price: 600,
                scale: 120,
                desc: 'allows you to move at normal speed in snow',
                coldM: 1
            },
            {
                id: 5,
                name: 'Cowboy Hat',
                price: 1000,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 4,
                name: 'Ranger Hat',
                price: 2000,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 18,
                name: 'Explorer Hat',
                price: 2000,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 31,
                name: 'Flipper Hat',
                price: 2500,
                scale: 120,
                desc: 'have more control while in water',
                watrImm: !0
            },
            {
                id: 1,
                name: 'Marksman Cap',
                price: 3000,
                scale: 120,
                desc: 'increases arrow speed and range',
                aMlt: 1.3
            },
            {
                id: 10,
                name: 'Bush Gear',
                price: 3000,
                scale: 160,
                desc: 'allows you to disguise yourself as a bush'
            },
            {
                id: 48,
                name: 'Halo',
                price: 3000,
                scale: 120,
                desc: 'no effect'
            },
            {
                id: 6,
                name: 'Soldier Helmet',
                price: 4000,
                scale: 120,
                desc: 'reduces damage taken but slows movement',
                spdMult: 0.94,
                dmgMult: 0.75
            },
            {
                id: 23,
                name: 'Anti Venom Gear',
                price: 4000,
                scale: 120,
                desc: 'makes you immune to poison',
                poisonRes: 1
            },
            {
                id: 13,
                name: 'Medic Gear',
                price: 5000,
                scale: 110,
                desc: 'slowly regenerates health over time',
                healthRegen: 3
            },
            {
                id: 9,
                name: 'Miners Helmet',
                price: 5000,
                scale: 120,
                desc: 'earn 1 extra gold per resource',
                extraGold: 1
            },
            {
                id: 32,
                name: 'Musketeer Hat',
                price: 5000,
                scale: 120,
                desc: 'reduces cost of projectiles',
                projCost: 0.5
            },
            {
                id: 7,
                name: 'Bull Helmet',
                price: 6000,
                scale: 120,
                desc: 'increases damage done but drains health',
                healthRegen: -5,
                dmgMultO: 1.5,
                spdMult: 0.96
            },
            {
                id: 22,
                name: 'Emp Helmet',
                price: 6000,
                scale: 120,
                desc: 'turrets won\'t attack but you move slower',
                antiTurret: 1,
                spdMult: 0.7
            },
            {
                id: 12,
                name: 'Booster Hat',
                price: 6000,
                scale: 120,
                desc: 'increases your movement speed',
                spdMult: 1.16
            },
            {
                id: 26,
                name: 'Barbarian Armor',
                price: 8000,
                scale: 120,
                desc: 'knocks back enemies that attack you',
                dmgK: 0.6
            },
            {
                id: 21,
                name: 'Plague Mask',
                price: 10000,
                scale: 120,
                desc: 'melee attacks deal poison damage',
                poisonDmg: 5,
                poisonTime: 6
            },
            {
                id: 46,
                name: 'Bull Mask',
                price: 10000,
                scale: 120,
                desc: 'bulls won\'t target you unless you attack them',
                bullRepel: 1
            },
            {
                id: 14,
                name: 'Windmill Hat',
                topSprite: !0,
                price: 10000,
                scale: 120,
                desc: 'generates points while worn',
                pps: 1.5
            },
            {
                id: 11,
                name: 'Spike Gear',
                topSprite: !0,
                price: 10000,
                scale: 120,
                desc: 'deal damage to players that damage you',
                dmg: 0.45
            },
            {
                id: 53,
                name: 'Turret Gear',
                topSprite: !0,
                price: 10000,
                scale: 120,
                desc: 'you become a walking turret',
                turret: {
                    proj: 1,
                    range: 700,
                    rate: 2500
                },
                spdMult: 0.7
            },
            {
                id: 20,
                name: 'Samurai Armor',
                price: 12000,
                scale: 120,
                desc: 'increased attack speed and fire rate',
                atkSpd: 0.78
            },
            {
                id: 58,
                name: 'Dark Knight',
                price: 12000,
                scale: 120,
                desc: 'restores health when you deal damage',
                healD: 0.4
            },
            {
                id: 27,
                name: 'Scavenger Gear',
                price: 15000,
                scale: 120,
                desc: 'earn double points for each kill',
                kScrM: 2
            },
            {
                id: 40,
                name: 'Tank Gear',
                price: 15000,
                scale: 120,
                desc: 'increased damage to buildings but slower movement',
                spdMult: 0.3,
                bDmg: 3.3
            },
            {
                id: 52,
                name: 'Thief Gear',
                price: 15000,
                scale: 120,
                desc: 'steal half of a players gold when you kill them',
                goldSteal: 0.5
            },
            {
                id: 55,
                name: 'Bloodthirster',
                price: 20000,
                scale: 120,
                desc: 'Restore Health when dealing damage. And increased damage',
                healD: 0.25,
                dmgMultO: 1.2
            },
            {
                id: 56,
                name: 'Assassin Gear',
                price: 20000,
                scale: 120,
                desc: 'Go invisible when not moving. Can\'t eat. Increased speed',
                noEat: !0,
                spdMult: 1.1,
                invisTimer: 1000
            }
        ], module.exports.accessories = [
            {
                id: 12,
                name: 'Snowball',
                price: 1000,
                scale: 105,
                xOff: 18,
                desc: 'no effect'
            },
            {
                id: 9,
                name: 'Tree Cape',
                price: 1000,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 10,
                name: 'Stone Cape',
                price: 1000,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 3,
                name: 'Cookie Cape',
                price: 1500,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 8,
                name: 'Cow Cape',
                price: 2000,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 11,
                name: 'Monkey Tail',
                price: 2000,
                scale: 97,
                xOff: 25,
                desc: 'Super speed but reduced damage',
                spdMult: 1.35,
                dmgMultO: 0.2
            },
            {
                id: 17,
                name: 'Apple Basket',
                price: 3000,
                scale: 80,
                xOff: 12,
                desc: 'slowly regenerates health over time',
                healthRegen: 1
            },
            {
                id: 6,
                name: 'Winter Cape',
                price: 3000,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 4,
                name: 'Skull Cape',
                price: 4000,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 5,
                name: 'Dash Cape',
                price: 5000,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 2,
                name: 'Dragon Cape',
                price: 6000,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 1,
                name: 'Super Cape',
                price: 8000,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 7,
                name: 'Troll Cape',
                price: 8000,
                scale: 90,
                desc: 'no effect'
            },
            {
                id: 14,
                name: 'Thorns',
                price: 10000,
                scale: 115,
                xOff: 20,
                desc: 'no effect'
            },
            {
                id: 15,
                name: 'Blockades',
                price: 10000,
                scale: 95,
                xOff: 15,
                desc: 'no effect'
            },
            {
                id: 20,
                name: 'Devils Tail',
                price: 10000,
                scale: 95,
                xOff: 20,
                desc: 'no effect'
            },
            {
                id: 16,
                name: 'Sawblade',
                price: 12000,
                scale: 90,
                spin: !0,
                xOff: 0,
                desc: 'deal damage to players that damage you',
                dmg: 0.15
            },
            {
                id: 13,
                name: 'Angel Wings',
                price: 15000,
                scale: 138,
                xOff: 22,
                desc: 'slowly regenerates health over time',
                healthRegen: 3
            },
            {
                id: 19,
                name: 'Shadow Wings',
                price: 15000,
                scale: 138,
                xOff: 22,
                desc: 'increased movement speed',
                spdMult: 1.1
            },
            {
                id: 18,
                name: 'Blood Wings',
                price: 20000,
                scale: 178,
                xOff: 26,
                desc: 'restores health when you deal damage',
                healD: 0.2
            },
            {
                id: 21,
                name: 'Corrupt X Wings',
                price: 20000,
                scale: 178,
                xOff: 26,
                desc: 'deal damage to players that damage you',
                dmg: 0.25
            }
        ];
    },
    function (module, t) {
        /* 20: ./src/js/data/projectileManager.js */
        module.exports = function (players, ais, objectManager, items, config, UTILS, server) {
            this.init = function (indx, x, y, dir, spd, dmg, rng, scl, owner) {
                this.active = !0, this.indx = indx, this.x = x, this.y = y, this.dir = dir, this.skipMov = !0, this.speed = spd, this.dmg = dmg, this.scale = scl, this.range = rng, this.owner = owner, server && (this.sentTo = {});
            };
            var tmpObj, objectsHit = [];
            this.update = function (delta) {
                if (this.active) {
                    var tmpScale, tmpSpeed = this.speed * delta;
                    if (this.skipMov ? this.skipMov = !1 : (this.x += tmpSpeed * Math.cos(this.dir), this.y += tmpSpeed * Math.sin(this.dir), this.range -= tmpSpeed, this.range <= 0 && (this.x += this.range * Math.cos(this.dir), this.y += this.range * Math.sin(this.dir), tmpSpeed = 1, this.range = 0, this.active = !1)), server) {
                        for (var i = 0; i < players.length; ++i)
                            !this.sentTo[players[i].id] && players[i].canSee(this) && (this.sentTo[players[i].id] = 1, server.send(players[i].id, '18', UTILS.fixTo(this.x, 1), UTILS.fixTo(this.y, 1), UTILS.fixTo(this.dir, 2), UTILS.fixTo(this.range, 1), this.speed, this.indx, this.layer, this.sid));
                        for (objectsHit.length = 0, i = 0; i < players.length + ais.length; ++i)
                            !(tmpObj = players[i] || ais[i - players.length]).alive || tmpObj == this.owner || this.owner.team && tmpObj.team == this.owner.team || UTILS.lineInRect(tmpObj.x - tmpObj.scale, tmpObj.y - tmpObj.scale, tmpObj.x + tmpObj.scale, tmpObj.y + tmpObj.scale, this.x, this.y, this.x + tmpSpeed * Math.cos(this.dir), this.y + tmpSpeed * Math.sin(this.dir)) && objectsHit.push(tmpObj);
                        for (var tmpList = objectManager.getGridArrays(this.x, this.y, this.scale), x = 0; x < tmpList.length; ++x)
                            for (var y = 0; y < tmpList[x].length; ++y)
                                tmpScale = (tmpObj = tmpList[x][y]).getScale(), tmpObj.active && this.ignoreObj != tmpObj.sid && this.layer <= tmpObj.layer && objectsHit.indexOf(tmpObj) < 0 && !tmpObj.ignoreCollision && UTILS.lineInRect(tmpObj.x - tmpScale, tmpObj.y - tmpScale, tmpObj.x + tmpScale, tmpObj.y + tmpScale, this.x, this.y, this.x + tmpSpeed * Math.cos(this.dir), this.y + tmpSpeed * Math.sin(this.dir)) && objectsHit.push(tmpObj);
                        if (objectsHit.length > 0) {
                            var hitObj = null, shortDist = null, tmpDist = null;
                            for (i = 0; i < objectsHit.length; ++i)
                                tmpDist = UTILS.getDistance(this.x, this.y, objectsHit[i].x, objectsHit[i].y), (null == shortDist || tmpDist < shortDist) && (shortDist = tmpDist, hitObj = objectsHit[i]);
                            if (hitObj.isPlayer || hitObj.isAI) {
                                var tmpSd = 0.3 * (hitObj.weightM || 1);
                                hitObj.xVel += tmpSd * Math.cos(this.dir), hitObj.yVel += tmpSd * Math.sin(this.dir), null != hitObj.weaponIndex && items.weapons[hitObj.weaponIndex].shield && UTILS.getAngleDist(this.dir + Math.PI, hitObj.dir) <= config.shieldAngle || hitObj.changeHealth(-this.dmg, this.owner, this.owner);
                            } else
                                for (hitObj.projDmg && hitObj.health && hitObj.changeHealth(-this.dmg) && objectManager.disableObj(hitObj), i = 0; i < players.length; ++i)
                                    players[i].active && (hitObj.sentTo[players[i].id] && (hitObj.active ? players[i].canSee(hitObj) && server.send(players[i].id, '8', UTILS.fixTo(this.dir, 2), hitObj.sid) : server.send(players[i].id, '12', hitObj.sid)), hitObj.active || hitObj.owner != players[i] || players[i].changeItemCount(hitObj.group.id, -1));
                            for (this.active = !1, i = 0; i < players.length; ++i)
                                this.sentTo[players[i].id] && server.send(players[i].id, '19', this.sid, UTILS.fixTo(shortDist, 1));
                        }
                    }
                }
            };
        };
    },
    function (module, t) {
        /* 21: ./src/js/libs/soundManager.js */
        module.exports = function (Projectile, projectiles, players, ais, objectManager, items, config, UTILS, server) {
            this.addProjectile = function (x, y, dir, range, speed, indx, owner, ignoreObj, layer) {
                for (var tmpProj, tmpData = items.projectiles[indx], i = 0; i < projectiles.length; ++i)
                    if (!projectiles[i].active) {
                        tmpProj = projectiles[i];
                        break;
                    }
                return tmpProj || ((tmpProj = new Projectile(players, ais, objectManager, items, config, UTILS, server)).sid = projectiles.length, projectiles.push(tmpProj)), tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner), tmpProj.ignoreObj = ignoreObj, tmpProj.layer = layer || tmpData.layer, tmpProj.src = tmpData.src, tmpProj;
            };
        };
    },
    function (module, t) {
        /* 22: ./vultr/VultrClient.js */
        module.exports.obj = function (config, UTILS) {
            var tmpSound;
            this.sounds = [], this.active = !0, this.play = function (id, volume, loop) {
                volume && this.active && ((tmpSound = this.sounds[id]) || (tmpSound = new Howl({ src: '.././sound/' + id + '.mp3' }), this.sounds[id] = tmpSound), loop && tmpSound.isPlaying || (tmpSound.isPlaying = !0, tmpSound.play(), tmpSound.volume((volume || 1) * config.volumeMult), tmpSound.loop(loop)));
            }, this.toggleMute = function (id, mute) {
                (tmpSound = this.sounds[id]) && tmpSound.mute(mute);
            }, this.stop = function (id) {
                (tmpSound = this.sounds[id]) && (tmpSound.stop(), tmpSound.isPlaying = !1);
            };
        };
    },
    function (module, t, __webpack_require__) {
        /* 23: ./node_modules/url/url.js */
        var url = __webpack_require__(24), md5 = __webpack_require__(32);
        function VultrClient(baseUrl, devPort, lobbySize, lobbySpread, rawIPs) {
            'localhost' == location.hostname && (window.location.hostname = '127.0.0.1'), this.debugLog = !1, this.baseUrl = baseUrl, this.lobbySize = lobbySize, this.devPort = devPort, this.lobbySpread = lobbySpread, this.rawIPs = !!rawIPs, this.server = void 0, this.gameIndex = void 0, this.callback = void 0, this.errorCallback = void 0, this.processServers(vultr.servers);
        }
        VultrClient.prototype.regionInfo = {
            0: {
                name: 'Local',
                latitude: 0,
                longitude: 0
            },
            'vultr:1': {
                name: 'New Jersey',
                latitude: 40.1393329,
                longitude: -75.8521818
            },
            'vultr:2': {
                name: 'Chicago',
                latitude: 41.8339037,
                longitude: -87.872238
            },
            'vultr:3': {
                name: 'Dallas',
                latitude: 32.8208751,
                longitude: -96.8714229
            },
            'vultr:4': {
                name: 'Seattle',
                latitude: 47.6149942,
                longitude: -122.4759879
            },
            'vultr:5': {
                name: 'Los Angeles',
                latitude: 34.0207504,
                longitude: -118.691914
            },
            'vultr:6': {
                name: 'Atlanta',
                latitude: 33.7676334,
                longitude: -84.5610332
            },
            'vultr:7': {
                name: 'Amsterdam',
                latitude: 52.3745287,
                longitude: 4.7581878
            },
            'vultr:8': {
                name: 'London',
                latitude: 51.5283063,
                longitude: -0.382486
            },
            'vultr:9': {
                name: 'Frankfurt',
                latitude: 50.1211273,
                longitude: 8.496137
            },
            'vultr:12': {
                name: 'Silicon Valley',
                latitude: 37.4024714,
                longitude: -122.3219752
            },
            'vultr:19': {
                name: 'Sydney',
                latitude: -33.8479715,
                longitude: 150.651084
            },
            'vultr:24': {
                name: 'Paris',
                latitude: 48.8588376,
                longitude: 2.2773454
            },
            'vultr:25': {
                name: 'Tokyo',
                latitude: 35.6732615,
                longitude: 139.569959
            },
            'vultr:39': {
                name: 'Miami',
                latitude: 25.7823071,
                longitude: -80.3012156
            },
            'vultr:40': {
                name: 'Singapore',
                latitude: 1.3147268,
                longitude: 103.7065876
            }
        }, VultrClient.prototype.start = function (callback, errorCallback) {
            this.callback = callback, this.errorCallback = errorCallback;
            var query = this.parseServerQuery();
            query ? (this.log('Found server in query.'), this.password = query[3], this.connect(query[0], query[1], query[2])) : (this.log('Pinging servers...'), this.pingServers());
        }, VultrClient.prototype.parseServerQuery = function () {
            var parsed = url.parse(location.href, !0), serverRaw = parsed.query.server;
            if ('string' == typeof serverRaw) {
                var split = serverRaw.split(':');
                if (3 == split.length) {
                    var region = split[0], index = parseInt(split[1]), gameIndex = parseInt(split[2]);
                    return '0' == region || region.startsWith('vultr:') || (region = 'vultr:' + region), [
                        region,
                        index,
                        gameIndex,
                        parsed.query.password
                    ];
                }
                this.errorCallback('Invalid number of server parameters in ' + serverRaw);
            }
        }, VultrClient.prototype.findServer = function (region, index) {
            var serverList = this.servers[region];
            if (Array.isArray(serverList)) {
                for (var i = 0; i < serverList.length; i++) {
                    var server = serverList[i];
                    if (server.index == index)
                        return server;
                }
                console.warn('Could not find server in region ' + region + ' with index ' + index + '.');
            } else
                this.errorCallback('No server list for region ' + region);
        }, VultrClient.prototype.pingServers = function () {
            var _this = this, requests = [];
            for (var region in this.servers)
                if (this.servers.hasOwnProperty(region)) {
                    var serverList = this.servers[region], targetServer = serverList[Math.floor(Math.random() * serverList.length)];
                    null != targetServer ? function (serverList, targetServer) {
                        var request = new XMLHttpRequest();
                        request.onreadystatechange = function (requestEvent) {
                            var request = requestEvent.target;
                            if (4 == request.readyState)
                                if (200 == request.status) {
                                    for (var i = 0; i < requests.length; i++)
                                        requests[i].abort();
                                    _this.log('Connecting to region', targetServer.region);
                                    var targetGame = _this.seekServer(targetServer.region);
                                    _this.connect(targetGame[0], targetGame[1], targetGame[2]);
                                } else
                                    console.warn('Error pinging ' + targetServer.ip + ' in region ' + region);
                        };
                        var targetAddress = '//' + _this.serverAddress(targetServer.ip, !0) + ':' + _this.serverPort(targetServer) + '/ping';
                        request.open('GET', targetAddress, !0), request.send(null), _this.log('Pinging', targetAddress), requests.push(request);
                    }(0, targetServer) : console.log('No target server for region ' + region);
                }
        }, VultrClient.prototype.seekServer = function (region, isPrivate, gameMode) {
            null == gameMode && (gameMode = 'random'), null == isPrivate && (isPrivate = !1);
            const gameModeList = ['random'];
            var lobbySize = this.lobbySize, lobbySpread = this.lobbySpread, servers = this.servers[region].flatMap(function (s) {
                    var gameIndex = 0;
                    return s.games.map(function (g) {
                        var currentGameIndex = gameIndex++;
                        return {
                            region: s.region,
                            index: s.index * s.games.length + currentGameIndex,
                            gameIndex: currentGameIndex,
                            gameCount: s.games.length,
                            playerCount: g.playerCount,
                            isPrivate: g.isPrivate
                        };
                    });
                }).filter(function (s) {
                    return !s.isPrivate;
                }).filter(function (s) {
                    return !isPrivate || 0 == s.playerCount && s.gameIndex >= s.gameCount / 2;
                }).filter(function (s) {
                    return 'random' == gameMode || gameModeList[s.index % gameModeList.length].key == gameMode;
                }).sort(function (a, b) {
                    return b.playerCount - a.playerCount;
                }).filter(function (s) {
                    return s.playerCount < lobbySize;
                });
            if (isPrivate && servers.reverse(), 0 != servers.length) {
                var randomSpread = Math.min(lobbySpread, servers.length), serverIndex = Math.floor(Math.random() * randomSpread), rawServer = servers[serverIndex = Math.min(serverIndex, servers.length - 1)], serverRegion = rawServer.region, gameIndex = (serverIndex = Math.floor(rawServer.index / rawServer.gameCount), rawServer.index % rawServer.gameCount);
                return this.log('Found server.'), [
                    serverRegion,
                    serverIndex,
                    gameIndex
                ];
            }
            this.errorCallback('No open servers.');
        }, VultrClient.prototype.connect = function (region, index, game) {
            if (!this.connected) {
                var server = this.findServer(region, index);
                null != server ? (this.log('Connecting to server', server, 'with game index', game), server.games[game].playerCount >= this.lobbySize ? this.errorCallback('Server is already full.') : (window.history.replaceState(document.title, document.title, this.generateHref(region, index, game, this.password)), this.server = server, this.gameIndex = game, this.log('Calling callback with address', this.serverAddress(server.ip), 'on port', this.serverPort(server), 'with game index', game), this.callback(this.serverAddress(server.ip), this.serverPort(server), game))) : this.errorCallback('Failed to find server for region ' + region + ' and index ' + index);
            }
        }, VultrClient.prototype.switchServer = function (region, index, game, password) {
            this.switchingServers = !0, window.location.href = this.generateHref(region, index, game, password);
        }, VultrClient.prototype.generateHref = function (region, index, game, password) {
            var href = '/?server=' + (region = this.stripRegion(region)) + ':' + index + ':' + game;
            return password && (href += '&password=' + encodeURIComponent(password)), href;
        }, VultrClient.prototype.serverAddress = function (ip, forceSecure) {
            return '127.0.0.1' == ip || '7f000001' == ip || '903d62ef5d1c2fecdcaeb5e7dd485eff' == ip ? window.location.hostname : this.rawIPs ? forceSecure ? 'ip_' + this.hashIP(ip) + '.' + this.baseUrl : ip : 'ip_' + ip + '.' + this.baseUrl;
        }, VultrClient.prototype.serverPort = function (server) {
            return 0 == server.region ? this.devPort : location.protocol.startsWith('https') ? 443 : 80;
        }, VultrClient.prototype.processServers = function (serverList) {
            for (var servers = {}, i = 0; i < serverList.length; i++) {
                var server = serverList[i], list = servers[server.region];
                null == list && (list = [], servers[server.region] = list), list.push(server);
            }
            for (var region in servers)
                servers[region] = servers[region].sort(function (a, b) {
                    return a.index - b.index;
                });
            this.servers = servers;
        }, VultrClient.prototype.ipToHex = function (ip) {
            return ip.split('.').map(component => ('00' + parseInt(component).toString(16)).substr(-2)).join('').toLowerCase();
        }, VultrClient.prototype.hashIP = function (ip) {
            return md5(this.ipToHex(ip));
        }, VultrClient.prototype.log = function () {
            return this.debugLog ? console.log.apply(void 0, arguments) : console.verbose ? console.verbose.apply(void 0, arguments) : void 0;
        }, VultrClient.prototype.stripRegion = function (region) {
            return region.startsWith('vultr:') ? region = region.slice(6) : region.startsWith('do:') && (region = region.slice(3)), region;
        }, window.testVultrClient = function () {
            var assertIndex = 1;
            function assert(actual, expected) {
                (actual = '' + actual) == (expected = '' + expected) ? console.log(`Assert ${ assertIndex } passed.`) : console.warn(`Assert ${ assertIndex } failed. Expected ${ expected }, got ${ actual }.`), assertIndex++;
            }
            var client1 = new VultrClient('test.io', -1, 5, 1, !1);
            client1.errorCallback = function (error) {
            }, client1.processServers(function (regions) {
                var servers = [];
                for (var region in regions)
                    for (var regionServers = regions[region], i = 0; i < regionServers.length; i++)
                        servers.push({
                            ip: region + ':' + i,
                            scheme: 'testing',
                            region: region,
                            index: i,
                            games: regionServers[i].map(p => ({
                                playerCount: p,
                                isPrivate: !1
                            }))
                        });
                return servers;
            }({
                1: [
                    [
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                2: [
                    [
                        5,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                3: [
                    [
                        5,
                        0,
                        1,
                        5
                    ],
                    [
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                4: [
                    [
                        5,
                        1,
                        1,
                        5
                    ],
                    [
                        1,
                        0,
                        0,
                        0
                    ]
                ],
                5: [
                    [
                        5,
                        1,
                        1,
                        5
                    ],
                    [
                        1,
                        0,
                        4,
                        0
                    ]
                ],
                6: [
                    [
                        5,
                        5,
                        5,
                        5
                    ],
                    [
                        2,
                        3,
                        1,
                        4
                    ]
                ],
                7: [
                    [
                        5,
                        5,
                        5,
                        5
                    ],
                    [
                        5,
                        5,
                        5,
                        5
                    ]
                ]
            })), assert(client1.seekServer(1, !1), [
                1,
                0,
                0
            ]), assert(client1.seekServer(1, !0), [
                1,
                1,
                3
            ]), assert(client1.seekServer(2, !1), [
                2,
                0,
                1
            ]), assert(client1.seekServer(2, !0), [
                2,
                1,
                3
            ]), assert(client1.seekServer(3, !1), [
                3,
                0,
                2
            ]), assert(client1.seekServer(3, !0), [
                3,
                1,
                3
            ]), assert(client1.seekServer(4, !1), [
                4,
                0,
                1
            ]), assert(client1.seekServer(4, !0), [
                4,
                1,
                3
            ]), assert(client1.seekServer(5, !1), [
                5,
                1,
                2
            ]), assert(client1.seekServer(5, !0), [
                5,
                1,
                3
            ]), assert(client1.seekServer(6, !1), [
                6,
                1,
                3
            ]), assert(client1.seekServer(6, !0), void 0), assert(client1.seekServer(7, !1), void 0), assert(client1.seekServer(7, !0), void 0), console.log('Tests passed.');
        };
        var concat = function (x, y) {
            return x.concat(y);
        };
        Array.prototype.flatMap = function (f) {
            return function (f, xs) {
                return xs.map(f).reduce(concat, []);
            }(f, this);
        }, module.exports = VultrClient;
    },
    function (e, exports, __webpack_require__) {
        /* 24: ./node_modules/punycode/punycode.js */
        'use strict';
        var punycode = __webpack_require__(25), util = __webpack_require__(28);
        function Url() {
            this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        exports.parse = urlParse, exports.resolve = function (source, relative) {
            return urlParse(source, !1, !0).resolve(relative);
        }, exports.resolveObject = function (source, relative) {
            return source ? urlParse(source, !1, !0).resolveObject(relative) : relative;
        }, exports.format = function (obj) {
            return util.isString(obj) && (obj = urlParse(obj)), obj instanceof Url ? obj.format() : Url.prototype.format.call(obj);
        }, exports.Url = Url;
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, unwise = [
                '{',
                '}',
                '|',
                '\\',
                '^',
                '`'
            ].concat([
                '<',
                '>',
                '"',
                '`',
                ' ',
                '\r',
                '\n',
                '\t'
            ]), autoEscape = ['\''].concat(unwise), nonHostChars = [
                '%',
                '/',
                '?',
                ';',
                '#'
            ].concat(autoEscape), hostEndingChars = [
                '/',
                '?',
                '#'
            ], hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
                javascript: !0,
                'javascript:': !0
            }, hostlessProtocol = {
                javascript: !0,
                'javascript:': !0
            }, slashedProtocol = {
                http: !0,
                https: !0,
                ftp: !0,
                gopher: !0,
                file: !0,
                'http:': !0,
                'https:': !0,
                'ftp:': !0,
                'gopher:': !0,
                'file:': !0
            }, querystring = __webpack_require__(29);
        function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && util.isObject(url) && url instanceof Url)
                return url;
            var u = new Url();
            return u.parse(url, parseQueryString, slashesDenoteHost), u;
        }
        Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
            if (!util.isString(url))
                throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
            var queryIndex = url.indexOf('?'), splitter = -1 !== queryIndex && queryIndex < url.indexOf('#') ? '?' : '#', uSplit = url.split(splitter);
            uSplit[0] = uSplit[0].replace(/\\/g, '/');
            var rest = url = uSplit.join(splitter);
            if (rest = rest.trim(), !slashesDenoteHost && 1 === url.split('#').length) {
                var simplePath = simplePathPattern.exec(rest);
                if (simplePath)
                    return this.path = rest, this.href = rest, this.pathname = simplePath[1], simplePath[2] ? (this.search = simplePath[2], this.query = parseQueryString ? querystring.parse(this.search.substr(1)) : this.search.substr(1)) : parseQueryString && (this.search = '', this.query = {}), this;
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
                var lowerProto = (proto = proto[0]).toLowerCase();
                this.protocol = lowerProto, rest = rest.substr(proto.length);
            }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = '//' === rest.substr(0, 2);
                !slashes || proto && hostlessProtocol[proto] || (rest = rest.substr(2), this.slashes = !0);
            }
            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                for (var auth, atSign, hostEnd = -1, i = 0; i < hostEndingChars.length; i++)
                    -1 !== (hec = rest.indexOf(hostEndingChars[i])) && (-1 === hostEnd || hec < hostEnd) && (hostEnd = hec);
                for (-1 !== (atSign = -1 === hostEnd ? rest.lastIndexOf('@') : rest.lastIndexOf('@', hostEnd)) && (auth = rest.slice(0, atSign), rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth)), hostEnd = -1, i = 0; i < nonHostChars.length; i++) {
                    var hec;
                    -1 !== (hec = rest.indexOf(nonHostChars[i])) && (-1 === hostEnd || hec < hostEnd) && (hostEnd = hec);
                }
                -1 === hostEnd && (hostEnd = rest.length), this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), this.parseHost(), this.hostname = this.hostname || '';
                var ipv6Hostname = '[' === this.hostname[0] && ']' === this.hostname[this.hostname.length - 1];
                if (!ipv6Hostname)
                    for (var hostparts = this.hostname.split(/\./), l = (i = 0, hostparts.length); i < l; i++) {
                        var part = hostparts[i];
                        if (part && !part.match(hostnamePartPattern)) {
                            for (var newpart = '', j = 0, k = part.length; j < k; j++)
                                part.charCodeAt(j) > 127 ? newpart += 'x' : newpart += part[j];
                            if (!newpart.match(hostnamePartPattern)) {
                                var validParts = hostparts.slice(0, i), notHost = hostparts.slice(i + 1), bit = part.match(hostnamePartStart);
                                bit && (validParts.push(bit[1]), notHost.unshift(bit[2])), notHost.length && (rest = '/' + notHost.join('.') + rest), this.hostname = validParts.join('.');
                                break;
                            }
                        }
                    }
                this.hostname.length > 255 ? this.hostname = '' : this.hostname = this.hostname.toLowerCase(), ipv6Hostname || (this.hostname = punycode.toASCII(this.hostname));
                var p = this.port ? ':' + this.port : '', h = this.hostname || '';
                this.host = h + p, this.href += this.host, ipv6Hostname && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), '/' !== rest[0] && (rest = '/' + rest));
            }
            if (!unsafeProtocol[lowerProto])
                for (i = 0, l = autoEscape.length; i < l; i++) {
                    var ae = autoEscape[i];
                    if (-1 !== rest.indexOf(ae)) {
                        var esc = encodeURIComponent(ae);
                        esc === ae && (esc = escape(ae)), rest = rest.split(ae).join(esc);
                    }
                }
            var hash = rest.indexOf('#');
            -1 !== hash && (this.hash = rest.substr(hash), rest = rest.slice(0, hash));
            var qm = rest.indexOf('?');
            if (-1 !== qm ? (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), parseQueryString && (this.query = querystring.parse(this.query)), rest = rest.slice(0, qm)) : parseQueryString && (this.search = '', this.query = {}), rest && (this.pathname = rest), slashedProtocol[lowerProto] && this.hostname && !this.pathname && (this.pathname = '/'), this.pathname || this.search) {
                p = this.pathname || '';
                var s = this.search || '';
                this.path = p + s;
            }
            return this.href = this.format(), this;
        }, Url.prototype.format = function () {
            var auth = this.auth || '';
            auth && (auth = (auth = encodeURIComponent(auth)).replace(/%3A/i, ':'), auth += '@');
            var protocol = this.protocol || '', pathname = this.pathname || '', hash = this.hash || '', host = !1, query = '';
            this.host ? host = auth + this.host : this.hostname && (host = auth + (-1 === this.hostname.indexOf(':') ? this.hostname : '[' + this.hostname + ']'), this.port && (host += ':' + this.port)), this.query && util.isObject(this.query) && Object.keys(this.query).length && (query = querystring.stringify(this.query));
            var search = this.search || query && '?' + query || '';
            return protocol && ':' !== protocol.substr(-1) && (protocol += ':'), this.slashes || (!protocol || slashedProtocol[protocol]) && !1 !== host ? (host = '//' + (host || ''), pathname && '/' !== pathname.charAt(0) && (pathname = '/' + pathname)) : host || (host = ''), hash && '#' !== hash.charAt(0) && (hash = '#' + hash), search && '?' !== search.charAt(0) && (search = '?' + search), protocol + host + (pathname = pathname.replace(/[?#]/g, function (match) {
                return encodeURIComponent(match);
            })) + (search = search.replace('#', '%23')) + hash;
        }, Url.prototype.resolve = function (relative) {
            return this.resolveObject(urlParse(relative, !1, !0)).format();
        }, Url.prototype.resolveObject = function (relative) {
            if (util.isString(relative)) {
                var rel = new Url();
                rel.parse(relative, !1, !0), relative = rel;
            }
            for (var result = new Url(), tkeys = Object.keys(this), tk = 0; tk < tkeys.length; tk++) {
                var tkey = tkeys[tk];
                result[tkey] = this[tkey];
            }
            if (result.hash = relative.hash, '' === relative.href)
                return result.href = result.format(), result;
            if (relative.slashes && !relative.protocol) {
                for (var rkeys = Object.keys(relative), rk = 0; rk < rkeys.length; rk++) {
                    var rkey = rkeys[rk];
                    'protocol' !== rkey && (result[rkey] = relative[rkey]);
                }
                return slashedProtocol[result.protocol] && result.hostname && !result.pathname && (result.path = result.pathname = '/'), result.href = result.format(), result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
                if (!slashedProtocol[relative.protocol]) {
                    for (var keys = Object.keys(relative), v = 0; v < keys.length; v++) {
                        var k = keys[v];
                        result[k] = relative[k];
                    }
                    return result.href = result.format(), result;
                }
                if (result.protocol = relative.protocol, relative.host || hostlessProtocol[relative.protocol])
                    result.pathname = relative.pathname;
                else {
                    for (var relPath = (relative.pathname || '').split('/'); relPath.length && !(relative.host = relPath.shift()););
                    relative.host || (relative.host = ''), relative.hostname || (relative.hostname = ''), '' !== relPath[0] && relPath.unshift(''), relPath.length < 2 && relPath.unshift(''), result.pathname = relPath.join('/');
                }
                if (result.search = relative.search, result.query = relative.query, result.host = relative.host || '', result.auth = relative.auth, result.hostname = relative.hostname || relative.host, result.port = relative.port, result.pathname || result.search) {
                    var p = result.pathname || '', s = result.search || '';
                    result.path = p + s;
                }
                return result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;
            }
            var isSourceAbs = result.pathname && '/' === result.pathname.charAt(0), isRelAbs = relative.host || relative.pathname && '/' === relative.pathname.charAt(0), mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split('/') || [], psychotic = (relPath = relative.pathname && relative.pathname.split('/') || [], result.protocol && !slashedProtocol[result.protocol]);
            if (psychotic && (result.hostname = '', result.port = null, result.host && ('' === srcPath[0] ? srcPath[0] = result.host : srcPath.unshift(result.host)), result.host = '', relative.protocol && (relative.hostname = null, relative.port = null, relative.host && ('' === relPath[0] ? relPath[0] = relative.host : relPath.unshift(relative.host)), relative.host = null), mustEndAbs = mustEndAbs && ('' === relPath[0] || '' === srcPath[0])), isRelAbs)
                result.host = relative.host || '' === relative.host ? relative.host : result.host, result.hostname = relative.hostname || '' === relative.hostname ? relative.hostname : result.hostname, result.search = relative.search, result.query = relative.query, srcPath = relPath;
            else if (relPath.length)
                srcPath || (srcPath = []), srcPath.pop(), srcPath = srcPath.concat(relPath), result.search = relative.search, result.query = relative.query;
            else if (!util.isNullOrUndefined(relative.search))
                return psychotic && (result.hostname = result.host = srcPath.shift(), (authInHost = !!(result.host && result.host.indexOf('@') > 0) && result.host.split('@')) && (result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift())), result.search = relative.search, result.query = relative.query, util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '')), result.href = result.format(), result;
            if (!srcPath.length)
                return result.pathname = null, result.search ? result.path = '/' + result.search : result.path = null, result.href = result.format(), result;
            for (var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && ('.' === last || '..' === last) || '' === last, up = 0, i = srcPath.length; i >= 0; i--)
                '.' === (last = srcPath[i]) ? srcPath.splice(i, 1) : '..' === last ? (srcPath.splice(i, 1), up++) : up && (srcPath.splice(i, 1), up--);
            if (!mustEndAbs && !removeAllDots)
                for (; up--; up)
                    srcPath.unshift('..');
            !mustEndAbs || '' === srcPath[0] || srcPath[0] && '/' === srcPath[0].charAt(0) || srcPath.unshift(''), hasTrailingSlash && '/' !== srcPath.join('/').substr(-1) && srcPath.push('');
            var authInHost, isAbsolute = '' === srcPath[0] || srcPath[0] && '/' === srcPath[0].charAt(0);
            return psychotic && (result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '', (authInHost = !!(result.host && result.host.indexOf('@') > 0) && result.host.split('@')) && (result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift())), (mustEndAbs = mustEndAbs || result.host && srcPath.length) && !isAbsolute && srcPath.unshift(''), srcPath.length ? result.pathname = srcPath.join('/') : (result.pathname = null, result.path = null), util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '')), result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;
        }, Url.prototype.parseHost = function () {
            var host = this.host, port = portPattern.exec(host);
            port && (':' !== (port = port[0]) && (this.port = port.substr(1)), host = host.substr(0, host.length - port.length)), host && (this.hostname = host);
        };
    },
    function (e, exports, __webpack_require__) {
        /* 25: (webpack)/buildin/module.js */
        (function (module, global) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !function (root) {
                exports && exports.nodeType, module && module.nodeType;
                var freeGlobal = 'object' == typeof global && global;
                freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal && freeGlobal.self;
                var punycode, maxInt = 2147483647, base = 36, regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                        overflow: 'Overflow: input needs wider integers to process',
                        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                        'invalid-input': 'Invalid input'
                    }, floor = Math.floor, stringFromCharCode = String.fromCharCode;
                function error(type) {
                    throw new RangeError(errors[type]);
                }
                function map(array, fn) {
                    for (var length = array.length, result = []; length--;)
                        result[length] = fn(array[length]);
                    return result;
                }
                function mapDomain(string, fn) {
                    var parts = string.split('@'), result = '';
                    return parts.length > 1 && (result = parts[0] + '@', string = parts[1]), result + map((string = string.replace(regexSeparators, '.')).split('.'), fn).join('.');
                }
                function ucs2decode(string) {
                    for (var value, extra, output = [], counter = 0, length = string.length; counter < length;)
                        (value = string.charCodeAt(counter++)) >= 55296 && value <= 56319 && counter < length ? 56320 == (64512 & (extra = string.charCodeAt(counter++))) ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value), counter--) : output.push(value);
                    return output;
                }
                function ucs2encode(array) {
                    return map(array, function (value) {
                        var output = '';
                        return value > 65535 && (output += stringFromCharCode((value -= 65536) >>> 10 & 1023 | 55296), value = 56320 | 1023 & value), output + stringFromCharCode(value);
                    }).join('');
                }
                function basicToDigit(codePoint) {
                    return codePoint - 48 < 10 ? codePoint - 22 : codePoint - 65 < 26 ? codePoint - 65 : codePoint - 97 < 26 ? codePoint - 97 : base;
                }
                function digitToBasic(digit, flag) {
                    return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5);
                }
                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    for (delta = firstTime ? floor(delta / 700) : delta >> 1, delta += floor(delta / numPoints); delta > 455; k += base)
                        delta = floor(delta / 35);
                    return floor(k + 36 * delta / (delta + 38));
                }
                function decode(input) {
                    var out, basic, j, index, oldi, w, k, digit, t, baseMinusT, output = [], inputLength = input.length, i = 0, n = 128, bias = 72;
                    for ((basic = input.lastIndexOf('-')) < 0 && (basic = 0), j = 0; j < basic; ++j)
                        input.charCodeAt(j) >= 128 && error('not-basic'), output.push(input.charCodeAt(j));
                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
                        for (oldi = i, w = 1, k = base; index >= inputLength && error('invalid-input'), ((digit = basicToDigit(input.charCodeAt(index++))) >= base || digit > floor((maxInt - i) / w)) && error('overflow'), i += digit * w, !(digit < (t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias)); k += base)
                            w > floor(maxInt / (baseMinusT = base - t)) && error('overflow'), w *= baseMinusT;
                        bias = adapt(i - oldi, out = output.length + 1, 0 == oldi), floor(i / out) > maxInt - n && error('overflow'), n += floor(i / out), i %= out, output.splice(i++, 0, n);
                    }
                    return ucs2encode(output);
                }
                function encode(input) {
                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, inputLength, handledCPCountPlusOne, baseMinusT, qMinusT, output = [];
                    for (inputLength = (input = ucs2decode(input)).length, n = 128, delta = 0, bias = 72, j = 0; j < inputLength; ++j)
                        (currentValue = input[j]) < 128 && output.push(stringFromCharCode(currentValue));
                    for (handledCPCount = basicLength = output.length, basicLength && output.push('-'); handledCPCount < inputLength;) {
                        for (m = maxInt, j = 0; j < inputLength; ++j)
                            (currentValue = input[j]) >= n && currentValue < m && (m = currentValue);
                        for (m - n > floor((maxInt - delta) / (handledCPCountPlusOne = handledCPCount + 1)) && error('overflow'), delta += (m - n) * handledCPCountPlusOne, n = m, j = 0; j < inputLength; ++j)
                            if ((currentValue = input[j]) < n && ++delta > maxInt && error('overflow'), currentValue == n) {
                                for (q = delta, k = base; !(q < (t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias)); k += base)
                                    qMinusT = q - t, baseMinusT = base - t, output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT);
                                output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength), delta = 0, ++handledCPCount;
                            }
                        ++delta, ++n;
                    }
                    return output.join('');
                }
                punycode = {
                    version: '1.4.1',
                    ucs2: {
                        decode: ucs2decode,
                        encode: ucs2encode
                    },
                    decode: decode,
                    encode: encode,
                    toASCII: function (input) {
                        return mapDomain(input, function (string) {
                            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
                        });
                    },
                    toUnicode: function (input) {
                        return mapDomain(input, function (string) {
                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                        });
                    }
                }, void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                    return punycode;
                }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
            }();
        }.call(this, __webpack_require__(26)(e), __webpack_require__(27)));
    },
    function (module, t) {
        /* 26: (webpack)/buildin/global.js */
        module.exports = function (module) {
            return module.webpackPolyfill || (module.deprecate = function () {
            }, module.paths = [], module.children || (module.children = []), Object.defineProperty(module, 'loaded', {
                enumerable: !0,
                get: function () {
                    return module.l;
                }
            }), Object.defineProperty(module, 'id', {
                enumerable: !0,
                get: function () {
                    return module.i;
                }
            }), module.webpackPolyfill = 1), module;
        };
    },
    function (module, t) {
        /* 27: ./node_modules/url/util.js */
        var g;
        g = function () {
            return this;
        }();
        try {
            g = g || new Function('return this')();
        } catch (e) {
            'object' == typeof window && (g = window);
        }
        module.exports = g;
    },
    function (module, t, i) {
        /* 28: ./node_modules/querystring-es3/index.js */
        'use strict';
        module.exports = {
            isString: function (arg) {
                return 'string' == typeof arg;
            },
            isObject: function (arg) {
                return 'object' == typeof arg && null !== arg;
            },
            isNull: function (arg) {
                return null === arg;
            },
            isNullOrUndefined: function (arg) {
                return null == arg;
            }
        };
    },
    function (e, exports, __webpack_require__) {
        /* 29: ./node_modules/querystring-es3/decode.js */
        'use strict';
        exports.decode = exports.parse = __webpack_require__(30), exports.encode = exports.stringify = __webpack_require__(31);
    },
    function (module, t, i) {
        /* 30: ./node_modules/querystring-es3/encode.js */
        'use strict';
        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module.exports = function (qs, sep, eq, options) {
            sep = sep || '&', eq = eq || '=';
            var obj = {};
            if ('string' != typeof qs || 0 === qs.length)
                return obj;
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1000;
            options && 'number' == typeof options.maxKeys && (maxKeys = options.maxKeys);
            var len = qs.length;
            maxKeys > 0 && len > maxKeys && (len = maxKeys);
            for (var i = 0; i < len; ++i) {
                var kstr, vstr, k, v, x = qs[i].replace(regexp, '%20'), idx = x.indexOf(eq);
                idx >= 0 ? (kstr = x.substr(0, idx), vstr = x.substr(idx + 1)) : (kstr = x, vstr = ''), k = decodeURIComponent(kstr), v = decodeURIComponent(vstr), hasOwnProperty(obj, k) ? isArray(obj[k]) ? obj[k].push(v) : obj[k] = [
                    obj[k],
                    v
                ] : obj[k] = v;
            }
            return obj;
        };
        var isArray = Array.isArray || function (xs) {
            return '[object Array]' === Object.prototype.toString.call(xs);
        };
    },
    function (module, t, i) {
        /* 31: ./node_modules/md5/md5.js */
        'use strict';
        var stringifyPrimitive = function (v) {
            switch (typeof v) {
            case 'string':
                return v;
            case 'boolean':
                return v ? 'true' : 'false';
            case 'number':
                return isFinite(v) ? v : '';
            default:
                return '';
            }
        };
        module.exports = function (obj, sep, eq, name) {
            return sep = sep || '&', eq = eq || '=', null === obj && (obj = void 0), 'object' == typeof obj ? map(objectKeys(obj), function (k) {
                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                return isArray(obj[k]) ? map(obj[k], function (v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep) : ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }).join(sep) : name ? encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj)) : '';
        };
        var isArray = Array.isArray || function (xs) {
            return '[object Array]' === Object.prototype.toString.call(xs);
        };
        function map(xs, f) {
            if (xs.map)
                return xs.map(f);
            for (var res = [], i = 0; i < xs.length; i++)
                res.push(f(xs[i], i));
            return res;
        }
        var objectKeys = Object.keys || function (obj) {
            var res = [];
            for (var key in obj)
                Object.prototype.hasOwnProperty.call(obj, key) && res.push(key);
            return res;
        };
    },
    function (module, t, __webpack_require__) {
        /* 32: ./node_modules/crypt/crypt.js */
        !function () {
            var crypt = __webpack_require__(33), utf8 = __webpack_require__(1).utf8, isBuffer = __webpack_require__(34), bin = __webpack_require__(1).bin, md5 = function (message, options) {
                    message.constructor == String ? message = options && 'binary' === options.encoding ? bin.stringToBytes(message) : utf8.stringToBytes(message) : isBuffer(message) ? message = Array.prototype.slice.call(message, 0) : Array.isArray(message) || (message = message.toString());
                    for (var m = crypt.bytesToWords(message), l = 8 * message.length, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, i = 0; i < m.length; i++)
                        m[i] = 16711935 & (m[i] << 8 | m[i] >>> 24) | 4278255360 & (m[i] << 24 | m[i] >>> 8);
                    m[l >>> 5] |= 128 << l % 32, m[14 + (l + 64 >>> 9 << 4)] = l;
                    var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;
                    for (i = 0; i < m.length; i += 16) {
                        var aa = a, bb = b, cc = c, dd = d;
                        b = II(b = II(b = II(b = II(b = HH(b = HH(b = HH(b = HH(b = GG(b = GG(b = GG(b = GG(b = FF(b = FF(b = FF(b = FF(b, c = FF(c, d = FF(d, a = FF(a, b, c, d, m[i + 0], 7, -680876936), b, c, m[i + 1], 12, -389564586), a, b, m[i + 2], 17, 606105819), d, a, m[i + 3], 22, -1044525330), c = FF(c, d = FF(d, a = FF(a, b, c, d, m[i + 4], 7, -176418897), b, c, m[i + 5], 12, 1200080426), a, b, m[i + 6], 17, -1473231341), d, a, m[i + 7], 22, -45705983), c = FF(c, d = FF(d, a = FF(a, b, c, d, m[i + 8], 7, 1770035416), b, c, m[i + 9], 12, -1958414417), a, b, m[i + 10], 17, -42063), d, a, m[i + 11], 22, -1990404162), c = FF(c, d = FF(d, a = FF(a, b, c, d, m[i + 12], 7, 1804603682), b, c, m[i + 13], 12, -40341101), a, b, m[i + 14], 17, -1502002290), d, a, m[i + 15], 22, 1236535329), c = GG(c, d = GG(d, a = GG(a, b, c, d, m[i + 1], 5, -165796510), b, c, m[i + 6], 9, -1069501632), a, b, m[i + 11], 14, 643717713), d, a, m[i + 0], 20, -373897302), c = GG(c, d = GG(d, a = GG(a, b, c, d, m[i + 5], 5, -701558691), b, c, m[i + 10], 9, 38016083), a, b, m[i + 15], 14, -660478335), d, a, m[i + 4], 20, -405537848), c = GG(c, d = GG(d, a = GG(a, b, c, d, m[i + 9], 5, 568446438), b, c, m[i + 14], 9, -1019803690), a, b, m[i + 3], 14, -187363961), d, a, m[i + 8], 20, 1163531501), c = GG(c, d = GG(d, a = GG(a, b, c, d, m[i + 13], 5, -1444681467), b, c, m[i + 2], 9, -51403784), a, b, m[i + 7], 14, 1735328473), d, a, m[i + 12], 20, -1926607734), c = HH(c, d = HH(d, a = HH(a, b, c, d, m[i + 5], 4, -378558), b, c, m[i + 8], 11, -2022574463), a, b, m[i + 11], 16, 1839030562), d, a, m[i + 14], 23, -35309556), c = HH(c, d = HH(d, a = HH(a, b, c, d, m[i + 1], 4, -1530992060), b, c, m[i + 4], 11, 1272893353), a, b, m[i + 7], 16, -155497632), d, a, m[i + 10], 23, -1094730640), c = HH(c, d = HH(d, a = HH(a, b, c, d, m[i + 13], 4, 681279174), b, c, m[i + 0], 11, -358537222), a, b, m[i + 3], 16, -722521979), d, a, m[i + 6], 23, 76029189), c = HH(c, d = HH(d, a = HH(a, b, c, d, m[i + 9], 4, -640364487), b, c, m[i + 12], 11, -421815835), a, b, m[i + 15], 16, 530742520), d, a, m[i + 2], 23, -995338651), c = II(c, d = II(d, a = II(a, b, c, d, m[i + 0], 6, -198630844), b, c, m[i + 7], 10, 1126891415), a, b, m[i + 14], 15, -1416354905), d, a, m[i + 5], 21, -57434055), c = II(c, d = II(d, a = II(a, b, c, d, m[i + 12], 6, 1700485571), b, c, m[i + 3], 10, -1894986606), a, b, m[i + 10], 15, -1051523), d, a, m[i + 1], 21, -2054922799), c = II(c, d = II(d, a = II(a, b, c, d, m[i + 8], 6, 1873313359), b, c, m[i + 15], 10, -30611744), a, b, m[i + 6], 15, -1560198380), d, a, m[i + 13], 21, 1309151649), c = II(c, d = II(d, a = II(a, b, c, d, m[i + 4], 6, -145523070), b, c, m[i + 11], 10, -1120210379), a, b, m[i + 2], 15, 718787259), d, a, m[i + 9], 21, -343485551), a = a + aa >>> 0, b = b + bb >>> 0, c = c + cc >>> 0, d = d + dd >>> 0;
                    }
                    return crypt.endian([
                        a,
                        b,
                        c,
                        d
                    ]);
                };
            md5._ff = function (a, b, c, d, x, s, t) {
                var n = a + (b & c | ~b & d) + (x >>> 0) + t;
                return (n << s | n >>> 32 - s) + b;
            }, md5._gg = function (a, b, c, d, x, s, t) {
                var n = a + (b & d | c & ~d) + (x >>> 0) + t;
                return (n << s | n >>> 32 - s) + b;
            }, md5._hh = function (a, b, c, d, x, s, t) {
                var n = a + (b ^ c ^ d) + (x >>> 0) + t;
                return (n << s | n >>> 32 - s) + b;
            }, md5._ii = function (a, b, c, d, x, s, t) {
                var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
                return (n << s | n >>> 32 - s) + b;
            }, md5._blocksize = 16, md5._digestsize = 16, module.exports = function (message, options) {
                if (null == message)
                    throw new Error('Illegal argument ' + message);
                var digestbytes = crypt.wordsToBytes(md5(message, options));
                return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
            };
        }();
    },
    function (module, t) {
        /* 33: ./node_modules/is-buffer/index.js */
        !function () {
            var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', crypt = {
                    rotl: function (n, b) {
                        return n << b | n >>> 32 - b;
                    },
                    rotr: function (n, b) {
                        return n << 32 - b | n >>> b;
                    },
                    endian: function (n) {
                        if (n.constructor == Number)
                            return 16711935 & crypt.rotl(n, 8) | 4278255360 & crypt.rotl(n, 24);
                        for (var i = 0; i < n.length; i++)
                            n[i] = crypt.endian(n[i]);
                        return n;
                    },
                    randomBytes: function (n) {
                        for (var bytes = []; n > 0; n--)
                            bytes.push(Math.floor(256 * Math.random()));
                        return bytes;
                    },
                    bytesToWords: function (bytes) {
                        for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
                            words[b >>> 5] |= bytes[i] << 24 - b % 32;
                        return words;
                    },
                    wordsToBytes: function (words) {
                        for (var bytes = [], b = 0; b < 32 * words.length; b += 8)
                            bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
                        return bytes;
                    },
                    bytesToHex: function (bytes) {
                        for (var hex = [], i = 0; i < bytes.length; i++)
                            hex.push((bytes[i] >>> 4).toString(16)), hex.push((15 & bytes[i]).toString(16));
                        return hex.join('');
                    },
                    hexToBytes: function (hex) {
                        for (var bytes = [], c = 0; c < hex.length; c += 2)
                            bytes.push(parseInt(hex.substr(c, 2), 16));
                        return bytes;
                    },
                    bytesToBase64: function (bytes) {
                        for (var base64 = [], i = 0; i < bytes.length; i += 3)
                            for (var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2], j = 0; j < 4; j++)
                                8 * i + 6 * j <= 8 * bytes.length ? base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63)) : base64.push('=');
                        return base64.join('');
                    },
                    base64ToBytes: function (base64) {
                        base64 = base64.replace(/[^A-Z0-9+\/]/gi, '');
                        for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4)
                            0 != imod4 && bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << 2 * imod4 | base64map.indexOf(base64.charAt(i)) >>> 6 - 2 * imod4);
                        return bytes;
                    }
                };
            module.exports = crypt;
        }();
    },
    function (module, t) {
        /* 34: ./src/js/data/aiManager.js */
        function isBuffer(obj) {
            return !!obj.constructor && 'function' == typeof obj.constructor.isBuffer && obj.constructor.isBuffer(obj);
        }
        module.exports = function (obj) {
            return null != obj && (isBuffer(obj) || function (obj) {
                return 'function' == typeof obj.readFloatLE && 'function' == typeof obj.slice && isBuffer(obj.slice(0, 0));
            }(obj) || !!obj._isBuffer);
        };
    },
    function (module, t) {
        /* 35: ./src/js/data/ai.js */
        module.exports = function (ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {
            this.aiTypes = [
                {
                    id: 0,
                    src: 'cow_1',
                    killScore: 150,
                    health: 500,
                    weightM: 0.8,
                    speed: 0.00095,
                    turnSpeed: 0.001,
                    scale: 72,
                    drop: [
                        'food',
                        50
                    ]
                },
                {
                    id: 1,
                    src: 'pig_1',
                    killScore: 200,
                    health: 800,
                    weightM: 0.6,
                    speed: 0.00085,
                    turnSpeed: 0.001,
                    scale: 72,
                    drop: [
                        'food',
                        80
                    ]
                },
                {
                    id: 2,
                    name: 'Bull',
                    src: 'bull_2',
                    hostile: !0,
                    dmg: 20,
                    killScore: 1000,
                    health: 1800,
                    weightM: 0.5,
                    speed: 0.00094,
                    turnSpeed: 0.00074,
                    scale: 78,
                    viewRange: 800,
                    chargePlayer: !0,
                    drop: [
                        'food',
                        100
                    ]
                },
                {
                    id: 3,
                    name: 'Bully',
                    src: 'bull_1',
                    hostile: !0,
                    dmg: 20,
                    killScore: 2000,
                    health: 2800,
                    weightM: 0.45,
                    speed: 0.001,
                    turnSpeed: 0.0008,
                    scale: 90,
                    viewRange: 900,
                    chargePlayer: !0,
                    drop: [
                        'food',
                        400
                    ]
                },
                {
                    id: 4,
                    name: 'Wolf',
                    src: 'wolf_1',
                    hostile: !0,
                    dmg: 8,
                    killScore: 500,
                    health: 300,
                    weightM: 0.45,
                    speed: 0.001,
                    turnSpeed: 0.002,
                    scale: 84,
                    viewRange: 800,
                    chargePlayer: !0,
                    drop: [
                        'food',
                        200
                    ]
                },
                {
                    id: 5,
                    name: 'Quack',
                    src: 'chicken_1',
                    dmg: 8,
                    killScore: 2000,
                    noTrap: !0,
                    health: 300,
                    weightM: 0.2,
                    speed: 0.0018,
                    turnSpeed: 0.006,
                    scale: 70,
                    drop: [
                        'food',
                        100
                    ]
                },
                {
                    id: 6,
                    name: 'MOOSTAFA',
                    nameScale: 50,
                    src: 'enemy',
                    hostile: !0,
                    dontRun: !0,
                    fixedSpawn: !0,
                    spawnDelay: 60000,
                    noTrap: !0,
                    colDmg: 100,
                    dmg: 40,
                    killScore: 8000,
                    health: 18000,
                    weightM: 0.4,
                    speed: 0.0007,
                    turnSpeed: 0.01,
                    scale: 80,
                    spriteMlt: 1.8,
                    leapForce: 0.9,
                    viewRange: 1000,
                    hitRange: 210,
                    hitDelay: 1000,
                    chargePlayer: !0,
                    drop: [
                        'food',
                        100
                    ]
                },
                {
                    id: 7,
                    name: 'Treasure',
                    hostile: !0,
                    nameScale: 35,
                    src: 'crate_1',
                    fixedSpawn: !0,
                    spawnDelay: 120000,
                    colDmg: 200,
                    killScore: 5000,
                    health: 20000,
                    weightM: 0.1,
                    speed: 0,
                    turnSpeed: 0,
                    scale: 70,
                    spriteMlt: 1
                },
                {
                    id: 8,
                    name: 'MOOFIE',
                    src: 'wolf_2',
                    hostile: !0,
                    fixedSpawn: !0,
                    dontRun: !0,
                    hitScare: 4,
                    spawnDelay: 30000,
                    noTrap: !0,
                    nameScale: 35,
                    dmg: 10,
                    colDmg: 100,
                    killScore: 3000,
                    health: 7000,
                    weightM: 0.45,
                    speed: 0.0015,
                    turnSpeed: 0.002,
                    scale: 90,
                    viewRange: 800,
                    chargePlayer: !0,
                    drop: [
                        'food',
                        1000
                    ]
                }
            ], this.spawn = function (x, y, dir, index) {
                for (var tmpObj, i = 0; i < ais.length; ++i)
                    if (!ais[i].active) {
                        tmpObj = ais[i];
                        break;
                    }
                return tmpObj || (tmpObj = new AI(ais.length, objectManager, players, items, UTILS, config, scoreCallback, server), ais.push(tmpObj)), tmpObj.init(x, y, dir, index, this.aiTypes[index]), tmpObj;
            };
        };
    },
    function (module, t) {
        /* 36: ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs */
        var PI2 = 2 * Math.PI;
        module.exports = function (sid, objectManager, players, items, UTILS, config, scoreCallback, server) {
            this.sid = sid, this.isAI = !0, this.nameIndex = UTILS.randInt(0, config.cowNames.length - 1), this.init = function (x, y, dir, index, data) {
                this.x = x, this.y = y, this.startX = data.fixedSpawn ? x : null, this.startY = data.fixedSpawn ? y : null, this.xVel = 0, this.yVel = 0, this.zIndex = 0, this.dir = dir, this.dirPlus = 0, this.index = index, this.src = data.src, data.name && (this.name = data.name), this.weightM = data.weightM, this.speed = data.speed, this.killScore = data.killScore, this.turnSpeed = data.turnSpeed, this.scale = data.scale, this.maxHealth = data.health, this.leapForce = data.leapForce, this.health = this.maxHealth, this.chargePlayer = data.chargePlayer, this.viewRange = data.viewRange, this.drop = data.drop, this.dmg = data.dmg, this.hostile = data.hostile, this.dontRun = data.dontRun, this.hitRange = data.hitRange, this.hitDelay = data.hitDelay, this.hitScare = data.hitScare, this.spriteMlt = data.spriteMlt, this.nameScale = data.nameScale, this.colDmg = data.colDmg, this.noTrap = data.noTrap, this.spawnDelay = data.spawnDelay, this.hitWait = 0, this.waitCount = 1000, this.moveCount = 0, this.targetDir = 0, this.active = !0, this.alive = !0, this.runFrom = null, this.chargeTarget = null, this.dmgOverTime = {};
            };
            var timerCount = 0;
            this.update = function (delta) {
                if (this.active) {
                    if (this.spawnCounter)
                        return this.spawnCounter -= delta, void (this.spawnCounter <= 0 && (this.spawnCounter = 0, this.x = this.startX || UTILS.randInt(0, config.mapScale), this.y = this.startY || UTILS.randInt(0, config.mapScale)));
                    (timerCount -= delta) <= 0 && (this.dmgOverTime.dmg && (this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer), this.dmgOverTime.time -= 1, this.dmgOverTime.time <= 0 && (this.dmgOverTime.dmg = 0)), timerCount = 1000);
                    var charging = !1, slowMlt = 1;
                    if (!this.zIndex && !this.lockMove && this.y >= config.mapScale / 2 - config.riverWidth / 2 && this.y <= config.mapScale / 2 + config.riverWidth / 2 && (slowMlt = 0.33, this.xVel += config.waterCurrent * delta), this.lockMove)
                        this.xVel = 0, this.yVel = 0;
                    else if (this.waitCount > 0) {
                        if (this.waitCount -= delta, this.waitCount <= 0)
                            if (this.chargePlayer) {
                                for (var tmpPlayer, bestDst, tmpDist, i = 0; i < players.length; ++i)
                                    !players[i].alive || players[i].skin && players[i].skin.bullRepel || (tmpDist = UTILS.getDistance(this.x, this.y, players[i].x, players[i].y)) <= this.viewRange && (!tmpPlayer || tmpDist < bestDst) && (bestDst = tmpDist, tmpPlayer = players[i]);
                                tmpPlayer ? (this.chargeTarget = tmpPlayer, this.moveCount = UTILS.randInt(8000, 12000)) : (this.moveCount = UTILS.randInt(1000, 2000), this.targetDir = UTILS.randFloat(-Math.PI, Math.PI));
                            } else
                                this.moveCount = UTILS.randInt(4000, 10000), this.targetDir = UTILS.randFloat(-Math.PI, Math.PI);
                    } else if (this.moveCount > 0) {
                        var tmpSpd = this.speed * slowMlt;
                        if (this.runFrom && this.runFrom.active && (!this.runFrom.isPlayer || this.runFrom.alive) ? (this.targetDir = UTILS.getDirection(this.x, this.y, this.runFrom.x, this.runFrom.y), tmpSpd *= 1.42) : this.chargeTarget && this.chargeTarget.alive && (this.targetDir = UTILS.getDirection(this.chargeTarget.x, this.chargeTarget.y, this.x, this.y), tmpSpd *= 1.75, charging = !0), this.hitWait && (tmpSpd *= 0.3), this.dir != this.targetDir) {
                            this.dir %= PI2;
                            var netAngle = (this.dir - this.targetDir + PI2) % PI2, amnt = Math.min(Math.abs(netAngle - PI2), netAngle, this.turnSpeed * delta), sign = netAngle - Math.PI >= 0 ? 1 : -1;
                            this.dir += sign * amnt + PI2;
                        }
                        this.dir %= PI2, this.xVel += tmpSpd * delta * Math.cos(this.dir), this.yVel += tmpSpd * delta * Math.sin(this.dir), this.moveCount -= delta, this.moveCount <= 0 && (this.runFrom = null, this.chargeTarget = null, this.waitCount = this.hostile ? 1500 : UTILS.randInt(1500, 6000));
                    }
                    this.zIndex = 0, this.lockMove = !1;
                    var tmpSpeed = UTILS.getDistance(0, 0, this.xVel * delta, this.yVel * delta), depth = Math.min(4, Math.max(1, Math.round(tmpSpeed / 40))), tMlt = 1 / depth;
                    for (i = 0; i < depth; ++i) {
                        this.xVel && (this.x += this.xVel * delta * tMlt), this.yVel && (this.y += this.yVel * delta * tMlt), tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                        for (var x = 0; x < tmpList.length; ++x)
                            for (var y = 0; y < tmpList[x].length; ++y)
                                tmpList[x][y].active && objectManager.checkCollision(this, tmpList[x][y], tMlt);
                    }
                    var tmpObj, tmpDst, tmpDir, hitting = !1;
                    if (this.hitWait > 0 && (this.hitWait -= delta, this.hitWait <= 0)) {
                        hitting = !0, this.hitWait = 0, this.leapForce && !UTILS.randInt(0, 2) && (this.xVel += this.leapForce * Math.cos(this.dir), this.yVel += this.leapForce * Math.sin(this.dir));
                        for (var tmpList = objectManager.getGridArrays(this.x, this.y, this.hitRange), t = 0; t < tmpList.length; ++t)
                            for (x = 0; x < tmpList[t].length; ++x)
                                (tmpObj = tmpList[t][x]).health && (tmpDst = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y)) < tmpObj.scale + this.hitRange && (tmpObj.changeHealth(5 * -this.dmg) && objectManager.disableObj(tmpObj), objectManager.hitObj(tmpObj, UTILS.getDirection(this.x, this.y, tmpObj.x, tmpObj.y)));
                        for (x = 0; x < players.length; ++x)
                            players[x].canSee(this) && server.send(players[x].id, 'aa', this.sid);
                    }
                    if (charging || hitting)
                        for (i = 0; i < players.length; ++i)
                            (tmpObj = players[i]) && tmpObj.alive && (tmpDst = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y), this.hitRange ? !this.hitWait && tmpDst <= this.hitRange + tmpObj.scale && (hitting ? (tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y), tmpObj.changeHealth(-this.dmg), tmpObj.xVel += 0.6 * Math.cos(tmpDir), tmpObj.yVel += 0.6 * Math.sin(tmpDir), this.runFrom = null, this.chargeTarget = null, this.waitCount = 3000, this.hitWait = UTILS.randInt(0, 2) ? 0 : 600) : this.hitWait = this.hitDelay) : tmpDst <= this.scale + tmpObj.scale && (tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y), tmpObj.changeHealth(-this.dmg), tmpObj.xVel += 0.55 * Math.cos(tmpDir), tmpObj.yVel += 0.55 * Math.sin(tmpDir)));
                    this.xVel && (this.xVel *= Math.pow(config.playerDecel, delta)), this.yVel && (this.yVel *= Math.pow(config.playerDecel, delta));
                    var tmpScale = this.scale;
                    this.x - tmpScale < 0 ? (this.x = tmpScale, this.xVel = 0) : this.x + tmpScale > config.mapScale && (this.x = config.mapScale - tmpScale, this.xVel = 0), this.y - tmpScale < 0 ? (this.y = tmpScale, this.yVel = 0) : this.y + tmpScale > config.mapScale && (this.y = config.mapScale - tmpScale, this.yVel = 0);
                }
            }, this.canSee = function (other) {
                if (!other)
                    return !1;
                if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer)
                    return !1;
                var dx = Math.abs(other.x - this.x) - other.scale, dy = Math.abs(other.y - this.y) - other.scale;
                return dx <= config.maxScreenWidth / 2 * 1.3 && dy <= config.maxScreenHeight / 2 * 1.3;
            };
            var tmpRatio = 0, animIndex = 0;
            this.animate = function (delta) {
                this.animTime > 0 && (this.animTime -= delta, this.animTime <= 0 ? (this.animTime = 0, this.dirPlus = 0, tmpRatio = 0, animIndex = 0) : 0 == animIndex ? (tmpRatio += delta / (this.animSpeed * config.hitReturnRatio), this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio)), tmpRatio >= 1 && (tmpRatio = 1, animIndex = 1)) : (tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio)), this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio))));
            }, this.startAnim = function () {
                this.animTime = this.animSpeed = 600, this.targetAngle = 0.8 * Math.PI, tmpRatio = 0, animIndex = 0;
            }, this.changeHealth = function (val, doer, runFrom) {
                if (this.active && (this.health += val, runFrom && (this.hitScare && !UTILS.randInt(0, this.hitScare) ? (this.runFrom = runFrom, this.waitCount = 0, this.moveCount = 2000) : this.hostile && this.chargePlayer && runFrom.isPlayer ? (this.chargeTarget = runFrom, this.waitCount = 0, this.moveCount = 8000) : this.dontRun || (this.runFrom = runFrom, this.waitCount = 0, this.moveCount = 2000)), val < 0 && this.hitRange && UTILS.randInt(0, 1) && (this.hitWait = 500), doer && doer.canSee(this) && val < 0 && server.send(doer.id, 't', Math.round(this.x), Math.round(this.y), Math.round(-val), 1), this.health <= 0 && (this.spawnDelay ? (this.spawnCounter = this.spawnDelay, this.x = -1000000, this.y = -1000000) : (this.x = this.startX || UTILS.randInt(0, config.mapScale), this.y = this.startY || UTILS.randInt(0, config.mapScale)), this.health = this.maxHealth, this.runFrom = null, doer && (scoreCallback(doer, this.killScore), this.drop))))
                    for (var i = 0; i < this.drop.length;)
                        doer.addResource(config.resourceTypes.indexOf(this.drop[i]), this.drop[i + 1]), i += 2;
            };
        };
    },
    function (e, __webpack_exports__, __webpack_require__) {
        /* 37: ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs */
        'use strict';
        __webpack_require__.r(__webpack_exports__);
        var utf8_a, utf8_b, utf8_c, UINT32_MAX = 4294967295;
        function setInt64(view, offset, value) {
            var high = Math.floor(value / 4294967296), low = value;
            view.setUint32(offset, high), view.setUint32(offset + 4, low);
        }
        function getInt64(view, offset) {
            return 4294967296 * view.getInt32(offset) + view.getUint32(offset + 4);
        }
        var TEXT_ENCODING_AVAILABLE = ('undefined' == typeof process || 'never' !== (null === (utf8_a = null === process || void 0 === process ? void 0 : process.env) || void 0 === utf8_a ? void 0 : utf8_a.TEXT_ENCODING)) && 'undefined' != typeof TextEncoder && 'undefined' != typeof TextDecoder;
        function utf8Count(str) {
            for (var strLength = str.length, byteLength = 0, pos = 0; pos < strLength;) {
                var value = str.charCodeAt(pos++);
                if (0 != (4294967168 & value))
                    if (0 == (4294965248 & value))
                        byteLength += 2;
                    else {
                        if (value >= 55296 && value <= 56319 && pos < strLength) {
                            var extra = str.charCodeAt(pos);
                            56320 == (64512 & extra) && (++pos, value = ((1023 & value) << 10) + (1023 & extra) + 65536);
                        }
                        byteLength += 0 == (4294901760 & value) ? 3 : 4;
                    }
                else
                    byteLength++;
            }
            return byteLength;
        }
        var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0, TEXT_ENCODER_THRESHOLD = TEXT_ENCODING_AVAILABLE ? 'undefined' != typeof process && 'force' !== (null === (utf8_b = null === process || void 0 === process ? void 0 : process.env) || void 0 === utf8_b ? void 0 : utf8_b.TEXT_ENCODING) ? 200 : 0 : UINT32_MAX, utf8EncodeTE = (null == sharedTextEncoder ? void 0 : sharedTextEncoder.encodeInto) ? function (str, output, outputOffset) {
                sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
            } : function (str, output, outputOffset) {
                output.set(sharedTextEncoder.encode(str), outputOffset);
            };
        function utf8DecodeJs(bytes, inputOffset, byteLength) {
            for (var offset = inputOffset, end = offset + byteLength, units = [], result = ''; offset < end;) {
                var byte1 = bytes[offset++];
                if (0 == (128 & byte1))
                    units.push(byte1);
                else if (192 == (224 & byte1)) {
                    var byte2 = 63 & bytes[offset++];
                    units.push((31 & byte1) << 6 | byte2);
                } else if (224 == (240 & byte1)) {
                    byte2 = 63 & bytes[offset++];
                    var byte3 = 63 & bytes[offset++];
                    units.push((31 & byte1) << 12 | byte2 << 6 | byte3);
                } else if (240 == (248 & byte1)) {
                    var unit = (7 & byte1) << 18 | (byte2 = 63 & bytes[offset++]) << 12 | (byte3 = 63 & bytes[offset++]) << 6 | 63 & bytes[offset++];
                    unit > 65535 && (unit -= 65536, units.push(unit >>> 10 & 1023 | 55296), unit = 56320 | 1023 & unit), units.push(unit);
                } else
                    units.push(byte1);
                units.length >= 4096 && (result += String.fromCharCode.apply(String, units), units.length = 0);
            }
            return units.length > 0 && (result += String.fromCharCode.apply(String, units)), result;
        }
        var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null, TEXT_DECODER_THRESHOLD = TEXT_ENCODING_AVAILABLE ? 'undefined' != typeof process && 'force' !== (null === (utf8_c = null === process || void 0 === process ? void 0 : process.env) || void 0 === utf8_c ? void 0 : utf8_c.TEXT_DECODER) ? 200 : 0 : UINT32_MAX, ExtData = function (type, data) {
                this.type = type, this.data = data;
            }, __extends = function () {
                var extendStatics = function (d, b) {
                    return (extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    } || function (d, b) {
                        for (var p in b)
                            Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
                    })(d, b);
                };
                return function (d, b) {
                    if ('function' != typeof b && null !== b)
                        throw new TypeError('Class extends value ' + String(b) + ' is not a constructor or null');
                    function __() {
                        this.constructor = d;
                    }
                    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }(), DecodeError = function (_super) {
                function DecodeError(message) {
                    var _this = _super.call(this, message) || this, proto = Object.create(DecodeError.prototype);
                    return Object.setPrototypeOf(_this, proto), Object.defineProperty(_this, 'name', {
                        configurable: !0,
                        enumerable: !1,
                        value: DecodeError.name
                    }), _this;
                }
                return __extends(DecodeError, _super), DecodeError;
            }(Error);
        function encodeTimeSpecToTimestamp(_a) {
            var view, sec = _a.sec, nsec = _a.nsec;
            if (sec >= 0 && nsec >= 0 && sec <= 17179869183) {
                if (0 === nsec && sec <= 4294967295) {
                    var rv = new Uint8Array(4);
                    return (view = new DataView(rv.buffer)).setUint32(0, sec), rv;
                }
                var secHigh = sec / 4294967296, secLow = 4294967295 & sec;
                return rv = new Uint8Array(8), (view = new DataView(rv.buffer)).setUint32(0, nsec << 2 | 3 & secHigh), view.setUint32(4, secLow), rv;
            }
            return rv = new Uint8Array(12), (view = new DataView(rv.buffer)).setUint32(0, nsec), setInt64(view, 4, sec), rv;
        }
        function encodeDateToTimeSpec(date) {
            var msec = date.getTime(), sec = Math.floor(msec / 1000), nsec = 1000000 * (msec - 1000 * sec), nsecInSec = Math.floor(nsec / 1000000000);
            return {
                sec: sec + nsecInSec,
                nsec: nsec - 1000000000 * nsecInSec
            };
        }
        function encodeTimestampExtension(object) {
            return object instanceof Date ? encodeTimeSpecToTimestamp(encodeDateToTimeSpec(object)) : null;
        }
        function decodeTimestampToTimeSpec(data) {
            var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
            switch (data.byteLength) {
            case 4:
                return {
                    sec: view.getUint32(0),
                    nsec: 0
                };
            case 8:
                var nsec30AndSecHigh2 = view.getUint32(0);
                return {
                    sec: 4294967296 * (3 & nsec30AndSecHigh2) + view.getUint32(4),
                    nsec: nsec30AndSecHigh2 >>> 2
                };
            case 12:
                return {
                    sec: getInt64(view, 4),
                    nsec: view.getUint32(0)
                };
            default:
                throw new DecodeError('Unrecognized data size for timestamp (expected 4, 8, or 12): '.concat(data.length));
            }
        }
        function decodeTimestampExtension(data) {
            var timeSpec = decodeTimestampToTimeSpec(data);
            return new Date(1000 * timeSpec.sec + timeSpec.nsec / 1000000);
        }
        var timestampExtension = {
                type: -1,
                encode: encodeTimestampExtension,
                decode: decodeTimestampExtension
            }, ExtensionCodec_ExtensionCodec = function () {
                function ExtensionCodec() {
                    this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(timestampExtension);
                }
                return ExtensionCodec.prototype.register = function (_a) {
                    var type = _a.type, encode = _a.encode, decode = _a.decode;
                    if (type >= 0)
                        this.encoders[type] = encode, this.decoders[type] = decode;
                    else {
                        var index = 1 + type;
                        this.builtInEncoders[index] = encode, this.builtInDecoders[index] = decode;
                    }
                }, ExtensionCodec.prototype.tryToEncode = function (object, context) {
                    for (var i = 0; i < this.builtInEncoders.length; i++)
                        if (null != (encodeExt = this.builtInEncoders[i]) && null != (data = encodeExt(object, context)))
                            return new ExtData(-1 - i, data);
                    for (i = 0; i < this.encoders.length; i++) {
                        var encodeExt, data;
                        if (null != (encodeExt = this.encoders[i]) && null != (data = encodeExt(object, context)))
                            return new ExtData(i, data);
                    }
                    return object instanceof ExtData ? object : null;
                }, ExtensionCodec.prototype.decode = function (data, type, context) {
                    var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
                    return decodeExt ? decodeExt(data, type, context) : new ExtData(type, data);
                }, ExtensionCodec.defaultCodec = new ExtensionCodec(), ExtensionCodec;
            }();
        function ensureUint8Array(buffer) {
            return buffer instanceof Uint8Array ? buffer : ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : Uint8Array.from(buffer);
        }
        var Encoder_Encoder = function () {
                function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {
                    void 0 === extensionCodec && (extensionCodec = ExtensionCodec_ExtensionCodec.defaultCodec), void 0 === context && (context = void 0), void 0 === maxDepth && (maxDepth = 100), void 0 === initialBufferSize && (initialBufferSize = 2048), void 0 === sortKeys && (sortKeys = !1), void 0 === forceFloat32 && (forceFloat32 = !1), void 0 === ignoreUndefined && (ignoreUndefined = !1), void 0 === forceIntegerToFloat && (forceIntegerToFloat = !1), this.extensionCodec = extensionCodec, this.context = context, this.maxDepth = maxDepth, this.initialBufferSize = initialBufferSize, this.sortKeys = sortKeys, this.forceFloat32 = forceFloat32, this.ignoreUndefined = ignoreUndefined, this.forceIntegerToFloat = forceIntegerToFloat, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
                }
                return Encoder.prototype.reinitializeState = function () {
                    this.pos = 0;
                }, Encoder.prototype.encodeSharedRef = function (object) {
                    return this.reinitializeState(), this.doEncode(object, 1), this.bytes.subarray(0, this.pos);
                }, Encoder.prototype.encode = function (object) {
                    return this.reinitializeState(), this.doEncode(object, 1), this.bytes.slice(0, this.pos);
                }, Encoder.prototype.doEncode = function (object, depth) {
                    if (depth > this.maxDepth)
                        throw new Error('Too deep objects in depth '.concat(depth));
                    null == object ? this.encodeNil() : 'boolean' == typeof object ? this.encodeBoolean(object) : 'number' == typeof object ? this.encodeNumber(object) : 'string' == typeof object ? this.encodeString(object) : this.encodeObject(object, depth);
                }, Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {
                    var requiredSize = this.pos + sizeToWrite;
                    this.view.byteLength < requiredSize && this.resizeBuffer(2 * requiredSize);
                }, Encoder.prototype.resizeBuffer = function (newSize) {
                    var newBuffer = new ArrayBuffer(newSize), newBytes = new Uint8Array(newBuffer), newView = new DataView(newBuffer);
                    newBytes.set(this.bytes), this.view = newView, this.bytes = newBytes;
                }, Encoder.prototype.encodeNil = function () {
                    this.writeU8(192);
                }, Encoder.prototype.encodeBoolean = function (object) {
                    !1 === object ? this.writeU8(194) : this.writeU8(195);
                }, Encoder.prototype.encodeNumber = function (object) {
                    Number.isSafeInteger(object) && !this.forceIntegerToFloat ? object >= 0 ? object < 128 ? this.writeU8(object) : object < 256 ? (this.writeU8(204), this.writeU8(object)) : object < 65536 ? (this.writeU8(205), this.writeU16(object)) : object < 4294967296 ? (this.writeU8(206), this.writeU32(object)) : (this.writeU8(207), this.writeU64(object)) : object >= -32 ? this.writeU8(224 | object + 32) : object >= -128 ? (this.writeU8(208), this.writeI8(object)) : object >= -32768 ? (this.writeU8(209), this.writeI16(object)) : object >= -2147483648 ? (this.writeU8(210), this.writeI32(object)) : (this.writeU8(211), this.writeI64(object)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(object)) : (this.writeU8(203), this.writeF64(object));
                }, Encoder.prototype.writeStringHeader = function (byteLength) {
                    if (byteLength < 32)
                        this.writeU8(160 + byteLength);
                    else if (byteLength < 256)
                        this.writeU8(217), this.writeU8(byteLength);
                    else if (byteLength < 65536)
                        this.writeU8(218), this.writeU16(byteLength);
                    else {
                        if (!(byteLength < 4294967296))
                            throw new Error('Too long string: '.concat(byteLength, ' bytes in UTF-8'));
                        this.writeU8(219), this.writeU32(byteLength);
                    }
                }, Encoder.prototype.encodeString = function (object) {
                    if (object.length > TEXT_ENCODER_THRESHOLD) {
                        var byteLength = utf8Count(object);
                        this.ensureBufferSizeToWrite(5 + byteLength), this.writeStringHeader(byteLength), utf8EncodeTE(object, this.bytes, this.pos), this.pos += byteLength;
                    } else
                        byteLength = utf8Count(object), this.ensureBufferSizeToWrite(5 + byteLength), this.writeStringHeader(byteLength), function (str, output, outputOffset) {
                            for (var strLength = str.length, offset = outputOffset, pos = 0; pos < strLength;) {
                                var value = str.charCodeAt(pos++);
                                if (0 != (4294967168 & value)) {
                                    if (0 == (4294965248 & value))
                                        output[offset++] = value >> 6 & 31 | 192;
                                    else {
                                        if (value >= 55296 && value <= 56319 && pos < strLength) {
                                            var extra = str.charCodeAt(pos);
                                            56320 == (64512 & extra) && (++pos, value = ((1023 & value) << 10) + (1023 & extra) + 65536);
                                        }
                                        0 == (4294901760 & value) ? (output[offset++] = value >> 12 & 15 | 224, output[offset++] = value >> 6 & 63 | 128) : (output[offset++] = value >> 18 & 7 | 240, output[offset++] = value >> 12 & 63 | 128, output[offset++] = value >> 6 & 63 | 128);
                                    }
                                    output[offset++] = 63 & value | 128;
                                } else
                                    output[offset++] = value;
                            }
                        }(object, this.bytes, this.pos), this.pos += byteLength;
                }, Encoder.prototype.encodeObject = function (object, depth) {
                    var ext = this.extensionCodec.tryToEncode(object, this.context);
                    if (null != ext)
                        this.encodeExtension(ext);
                    else if (Array.isArray(object))
                        this.encodeArray(object, depth);
                    else if (ArrayBuffer.isView(object))
                        this.encodeBinary(object);
                    else {
                        if ('object' != typeof object)
                            throw new Error('Unrecognized object: '.concat(Object.prototype.toString.apply(object)));
                        this.encodeMap(object, depth);
                    }
                }, Encoder.prototype.encodeBinary = function (object) {
                    var size = object.byteLength;
                    if (size < 256)
                        this.writeU8(196), this.writeU8(size);
                    else if (size < 65536)
                        this.writeU8(197), this.writeU16(size);
                    else {
                        if (!(size < 4294967296))
                            throw new Error('Too large binary: '.concat(size));
                        this.writeU8(198), this.writeU32(size);
                    }
                    var bytes = ensureUint8Array(object);
                    this.writeU8a(bytes);
                }, Encoder.prototype.encodeArray = function (object, depth) {
                    var size = object.length;
                    if (size < 16)
                        this.writeU8(144 + size);
                    else if (size < 65536)
                        this.writeU8(220), this.writeU16(size);
                    else {
                        if (!(size < 4294967296))
                            throw new Error('Too large array: '.concat(size));
                        this.writeU8(221), this.writeU32(size);
                    }
                    for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
                        var item = object_1[_i];
                        this.doEncode(item, depth + 1);
                    }
                }, Encoder.prototype.countWithoutUndefined = function (object, keys) {
                    for (var count = 0, _i = 0, keys_1 = keys; _i < keys_1.length; _i++)
                        void 0 !== object[keys_1[_i]] && count++;
                    return count;
                }, Encoder.prototype.encodeMap = function (object, depth) {
                    var keys = Object.keys(object);
                    this.sortKeys && keys.sort();
                    var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
                    if (size < 16)
                        this.writeU8(128 + size);
                    else if (size < 65536)
                        this.writeU8(222), this.writeU16(size);
                    else {
                        if (!(size < 4294967296))
                            throw new Error('Too large map object: '.concat(size));
                        this.writeU8(223), this.writeU32(size);
                    }
                    for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                        var key = keys_2[_i], value = object[key];
                        this.ignoreUndefined && void 0 === value || (this.encodeString(key), this.doEncode(value, depth + 1));
                    }
                }, Encoder.prototype.encodeExtension = function (ext) {
                    var size = ext.data.length;
                    if (1 === size)
                        this.writeU8(212);
                    else if (2 === size)
                        this.writeU8(213);
                    else if (4 === size)
                        this.writeU8(214);
                    else if (8 === size)
                        this.writeU8(215);
                    else if (16 === size)
                        this.writeU8(216);
                    else if (size < 256)
                        this.writeU8(199), this.writeU8(size);
                    else if (size < 65536)
                        this.writeU8(200), this.writeU16(size);
                    else {
                        if (!(size < 4294967296))
                            throw new Error('Too large extension object: '.concat(size));
                        this.writeU8(201), this.writeU32(size);
                    }
                    this.writeI8(ext.type), this.writeU8a(ext.data);
                }, Encoder.prototype.writeU8 = function (value) {
                    this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, value), this.pos++;
                }, Encoder.prototype.writeU8a = function (values) {
                    var size = values.length;
                    this.ensureBufferSizeToWrite(size), this.bytes.set(values, this.pos), this.pos += size;
                }, Encoder.prototype.writeI8 = function (value) {
                    this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, value), this.pos++;
                }, Encoder.prototype.writeU16 = function (value) {
                    this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, value), this.pos += 2;
                }, Encoder.prototype.writeI16 = function (value) {
                    this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, value), this.pos += 2;
                }, Encoder.prototype.writeU32 = function (value) {
                    this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, value), this.pos += 4;
                }, Encoder.prototype.writeI32 = function (value) {
                    this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, value), this.pos += 4;
                }, Encoder.prototype.writeF32 = function (value) {
                    this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, value), this.pos += 4;
                }, Encoder.prototype.writeF64 = function (value) {
                    this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, value), this.pos += 8;
                }, Encoder.prototype.writeU64 = function (value) {
                    this.ensureBufferSizeToWrite(8), function (view, offset, value) {
                        var high = value / 4294967296, low = value;
                        view.setUint32(offset, high), view.setUint32(offset + 4, low);
                    }(this.view, this.pos, value), this.pos += 8;
                }, Encoder.prototype.writeI64 = function (value) {
                    this.ensureBufferSizeToWrite(8), setInt64(this.view, this.pos, value), this.pos += 8;
                }, Encoder;
            }(), defaultEncodeOptions = {};
        function encode(value, options) {
            return void 0 === options && (options = defaultEncodeOptions), new Encoder_Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat).encodeSharedRef(value);
        }
        function prettyByte(byte) {
            return ''.concat(byte < 0 ? '-' : '', '0x').concat(Math.abs(byte).toString(16).padStart(2, '0'));
        }
        var CachedKeyDecoder_CachedKeyDecoder = function () {
                function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {
                    void 0 === maxKeyLength && (maxKeyLength = 16), void 0 === maxLengthPerKey && (maxLengthPerKey = 16), this.maxKeyLength = maxKeyLength, this.maxLengthPerKey = maxLengthPerKey, this.hit = 0, this.miss = 0, this.caches = [];
                    for (var i = 0; i < this.maxKeyLength; i++)
                        this.caches.push([]);
                }
                return CachedKeyDecoder.prototype.canBeCached = function (byteLength) {
                    return byteLength > 0 && byteLength <= this.maxKeyLength;
                }, CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {
                    e:
                        for (var _i = 0, records_1 = this.caches[byteLength - 1]; _i < records_1.length; _i++) {
                            for (var record = records_1[_i], recordBytes = record.bytes, j = 0; j < byteLength; j++)
                                if (recordBytes[j] !== bytes[inputOffset + j])
                                    continue e;
                            return record.str;
                        }
                    return null;
                }, CachedKeyDecoder.prototype.store = function (bytes, value) {
                    var records = this.caches[bytes.length - 1], record = {
                            bytes: bytes,
                            str: value
                        };
                    records.length >= this.maxLengthPerKey ? records[Math.random() * records.length | 0] = record : records.push(record);
                }, CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {
                    var cachedValue = this.find(bytes, inputOffset, byteLength);
                    if (null != cachedValue)
                        return this.hit++, cachedValue;
                    this.miss++;
                    var str = utf8DecodeJs(bytes, inputOffset, byteLength), slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
                    return this.store(slicedCopyOfBytes, str), str;
                }, CachedKeyDecoder;
            }(), __generator = function (thisArg, body) {
                var f, y, t, g, _ = {
                        label: 0,
                        sent: function () {
                            if (1 & t[0])
                                throw t[1];
                            return t[1];
                        },
                        trys: [],
                        ops: []
                    };
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, 'function' == typeof Symbol && (g[Symbol.iterator] = function () {
                    return this;
                }), g;
                function verb(n) {
                    return function (v) {
                        return function (op) {
                            if (f)
                                throw new TypeError('Generator is already executing.');
                            for (; _;)
                                try {
                                    if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                                        return t;
                                    switch (y = 0, t && (op = [
                                            2 & op[0],
                                            t.value
                                        ]), op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        return _.label++, {
                                            value: op[1],
                                            done: !1
                                        };
                                    case 5:
                                        _.label++, y = op[1], op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop(), _.trys.pop();
                                        continue;
                                    default:
                                        if (!(t = (t = _.trys).length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (6 === op[0] && _.label < t[1]) {
                                            _.label = t[1], t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2], _.ops.push(op);
                                            break;
                                        }
                                        t[2] && _.ops.pop(), _.trys.pop();
                                        continue;
                                    }
                                    op = body.call(thisArg, _);
                                } catch (e) {
                                    op = [
                                        6,
                                        e
                                    ], y = 0;
                                } finally {
                                    f = t = 0;
                                }
                            if (5 & op[0])
                                throw op[1];
                            return {
                                value: op[0] ? op[1] : void 0,
                                done: !0
                            };
                        }([
                            n,
                            v
                        ]);
                    };
                }
            }, __asyncValues = function (o) {
                if (!Symbol.asyncIterator)
                    throw new TypeError('Symbol.asyncIterator is not defined.');
                var i, m = o[Symbol.asyncIterator];
                return m ? m.call(o) : (o = 'function' == typeof __values ? __values(o) : o[Symbol.iterator](), i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
                    return this;
                }, i);
                function verb(n) {
                    i[n] = o[n] && function (v) {
                        return new Promise(function (resolve, reject) {
                            !function (resolve, reject, d, v) {
                                Promise.resolve(v).then(function (v) {
                                    resolve({
                                        value: v,
                                        done: d
                                    });
                                }, reject);
                            }(resolve, reject, (v = o[n](v)).done, v.value);
                        });
                    };
                }
            }, __await = function (v) {
                return this instanceof __await ? (this.v = v, this) : new __await(v);
            }, __asyncGenerator = function (thisArg, _arguments, generator) {
                if (!Symbol.asyncIterator)
                    throw new TypeError('Symbol.asyncIterator is not defined.');
                var i, g = generator.apply(thisArg, _arguments || []), q = [];
                return i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
                    return this;
                }, i;
                function verb(n) {
                    g[n] && (i[n] = function (v) {
                        return new Promise(function (a, b) {
                            q.push([
                                n,
                                v,
                                a,
                                b
                            ]) > 1 || resume(n, v);
                        });
                    });
                }
                function resume(n, v) {
                    try {
                        !function (r) {
                            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
                        }(g[n](v));
                    } catch (e) {
                        settle(q[0][3], e);
                    }
                }
                function fulfill(value) {
                    resume('next', value);
                }
                function reject(value) {
                    resume('throw', value);
                }
                function settle(f, v) {
                    f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
                }
            }, isValidMapKeyType = function (key) {
                var keyType = typeof key;
                return 'string' === keyType || 'number' === keyType;
            }, EMPTY_VIEW = new DataView(new ArrayBuffer(0)), EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer), DataViewIndexOutOfBoundsError = function () {
                try {
                    EMPTY_VIEW.getInt8(0);
                } catch (e) {
                    return e.constructor;
                }
                throw new Error('never reached');
            }(), MORE_DATA = new DataViewIndexOutOfBoundsError('Insufficient data'), sharedCachedKeyDecoder = new CachedKeyDecoder_CachedKeyDecoder(), Decoder_Decoder = function () {
                function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {
                    void 0 === extensionCodec && (extensionCodec = ExtensionCodec_ExtensionCodec.defaultCodec), void 0 === context && (context = void 0), void 0 === maxStrLength && (maxStrLength = UINT32_MAX), void 0 === maxBinLength && (maxBinLength = UINT32_MAX), void 0 === maxArrayLength && (maxArrayLength = UINT32_MAX), void 0 === maxMapLength && (maxMapLength = UINT32_MAX), void 0 === maxExtLength && (maxExtLength = UINT32_MAX), void 0 === keyDecoder && (keyDecoder = sharedCachedKeyDecoder), this.extensionCodec = extensionCodec, this.context = context, this.maxStrLength = maxStrLength, this.maxBinLength = maxBinLength, this.maxArrayLength = maxArrayLength, this.maxMapLength = maxMapLength, this.maxExtLength = maxExtLength, this.keyDecoder = keyDecoder, this.totalPos = 0, this.pos = 0, this.view = EMPTY_VIEW, this.bytes = EMPTY_BYTES, this.headByte = -1, this.stack = [];
                }
                return Decoder.prototype.reinitializeState = function () {
                    this.totalPos = 0, this.headByte = -1, this.stack.length = 0;
                }, Decoder.prototype.setBuffer = function (buffer) {
                    this.bytes = ensureUint8Array(buffer), this.view = function (buffer) {
                        if (buffer instanceof ArrayBuffer)
                            return new DataView(buffer);
                        var bufferView = ensureUint8Array(buffer);
                        return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
                    }(this.bytes), this.pos = 0;
                }, Decoder.prototype.appendBuffer = function (buffer) {
                    if (-1 !== this.headByte || this.hasRemaining(1)) {
                        var remainingData = this.bytes.subarray(this.pos), newData = ensureUint8Array(buffer), newBuffer = new Uint8Array(remainingData.length + newData.length);
                        newBuffer.set(remainingData), newBuffer.set(newData, remainingData.length), this.setBuffer(newBuffer);
                    } else
                        this.setBuffer(buffer);
                }, Decoder.prototype.hasRemaining = function (size) {
                    return this.view.byteLength - this.pos >= size;
                }, Decoder.prototype.createExtraByteError = function (posToShow) {
                    var view = this.view, pos = this.pos;
                    return new RangeError('Extra '.concat(view.byteLength - pos, ' of ').concat(view.byteLength, ' byte(s) found at buffer[').concat(posToShow, ']'));
                }, Decoder.prototype.decode = function (buffer) {
                    this.reinitializeState(), this.setBuffer(buffer);
                    var object = this.doDecodeSync();
                    if (this.hasRemaining(1))
                        throw this.createExtraByteError(this.pos);
                    return object;
                }, Decoder.prototype.decodeMulti = function (buffer) {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                        case 0:
                            this.reinitializeState(), this.setBuffer(buffer), _a.label = 1;
                        case 1:
                            return this.hasRemaining(1) ? [
                                4,
                                this.doDecodeSync()
                            ] : [
                                3,
                                3
                            ];
                        case 2:
                            return _a.sent(), [
                                3,
                                1
                            ];
                        case 3:
                            return [2];
                        }
                    });
                }, Decoder.prototype.decodeAsync = function (stream) {
                    var stream_1, stream_1_1, e_1, _a;
                    return function (thisArg, _arguments, P, generator) {
                        return new (P || (P = Promise))(function (resolve, reject) {
                            function fulfilled(value) {
                                try {
                                    step(generator.next(value));
                                } catch (e) {
                                    reject(e);
                                }
                            }
                            function rejected(value) {
                                try {
                                    step(generator.throw(value));
                                } catch (e) {
                                    reject(e);
                                }
                            }
                            function step(result) {
                                result.done ? resolve(result.value) : function (value) {
                                    return value instanceof P ? value : new P(function (resolve) {
                                        resolve(value);
                                    });
                                }(result.value).then(fulfilled, rejected);
                            }
                            step((generator = generator.apply(thisArg, _arguments || [])).next());
                        });
                    }(this, void 0, void 0, function () {
                        var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                            case 0:
                                decoded = !1, _c.label = 1;
                            case 1:
                                _c.trys.push([
                                    1,
                                    6,
                                    7,
                                    12
                                ]), stream_1 = __asyncValues(stream), _c.label = 2;
                            case 2:
                                return [
                                    4,
                                    stream_1.next()
                                ];
                            case 3:
                                if ((stream_1_1 = _c.sent()).done)
                                    return [
                                        3,
                                        5
                                    ];
                                if (buffer = stream_1_1.value, decoded)
                                    throw this.createExtraByteError(this.totalPos);
                                this.appendBuffer(buffer);
                                try {
                                    object = this.doDecodeSync(), decoded = !0;
                                } catch (e) {
                                    if (!(e instanceof DataViewIndexOutOfBoundsError))
                                        throw e;
                                }
                                this.totalPos += this.pos, _c.label = 4;
                            case 4:
                                return [
                                    3,
                                    2
                                ];
                            case 5:
                                return [
                                    3,
                                    12
                                ];
                            case 6:
                                return e_1_1 = _c.sent(), e_1 = { error: e_1_1 }, [
                                    3,
                                    12
                                ];
                            case 7:
                                return _c.trys.push([
                                    7,
                                    ,
                                    10,
                                    11
                                ]), stream_1_1 && !stream_1_1.done && (_a = stream_1.return) ? [
                                    4,
                                    _a.call(stream_1)
                                ] : [
                                    3,
                                    9
                                ];
                            case 8:
                                _c.sent(), _c.label = 9;
                            case 9:
                                return [
                                    3,
                                    11
                                ];
                            case 10:
                                if (e_1)
                                    throw e_1.error;
                                return [7];
                            case 11:
                                return [7];
                            case 12:
                                if (decoded) {
                                    if (this.hasRemaining(1))
                                        throw this.createExtraByteError(this.totalPos);
                                    return [
                                        2,
                                        object
                                    ];
                                }
                                throw headByte = (_b = this).headByte, pos = _b.pos, totalPos = _b.totalPos, new RangeError('Insufficient data in parsing '.concat(prettyByte(headByte), ' at ').concat(totalPos, ' (').concat(pos, ' in the current buffer)'));
                            }
                        });
                    });
                }, Decoder.prototype.decodeArrayStream = function (stream) {
                    return this.decodeMultiAsync(stream, !0);
                }, Decoder.prototype.decodeStream = function (stream) {
                    return this.decodeMultiAsync(stream, !1);
                }, Decoder.prototype.decodeMultiAsync = function (stream, isArray) {
                    return __asyncGenerator(this, arguments, function () {
                        var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1, e_3, _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                            case 0:
                                isArrayHeaderRequired = isArray, arrayItemsLeft = -1, _b.label = 1;
                            case 1:
                                _b.trys.push([
                                    1,
                                    13,
                                    14,
                                    19
                                ]), stream_2 = __asyncValues(stream), _b.label = 2;
                            case 2:
                                return [
                                    4,
                                    __await(stream_2.next())
                                ];
                            case 3:
                                if ((stream_2_1 = _b.sent()).done)
                                    return [
                                        3,
                                        12
                                    ];
                                if (buffer = stream_2_1.value, isArray && 0 === arrayItemsLeft)
                                    throw this.createExtraByteError(this.totalPos);
                                this.appendBuffer(buffer), isArrayHeaderRequired && (arrayItemsLeft = this.readArraySize(), isArrayHeaderRequired = !1, this.complete()), _b.label = 4;
                            case 4:
                                _b.trys.push([
                                    4,
                                    9,
                                    ,
                                    10
                                ]), _b.label = 5;
                            case 5:
                                return [
                                    4,
                                    __await(this.doDecodeSync())
                                ];
                            case 6:
                                return [
                                    4,
                                    _b.sent()
                                ];
                            case 7:
                                return _b.sent(), 0 == --arrayItemsLeft ? [
                                    3,
                                    8
                                ] : [
                                    3,
                                    5
                                ];
                            case 8:
                                return [
                                    3,
                                    10
                                ];
                            case 9:
                                if (!((e_2 = _b.sent()) instanceof DataViewIndexOutOfBoundsError))
                                    throw e_2;
                                return [
                                    3,
                                    10
                                ];
                            case 10:
                                this.totalPos += this.pos, _b.label = 11;
                            case 11:
                                return [
                                    3,
                                    2
                                ];
                            case 12:
                                return [
                                    3,
                                    19
                                ];
                            case 13:
                                return e_3_1 = _b.sent(), e_3 = { error: e_3_1 }, [
                                    3,
                                    19
                                ];
                            case 14:
                                return _b.trys.push([
                                    14,
                                    ,
                                    17,
                                    18
                                ]), stream_2_1 && !stream_2_1.done && (_a = stream_2.return) ? [
                                    4,
                                    __await(_a.call(stream_2))
                                ] : [
                                    3,
                                    16
                                ];
                            case 15:
                                _b.sent(), _b.label = 16;
                            case 16:
                                return [
                                    3,
                                    18
                                ];
                            case 17:
                                if (e_3)
                                    throw e_3.error;
                                return [7];
                            case 18:
                                return [7];
                            case 19:
                                return [2];
                            }
                        });
                    });
                }, Decoder.prototype.doDecodeSync = function () {
                    e:
                        for (;;) {
                            var headByte = this.readHeadByte(), object = void 0;
                            if (headByte >= 224)
                                object = headByte - 256;
                            else if (headByte < 192)
                                if (headByte < 128)
                                    object = headByte;
                                else if (headByte < 144) {
                                    if (0 != (size = headByte - 128)) {
                                        this.pushMapState(size), this.complete();
                                        continue e;
                                    }
                                    object = {};
                                } else if (headByte < 160) {
                                    if (0 != (size = headByte - 144)) {
                                        this.pushArrayState(size), this.complete();
                                        continue e;
                                    }
                                    object = [];
                                } else {
                                    var byteLength = headByte - 160;
                                    object = this.decodeUtf8String(byteLength, 0);
                                }
                            else if (192 === headByte)
                                object = null;
                            else if (194 === headByte)
                                object = !1;
                            else if (195 === headByte)
                                object = !0;
                            else if (202 === headByte)
                                object = this.readF32();
                            else if (203 === headByte)
                                object = this.readF64();
                            else if (204 === headByte)
                                object = this.readU8();
                            else if (205 === headByte)
                                object = this.readU16();
                            else if (206 === headByte)
                                object = this.readU32();
                            else if (207 === headByte)
                                object = this.readU64();
                            else if (208 === headByte)
                                object = this.readI8();
                            else if (209 === headByte)
                                object = this.readI16();
                            else if (210 === headByte)
                                object = this.readI32();
                            else if (211 === headByte)
                                object = this.readI64();
                            else if (217 === headByte)
                                byteLength = this.lookU8(), object = this.decodeUtf8String(byteLength, 1);
                            else if (218 === headByte)
                                byteLength = this.lookU16(), object = this.decodeUtf8String(byteLength, 2);
                            else if (219 === headByte)
                                byteLength = this.lookU32(), object = this.decodeUtf8String(byteLength, 4);
                            else if (220 === headByte) {
                                if (0 !== (size = this.readU16())) {
                                    this.pushArrayState(size), this.complete();
                                    continue e;
                                }
                                object = [];
                            } else if (221 === headByte) {
                                if (0 !== (size = this.readU32())) {
                                    this.pushArrayState(size), this.complete();
                                    continue e;
                                }
                                object = [];
                            } else if (222 === headByte) {
                                if (0 !== (size = this.readU16())) {
                                    this.pushMapState(size), this.complete();
                                    continue e;
                                }
                                object = {};
                            } else if (223 === headByte) {
                                if (0 !== (size = this.readU32())) {
                                    this.pushMapState(size), this.complete();
                                    continue e;
                                }
                                object = {};
                            } else if (196 === headByte) {
                                var size = this.lookU8();
                                object = this.decodeBinary(size, 1);
                            } else if (197 === headByte)
                                size = this.lookU16(), object = this.decodeBinary(size, 2);
                            else if (198 === headByte)
                                size = this.lookU32(), object = this.decodeBinary(size, 4);
                            else if (212 === headByte)
                                object = this.decodeExtension(1, 0);
                            else if (213 === headByte)
                                object = this.decodeExtension(2, 0);
                            else if (214 === headByte)
                                object = this.decodeExtension(4, 0);
                            else if (215 === headByte)
                                object = this.decodeExtension(8, 0);
                            else if (216 === headByte)
                                object = this.decodeExtension(16, 0);
                            else if (199 === headByte)
                                size = this.lookU8(), object = this.decodeExtension(size, 1);
                            else if (200 === headByte)
                                size = this.lookU16(), object = this.decodeExtension(size, 2);
                            else {
                                if (201 !== headByte)
                                    throw new DecodeError('Unrecognized type byte: '.concat(prettyByte(headByte)));
                                size = this.lookU32(), object = this.decodeExtension(size, 4);
                            }
                            this.complete();
                            for (var stack = this.stack; stack.length > 0;) {
                                var state = stack[stack.length - 1];
                                if (0 === state.type) {
                                    if (state.array[state.position] = object, state.position++, state.position !== state.size)
                                        continue e;
                                    stack.pop(), object = state.array;
                                } else {
                                    if (1 === state.type) {
                                        if (!isValidMapKeyType(object))
                                            throw new DecodeError('The type of key must be string or number but ' + typeof object);
                                        if ('__proto__' === object)
                                            throw new DecodeError('The key __proto__ is not allowed');
                                        state.key = object, state.type = 2;
                                        continue e;
                                    }
                                    if (state.map[state.key] = object, state.readCount++, state.readCount !== state.size) {
                                        state.key = null, state.type = 1;
                                        continue e;
                                    }
                                    stack.pop(), object = state.map;
                                }
                            }
                            return object;
                        }
                }, Decoder.prototype.readHeadByte = function () {
                    return -1 === this.headByte && (this.headByte = this.readU8()), this.headByte;
                }, Decoder.prototype.complete = function () {
                    this.headByte = -1;
                }, Decoder.prototype.readArraySize = function () {
                    var headByte = this.readHeadByte();
                    switch (headByte) {
                    case 220:
                        return this.readU16();
                    case 221:
                        return this.readU32();
                    default:
                        if (headByte < 160)
                            return headByte - 144;
                        throw new DecodeError('Unrecognized array type byte: '.concat(prettyByte(headByte)));
                    }
                }, Decoder.prototype.pushMapState = function (size) {
                    if (size > this.maxMapLength)
                        throw new DecodeError('Max length exceeded: map length ('.concat(size, ') > maxMapLengthLength (').concat(this.maxMapLength, ')'));
                    this.stack.push({
                        type: 1,
                        size: size,
                        key: null,
                        readCount: 0,
                        map: {}
                    });
                }, Decoder.prototype.pushArrayState = function (size) {
                    if (size > this.maxArrayLength)
                        throw new DecodeError('Max length exceeded: array length ('.concat(size, ') > maxArrayLength (').concat(this.maxArrayLength, ')'));
                    this.stack.push({
                        type: 0,
                        size: size,
                        array: new Array(size),
                        position: 0
                    });
                }, Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {
                    var _a;
                    if (byteLength > this.maxStrLength)
                        throw new DecodeError('Max length exceeded: UTF-8 byte length ('.concat(byteLength, ') > maxStrLength (').concat(this.maxStrLength, ')'));
                    if (this.bytes.byteLength < this.pos + headerOffset + byteLength)
                        throw MORE_DATA;
                    var object, offset = this.pos + headerOffset;
                    return object = this.stateIsMapKey() && (null === (_a = this.keyDecoder) || void 0 === _a ? void 0 : _a.canBeCached(byteLength)) ? this.keyDecoder.decode(this.bytes, offset, byteLength) : byteLength > TEXT_DECODER_THRESHOLD ? function (bytes, inputOffset, byteLength) {
                        var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
                        return sharedTextDecoder.decode(stringBytes);
                    }(this.bytes, offset, byteLength) : utf8DecodeJs(this.bytes, offset, byteLength), this.pos += headerOffset + byteLength, object;
                }, Decoder.prototype.stateIsMapKey = function () {
                    return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type;
                }, Decoder.prototype.decodeBinary = function (byteLength, headOffset) {
                    if (byteLength > this.maxBinLength)
                        throw new DecodeError('Max length exceeded: bin length ('.concat(byteLength, ') > maxBinLength (').concat(this.maxBinLength, ')'));
                    if (!this.hasRemaining(byteLength + headOffset))
                        throw MORE_DATA;
                    var offset = this.pos + headOffset, object = this.bytes.subarray(offset, offset + byteLength);
                    return this.pos += headOffset + byteLength, object;
                }, Decoder.prototype.decodeExtension = function (size, headOffset) {
                    if (size > this.maxExtLength)
                        throw new DecodeError('Max length exceeded: ext length ('.concat(size, ') > maxExtLength (').concat(this.maxExtLength, ')'));
                    var extType = this.view.getInt8(this.pos + headOffset), data = this.decodeBinary(size, headOffset + 1);
                    return this.extensionCodec.decode(data, extType, this.context);
                }, Decoder.prototype.lookU8 = function () {
                    return this.view.getUint8(this.pos);
                }, Decoder.prototype.lookU16 = function () {
                    return this.view.getUint16(this.pos);
                }, Decoder.prototype.lookU32 = function () {
                    return this.view.getUint32(this.pos);
                }, Decoder.prototype.readU8 = function () {
                    var value = this.view.getUint8(this.pos);
                    return this.pos++, value;
                }, Decoder.prototype.readI8 = function () {
                    var value = this.view.getInt8(this.pos);
                    return this.pos++, value;
                }, Decoder.prototype.readU16 = function () {
                    var value = this.view.getUint16(this.pos);
                    return this.pos += 2, value;
                }, Decoder.prototype.readI16 = function () {
                    var value = this.view.getInt16(this.pos);
                    return this.pos += 2, value;
                }, Decoder.prototype.readU32 = function () {
                    var value = this.view.getUint32(this.pos);
                    return this.pos += 4, value;
                }, Decoder.prototype.readI32 = function () {
                    var value = this.view.getInt32(this.pos);
                    return this.pos += 4, value;
                }, Decoder.prototype.readU64 = function () {
                    var value = function (view, offset) {
                        return 4294967296 * view.getUint32(offset) + view.getUint32(offset + 4);
                    }(this.view, this.pos);
                    return this.pos += 8, value;
                }, Decoder.prototype.readI64 = function () {
                    var value = getInt64(this.view, this.pos);
                    return this.pos += 8, value;
                }, Decoder.prototype.readF32 = function () {
                    var value = this.view.getFloat32(this.pos);
                    return this.pos += 4, value;
                }, Decoder.prototype.readF64 = function () {
                    var value = this.view.getFloat64(this.pos);
                    return this.pos += 8, value;
                }, Decoder;
            }(), defaultDecodeOptions = {};
        function decode(buffer, options) {
            return void 0 === options && (options = defaultDecodeOptions), new Decoder_Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength).decode(buffer);
        }
        function decodeMulti(buffer, options) {
            return void 0 === options && (options = defaultDecodeOptions), new Decoder_Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength).decodeMulti(buffer);
        }
        var stream_generator = function (thisArg, body) {
                var f, y, t, g, _ = {
                        label: 0,
                        sent: function () {
                            if (1 & t[0])
                                throw t[1];
                            return t[1];
                        },
                        trys: [],
                        ops: []
                    };
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, 'function' == typeof Symbol && (g[Symbol.iterator] = function () {
                    return this;
                }), g;
                function verb(n) {
                    return function (v) {
                        return function (op) {
                            if (f)
                                throw new TypeError('Generator is already executing.');
                            for (; _;)
                                try {
                                    if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                                        return t;
                                    switch (y = 0, t && (op = [
                                            2 & op[0],
                                            t.value
                                        ]), op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        return _.label++, {
                                            value: op[1],
                                            done: !1
                                        };
                                    case 5:
                                        _.label++, y = op[1], op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop(), _.trys.pop();
                                        continue;
                                    default:
                                        if (!(t = (t = _.trys).length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (6 === op[0] && _.label < t[1]) {
                                            _.label = t[1], t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2], _.ops.push(op);
                                            break;
                                        }
                                        t[2] && _.ops.pop(), _.trys.pop();
                                        continue;
                                    }
                                    op = body.call(thisArg, _);
                                } catch (e) {
                                    op = [
                                        6,
                                        e
                                    ], y = 0;
                                } finally {
                                    f = t = 0;
                                }
                            if (5 & op[0])
                                throw op[1];
                            return {
                                value: op[0] ? op[1] : void 0,
                                done: !0
                            };
                        }([
                            n,
                            v
                        ]);
                    };
                }
            }, stream_await = function (v) {
                return this instanceof stream_await ? (this.v = v, this) : new stream_await(v);
            }, stream_asyncGenerator = function (thisArg, _arguments, generator) {
                if (!Symbol.asyncIterator)
                    throw new TypeError('Symbol.asyncIterator is not defined.');
                var i, g = generator.apply(thisArg, _arguments || []), q = [];
                return i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
                    return this;
                }, i;
                function verb(n) {
                    g[n] && (i[n] = function (v) {
                        return new Promise(function (a, b) {
                            q.push([
                                n,
                                v,
                                a,
                                b
                            ]) > 1 || resume(n, v);
                        });
                    });
                }
                function resume(n, v) {
                    try {
                        !function (r) {
                            r.value instanceof stream_await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
                        }(g[n](v));
                    } catch (e) {
                        settle(q[0][3], e);
                    }
                }
                function fulfill(value) {
                    resume('next', value);
                }
                function reject(value) {
                    resume('throw', value);
                }
                function settle(f, v) {
                    f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
                }
            };
        function ensureAsyncIterable(streamLike) {
            return function (object) {
                return null != object[Symbol.asyncIterator];
            }(streamLike) ? streamLike : function (stream) {
                return stream_asyncGenerator(this, arguments, function () {
                    var reader, _a, done, value;
                    return stream_generator(this, function (_b) {
                        switch (_b.label) {
                        case 0:
                            reader = stream.getReader(), _b.label = 1;
                        case 1:
                            _b.trys.push([
                                1,
                                ,
                                9,
                                10
                            ]), _b.label = 2;
                        case 2:
                            return [
                                4,
                                stream_await(reader.read())
                            ];
                        case 3:
                            return _a = _b.sent(), done = _a.done, value = _a.value, done ? [
                                4,
                                stream_await(void 0)
                            ] : [
                                3,
                                5
                            ];
                        case 4:
                            return [
                                2,
                                _b.sent()
                            ];
                        case 5:
                            return function (value) {
                                if (null == value)
                                    throw new Error('Assertion Failure: value must not be null nor undefined');
                            }(value), [
                                4,
                                stream_await(value)
                            ];
                        case 6:
                            return [
                                4,
                                _b.sent()
                            ];
                        case 7:
                            return _b.sent(), [
                                3,
                                2
                            ];
                        case 8:
                            return [
                                3,
                                10
                            ];
                        case 9:
                            return reader.releaseLock(), [7];
                        case 10:
                            return [2];
                        }
                    });
                });
            }(streamLike);
        }
        function decodeAsync(streamLike, options) {
            return void 0 === options && (options = defaultDecodeOptions), function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value));
                        } catch (e) {
                            reject(e);
                        }
                    }
                    function rejected(value) {
                        try {
                            step(generator.throw(value));
                        } catch (e) {
                            reject(e);
                        }
                    }
                    function step(result) {
                        result.done ? resolve(result.value) : function (value) {
                            return value instanceof P ? value : new P(function (resolve) {
                                resolve(value);
                            });
                        }(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            }(this, void 0, void 0, function () {
                var stream;
                return function (thisArg, body) {
                    var f, y, t, g, _ = {
                            label: 0,
                            sent: function () {
                                if (1 & t[0])
                                    throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        };
                    return g = {
                        next: verb(0),
                        throw: verb(1),
                        return: verb(2)
                    }, 'function' == typeof Symbol && (g[Symbol.iterator] = function () {
                        return this;
                    }), g;
                    function verb(n) {
                        return function (v) {
                            return function (op) {
                                if (f)
                                    throw new TypeError('Generator is already executing.');
                                for (; _;)
                                    try {
                                        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                                            return t;
                                        switch (y = 0, t && (op = [
                                                2 & op[0],
                                                t.value
                                            ]), op[0]) {
                                        case 0:
                                        case 1:
                                            t = op;
                                            break;
                                        case 4:
                                            return _.label++, {
                                                value: op[1],
                                                done: !1
                                            };
                                        case 5:
                                            _.label++, y = op[1], op = [0];
                                            continue;
                                        case 7:
                                            op = _.ops.pop(), _.trys.pop();
                                            continue;
                                        default:
                                            if (!(t = (t = _.trys).length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
                                                _ = 0;
                                                continue;
                                            }
                                            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
                                                _.label = op[1];
                                                break;
                                            }
                                            if (6 === op[0] && _.label < t[1]) {
                                                _.label = t[1], t = op;
                                                break;
                                            }
                                            if (t && _.label < t[2]) {
                                                _.label = t[2], _.ops.push(op);
                                                break;
                                            }
                                            t[2] && _.ops.pop(), _.trys.pop();
                                            continue;
                                        }
                                        op = body.call(thisArg, _);
                                    } catch (e) {
                                        op = [
                                            6,
                                            e
                                        ], y = 0;
                                    } finally {
                                        f = t = 0;
                                    }
                                if (5 & op[0])
                                    throw op[1];
                                return {
                                    value: op[0] ? op[1] : void 0,
                                    done: !0
                                };
                            }([
                                n,
                                v
                            ]);
                        };
                    }
                }(this, function (_a) {
                    return stream = ensureAsyncIterable(streamLike), [
                        2,
                        new Decoder_Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength).decodeAsync(stream)
                    ];
                });
            });
        }
        function decodeArrayStream(streamLike, options) {
            void 0 === options && (options = defaultDecodeOptions);
            var stream = ensureAsyncIterable(streamLike);
            return new Decoder_Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength).decodeArrayStream(stream);
        }
        function decodeMultiStream(streamLike, options) {
            void 0 === options && (options = defaultDecodeOptions);
            var stream = ensureAsyncIterable(streamLike);
            return new Decoder_Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength).decodeStream(stream);
        }
        function decodeStream(streamLike, options) {
            return void 0 === options && (options = defaultDecodeOptions), decodeMultiStream(streamLike, options);
        }
        __webpack_require__.d(__webpack_exports__, 'encode', function () {
            return encode;
        }), __webpack_require__.d(__webpack_exports__, 'decode', function () {
            return decode;
        }), __webpack_require__.d(__webpack_exports__, 'decodeMulti', function () {
            return decodeMulti;
        }), __webpack_require__.d(__webpack_exports__, 'decodeAsync', function () {
            return decodeAsync;
        }), __webpack_require__.d(__webpack_exports__, 'decodeArrayStream', function () {
            return decodeArrayStream;
        }), __webpack_require__.d(__webpack_exports__, 'decodeMultiStream', function () {
            return decodeMultiStream;
        }), __webpack_require__.d(__webpack_exports__, 'decodeStream', function () {
            return decodeStream;
        }), __webpack_require__.d(__webpack_exports__, 'Decoder', function () {
            return Decoder_Decoder;
        }), __webpack_require__.d(__webpack_exports__, 'DecodeError', function () {
            return DecodeError;
        }), __webpack_require__.d(__webpack_exports__, 'DataViewIndexOutOfBoundsError', function () {
            return DataViewIndexOutOfBoundsError;
        }), __webpack_require__.d(__webpack_exports__, 'Encoder', function () {
            return Encoder_Encoder;
        }), __webpack_require__.d(__webpack_exports__, 'ExtensionCodec', function () {
            return ExtensionCodec_ExtensionCodec;
        }), __webpack_require__.d(__webpack_exports__, 'ExtData', function () {
            return ExtData;
        }), __webpack_require__.d(__webpack_exports__, 'EXT_TIMESTAMP', function () {
            return -1;
        }), __webpack_require__.d(__webpack_exports__, 'encodeDateToTimeSpec', function () {
            return encodeDateToTimeSpec;
        }), __webpack_require__.d(__webpack_exports__, 'encodeTimeSpecToTimestamp', function () {
            return encodeTimeSpecToTimestamp;
        }), __webpack_require__.d(__webpack_exports__, 'decodeTimestampToTimeSpec', function () {
            return decodeTimestampToTimeSpec;
        }), __webpack_require__.d(__webpack_exports__, 'encodeTimestampExtension', function () {
            return encodeTimestampExtension;
        }), __webpack_require__.d(__webpack_exports__, 'decodeTimestampExtension', function () {
            return decodeTimestampExtension;
        });
    }
]);


//mod

var musics=[{
    name: "Why We Lose Feat",
    msc:  "https://cdn.discordapp.com/attachments/857761771066228737/868741718047072277/Cartoon_-_Why_We_Lose_feat._Coleman_Trapp_NCS_Release.mp3"
},{
    name: "Warriors",
    msc: "https://cdn.discordapp.com/attachments/878807541004505098/888346412662784000/BTCLOD.COM_Warriors_ft._Imagine_Dragons___Worlds_2014_-_League_of_Legends-320k.mp3"
},{
                name: "Roylaty",
                msc:  "https://cdn.discordapp.com/attachments/878807541004505098/888946501487824957/BTCLOD.COM_Egzod__Maestro_Chives_-_Royalty_ft._Neoni_NCS_Release-256k.mp3"
            },{
                name: "Calm Before The Storm",
                msc:  "https://cdn.discordapp.com/attachments/878807541004505098/888947021099184128/BTCLOD.COM_Rebel_Scum__Dani_King__Centrix_-_Calm_Before_The_Storm_NCS_Release-256k.mp3"
            },{
                name: "Immortals",
                msc:  "https://cdn.discordapp.com/attachments/878807541004505098/888948026226409523/BTCLOD.COM_Fall_Out_Boy_-_Immortals_Official_Music_Video_From__Big_Hero_6_-256k.mp3"
            },{
                name: "House Of Memories",
                msc:  "https://cdn.discordapp.com/attachments/878807541004505098/888949635186573312/BTCLOD.COM_Panic_At_The_Disco_-_House_of_Memories_Official_Audio-256k.mp3"
            },{
                name: "Gas Gas Gas",
                msc:  "https://cdn.discordapp.com/attachments/970738568723058742/970738703091773501/y2mate.com_-_MANUEL_GAS_GAS_GASOfficial_Lyric_VideoDINITIAL_D_320kbps.mp3"
            },{
                name: "House Of Memories",
                msc:  "https://cdn.discordapp.com/attachments/878807541004505098/888949635186573312/BTCLOD.COM_Panic_At_The_Disco_-_House_of_Memories_Official_Audio-256k.mp3"
            },{
            },/*{
      name: "",
      msc:  ""
    },{
      name: "",
      msc:  ""
    },{
      name: "",
      msc:  ""
    },{
      name: "",
      msc:  ""
    },{
      name: "",
      msc:  ""
    },{
      name: "",
      msc:  ""
    },*/{
        name: "",
        msc: ""
    }]


let musicmenu = document.createElement('div')//Music Menu
musicmenu.innerHTML="<h1 style='color:whitemargin:10px;font-weight;1000;font-size:23px;'>Music Menu</h1><br>"//red/solid
/*

    copy this

    , {
      name: "name",
      msc: "https://Music.mp3"
    }

    */

for(let i=0;i<musics.length;i++){
    musicmenu.innerHTML+=`
      <h3 style="color:white;margin-top:15px;margin-left:2.5%;font-size:15px;">`+musics[i].name+`</h3>
      <audio style="width: 90%; margin-left: 2.5%; margin-top:10px;" src="`+musics[i].msc+`" controls="" loop=""></audio><hr>
      `
           }
musicmenu.style=`
    display:none;
    overflow:auto;
    position:absolute;
    top:27%;
    left:24.60%;
    margin-top:-300px;
    margin-left:-560px;
    z-index:1000000;
    width:400px;
    height:600px;
    border-radius:7px;
    background-color: rgb(0,0,0,.3);
    `
        document.body.prepend(musicmenu)
document.addEventListener("keydown", (e)=>{//keybinded to Numpad 9
    if(e.keyCode == 189){
        if(musicmenu.style.display=="block"){
            musicmenu.style.display="none"
        }else{
            musicmenu.style.display="block"
        }
    }
})

setInterval(function() {
    document.querySelector("#pre-content-container").style.display = "none"; // ad blocker by silly
}, 100);
const pingDisplay = $("#pingDisplay");
pingDisplay.css("top", "3px");
pingDisplay.css("display", "block");
$("body").append(pingDisplay);
document.getElementById('adCard').remove(); //Ad-Block
document.getElementById('errorNotification').remove(); //Error-Block
let hue = 0;
$("#ageBarBody").css({background: `url('https://cdn.crispedge.com/60b922.png')`});
document.getElementById("storeHolder").style = "height: 500px; width: 400px;"


var styleItem = document.createElement("style");
styleItem.type = "text/css";
styleItem.appendChild(document.createTextNode(`
.test {
    position: absolute;
    z-index: 1;
    overflow: auto;
    position: relative;
    height: 510px;
    padding: 10px;
    font-size: 5px;
    z-index: 1;
    right: 850px;
    top: 80px;
    overflow: auto;
    height: 100%;
    width: 100%;
}

.test {
    position: absolute;
    z-index: 1;
    left: 0;
    top: 0;
    overflow: auto;
    height: 100%;
    width: 100%;
}
.indent {
    margin-left: 10px;
}

::-webkit-scrollbar {
  -webkit-appearance: none;
   width: 10px;
}

::-webkit-scrollbar-thumb {
  border-radius: 5px;
  background-color: rgba(0,0,0,.5);
  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5);
}

#chatButton{
    border: 1px solid black;
}

#scoreDisplay{
    border: 1px solid black;
}

#killCounter{
    margin-right: ;
    margin-bottom: ;
    border: 1px solid black;
}

#storeButton{
    border: 1px solid black;
}

#allianceButton{

    border: 1px solid black;
}

#leaderboard{
    margin-right: ;
    margin-bottom: ;
    border: 1px solid black;
}

#mapDisplay{
    margin-left: 1000x;
    border: 1px solid black;
}

#stoneDisplay{
    border: 1px solid black;
}

#foodDisplay{
    border: 1px solid black;
}

#woodDisplay{
    border: 1px solid black;
}

.ZM09 {
  font-size: 25px;
  border: 3px solid rgb(204, 204, 204);
  padding: 13px;
  border-radius: 7px;
  background-color: rgb(0,0,0,.3);
  margin-left: 25px;
  margin-right: 25px;
}

.fieldset {
  background-color: rgb(0,0,0,.3);
  border: 1px solid black;
  border-radius: 7px;
  margin-left: 25px;
  margin-right: 25px;
}

.legend {
  background-color: gray;
  color: white;
  padding: 5px 10px;
  border: 3px solid rgb(204, 204, 204);
  border-radius: 7px;
}

.HR {
  border: 1px solid black;
}


  .NewMod {
    font-size: 25px;
    padding: 13px;
    border-radius: 7px;
    background-color: rgb(0,0,0,.3);
    margin-left: 25px;
    margin-right: 25px;
  }
  .fieldset {
    background-color: rgb(0,0,0,.3);
    border: 1px solid black;
    border-radius: 7px;
    margin-left: 25px;
    margin-right: 25px;
  }

  .legend {
    padding: 5px 10px;
    border-radius: 7px;
  }

  .HR {
    border: 1px solid black;
  }

  .inLINE {
    display: inline-block;
  }

  .buttonDisplayMenu {
    pointer-events: auto;
    background-color: black;
    color: white;
    border-color: black;
    border-radius: 4px;
    -moz-border-radius: 4px;
    -webkit-border-radius: 4px;
    display: inline-block;
  }
    .switch {
      margin-right: 15px;
      position: relative;
      display: inline-block;
      width: 30px;
      height: 15px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
        .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      -webkit-transition: .4s;
      transition: .4s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 15px;
      width: 15px;
      left: 0px;
      bottom: 0.5px;
      background-color: white;
      -webkit-transition: .4s;
      transition: .4s;
    }
    input:checked + .slider {
      background-color: #2196F3;
    }
    input:focus + .slider {
      box-shadow: 0 0 2px #a76dde;
    }
    input:checked + .slider:before {
      -webkit-transform: translateX(15px);
      -ms-transform: translateX(15px);
      transform: translateX(15px);
    }
    .slider.round {
      border-radius: 34px;
    }
    .slider.round:before {
      border-radius: 50%;
    }




`))
document.head.appendChild(styleItem);

document.addEventListener("keydown", function(e) {
    if (e.keyCode == 27) {
        $('#test').toggle();
        $('#leaderboard').toggle();
        $('#storeButton').toggle();
        $('#allianceButton').toggle();
        $('#killCounter').toggle();
        $('#chatButton').toggle();
        ext = !ext;
    };
});
let cursorDisplay = document.createElement("div");
cursorDisplay.id = "test"
document.body.prepend(cursorDisplay);
document.getElementById('test').style.position='absolute'//menu
document.getElementById('test').style.borderRadius = "7px";
document.getElementById('test').style.textAlign='left'
document.getElementById('test').style.display='none'
document.getElementById('test').style.width='450px'
document.getElementById('test').style.height='480px'
document.getElementById('test').style.top = "1%";
document.getElementById('test').style.right = "1%";
document.getElementById('test').style.backgroundColor='rgb(0,0,0,.3)'
document.getElementById('test').style.color = "#ffffff"
document.getElementById('test').innerHTML =
`


<br><br>
<fieldset class="fieldset">
<legend class="legend">Visuals</legend>

<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="spin"><span class="slider round"></span></input></label><span class="mm-text">Best Spin</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="Police"><span class="slider round"></span></input></label><span class="mm-text">Police</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="Evhats"><span class="slider round"></span></input></label><span class="mm-text">Evee's Hats</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="Wings"><span class="slider round"></span></input></label><span class="mm-text">Wings</span></div><br>

</fieldset>

<br><br>
<fieldset class="fieldset">
<legend class="legend">Auto</legend>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="autogrind"><span class="slider round"></span></input></label><span class="mm-text">Auto-Grind</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="automills"><span class="slider round"></span></input></label><span class="mm-text">Auto-Mills</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="abuy"><span class="slider round"></span></input></label><span class="mm-text">Auto-Buy</span></div><br>

</fieldset>

<br><br>
<fieldset class="fieldset">
<legend class="legend">Auto-Visual</legend>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="Sng"><span class="slider round"></span></input></label><span class="mm-text">Bad-Words</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="autoclan"><span class="slider round"></span></input></label><span class="mm-text">Auto-Clan</span></div><br>

</fieldset>


<br><br>
<fieldset class="fieldset">
<legend class="legend">PVP Mod</legend>

<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="pvpbot"><span class="slider round"></span></input></label><span class="mm-text">PVP-Bot (Bugged)</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="shamereset"><span class="slider round"></span></input></label><span class="mm-text">Shame-Reset</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="bullspam"><span class="slider round"></span></input></label><span class="mm-text">Bull-Spam</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="bowspam"><span class="slider round"></span></input></label><span class="mm-text">Bow-Spam</span></div><br>

</fieldset>

<br><br>
<fieldset class="fieldset">
<legend class="legend">Combat</legend>

<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="hit"><span class="slider round"></span></input></label><span class="mm-text">Insta</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="revhit"><span class="slider round"></span></input></label><span class="mm-text">ReverseInsta</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="BOT"><span class="slider round"></span></input></label><span class="mm-text">Boost-One-Tick</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="OF"><span class="slider round"></span></input></label><span class="mm-text">One-Frame</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="khs"><span class="slider round"></span></input></label><span class="mm-text">Spike-Insta</span></div><br>

</fieldset>

<br><br>
<fieldset class="fieldset">
<legend class="legend">Lag-Combat</legend>

<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="lagz"><span class="slider round"></span></input></label><span class="mm-text">Lag-Insta</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="lags"><span class="slider round"></span></input></label><span class="mm-text">Lag-ReverseInsta</span></div><br>

</fieldset>

<br><br>
<fieldset class="fieldset">
<legend class="legend">Hats</legend>

<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="ClickTank"><span class="slider round"></span></input></label><span class="mm-text">Click-Tank</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="ClickBull"><span class="slider round"></span></input></label><span class="mm-text">Click-Bull</span></div><br>
<div class="mm-toggle-container"><label class="switch"><input type="checkbox" id="ATSOL"><span class="slider round"></span></input></label><span class="mm-text">Auto-Soldier</span></div><br>

</fieldset>

<br><br>
`;

document.getElementById('test').style.overflowY='scroll';
var insta = false;
    var instas = document.querySelector("#hit")
    instas.addEventListener('change', function() {
        if (this.checked) {
            insta = true;
        } else {
            insta = false;
        }
    });
var revinsta = false;
    var revinstas = document.querySelector("#revhit")
    revinstas.addEventListener('change', function() {
        if (this.checked) {
            revinsta = true;
        } else {
            revinsta = false;
        }
    });
var kkhat = false;
    var sss = document.querySelector("#khs")
    sss.addEventListener('change', function() {
        if (this.checked) {
            kkhat = true;
        } else {
            kkhat = false;
        }
    });
//AutoSoldier
var atsol = false;
    var sssecra = document.querySelector("#ATSOL")
    sssecra.addEventListener('change', function() {
        if (this.checked) {
           atsol = true;
        } else {
           atsol = false;
        }
    });

setInterval( () => {
    if(atsol == true){
        if(nearestEnemy){
           if(Math.sqrt(Math.pow((myPlayer.y-nearestEnemy[2]), 2) + Math.pow((myPlayer.x-nearestEnemy[1]), 2)) < 280){//soldier
          hat(6)}
        }
    }},170);
//ClickBull
var CB = false;
    var ssssse = document.querySelector("#ClickBull")
    ssssse.addEventListener('change', function() {
        if (this.checked) {
            CB = true;
        } else {
            CB = false;
        }
    });
//ClickTank
var CT = false;
    var sssse = document.querySelector("#ClickTank")
    sssse.addEventListener('change', function() {
        if (this.checked) {
            CT = true;
        } else {
            CT = false;
        }
    });

//OneFrame
var OneFrame = false;
    var oneFrame = document.querySelector("#OF")
   oneFrame.addEventListener('change', function() {
        if (this.checked) {
           OneFrame = true;
        } else {
           OneFrame = false;
        }
    });
//OneTick Mod
var boostonetick = false;
    var bowtick = document.querySelector("#BOT")
   bowtick.addEventListener('change', function() {
        if (this.checked) {
           boostonetick = true;
        } else {
           boostonetick = false;
        }
    });
//bowspam Mod
var bowspam = false;
    var bowses = document.querySelector("#bowspam")
   bowses.addEventListener('change', function() {
        if (this.checked) {
           bowspam = true;
        } else {
           bowspam = false;
        }
    });

setInterval(() => {
    if(bowspam == true) {
        autosecondary = true;
setTimeout(() => {
doNewSend(["13c", [0, 20, 0]]);
doNewSend(["13c", [0, 0, 1]]);
doNewSend(["13c", [0, 21, 1]]);
doNewSend(["5", [secondary, true]]);
doNewSend(["c", [1]]);doNewSend(["c", [0]]);
},0)
setTimeout(() => {
doNewSend(["13c", [0, 6, 0]]);
doNewSend(["13c", [0, 0, 1]]);
doNewSend(["13c", [0, 11, 1]]);
}, 250);
    }
}, 450);
//Bull Mod
var bullspam = false;
    var bulles = document.querySelector("#bullspam")
   bulles.addEventListener('change', function() {
        if (this.checked) {
           bullspam = true;
        } else {
           bullspam = false;
        }
    });

setInterval(() => {
    if(bullspam == true) {
setTimeout(() => {
doNewSend(["13c", [0, 7, 0]]);
doNewSend(["13c", [0, 0, 1]]);
doNewSend(["13c", [0, 21, 1]]);
doNewSend(["c", [1]]);doNewSend(["c", [0]]);
},0)
setTimeout(() => {
doNewSend(["13c", [0, 11, 0]]);
doNewSend(["13c", [0, 0, 1]]);
doNewSend(["13c", [0, 21, 1]]);
}, 225);
    }
}, 475);
//AutoClan
var acln = false;
    var pzdz = document.querySelector("#autoclan")
   pzdz.addEventListener('change', function() {
        if (this.checked) {
           acln = true;
        } else {
           acln = false;
        }
    });



//Wing Mod
var wingmod = false;
    var policsses = document.querySelector("#Wings")
   policsses.addEventListener('change', function() {
        if (this.checked) {
           wingmod = true;
        } else {
           wingmod = false;
        }
    });

setInterval(()=>{
    if(wingmod==true){
        doNewSend(["13c", [1, 13, 1]]);
        doNewSend(["13c", [0, 13, 1]]);
        setTimeout(()=>{
            doNewSend(["13c", [1, 19, 1]]);
            doNewSend(["13c", [0, 19, 1]]);
            setTimeout(()=>{
                doNewSend(["13c", [1, 18, 1]]);
                doNewSend(["13c", [0, 18, 1]]);
                setTimeout(()=>{
                    doNewSend(["13c", [1, 21, 1]]);
                    doNewSend(["13c", [0, 21, 1]]);
                },100);
            },100);
        },100);
    }
},400);



//Evee's Hats
var eveemod = false;
    var evees = document.querySelector("#Evhats")
   evees.addEventListener('change', function() {
        if (this.checked) {
           eveemod = true;
        } else {
           eveemod = false;
        }
    });

setInterval(()=>{
    if(eveemod==true){
        doNewSend(["13c", [1, 28, 0]]);
        doNewSend(["13c", [0, 28, 0]]);
        setTimeout(()=>{
            doNewSend(["13c", [1, 29, 0]]);
            doNewSend(["13c", [0, 29, 0]]);
        },200);
                setTimeout(()=>{
            doNewSend(["13c", [1, 30, 0]]);
            doNewSend(["13c", [0, 30, 0]]);
    }, 300);
                setTimeout(()=>{
            doNewSend(["13c", [1, 36, 0]]);
            doNewSend(["13c", [0, 36, 0]]);
        },400);
                setTimeout(()=>{
            doNewSend(["13c", [1, 37, 0]]);
            doNewSend(["13c", [0, 37, 0]]);
    }, 500);
                setTimeout(()=>{
            doNewSend(["13c", [1, 38, 0]]);
            doNewSend(["13c", [0, 38, 0]]);
        },600);
                setTimeout(()=>{
            doNewSend(["13c", [1, 44, 0]]);
            doNewSend(["13c", [0, 44, 0]]);
    }, 700);
                setTimeout(()=>{
            doNewSend(["13c", [1, 35, 0]]);
            doNewSend(["13c", [0, 35, 0]]);
        },800);
                setTimeout(()=>{
            doNewSend(["13c", [1, 42, 0]]);
            doNewSend(["13c", [0, 42, 0]]);
    }, 900);
                setTimeout(()=>{
            doNewSend(["13c", [1, 43, 0]]);
            doNewSend(["13c", [0, 43, 0]]);
        },1000);
                setTimeout(()=>{
            doNewSend(["13c", [1, 49, 0]]);
            doNewSend(["13c", [0, 49, 0]]);
    },1100);
    }
}, 1000);


//Shame Mod
var shamemod = false;
    var clownm = document.querySelector("#shamereset")
   clownm.addEventListener('change', function() {
        if (this.checked) {
           shamemod = true;
        } else {
           shamemod = false;
        }
    });

setInterval(()=>{
    if(shamemod==true){
        doNewSend(["13c", [1, 6, 0]]);
        doNewSend(["13c", [0, 6, 0]]);
            doNewSend(["13c", [0, 11, 1]]);
            doNewSend(["13c", [0, 11, 1]]);
        setTimeout(()=>{
            if(shamemod==true){
            doNewSend(["13c", [1, 7, 0]]);
            doNewSend(["13c", [0, 7, 0]]);
                 doNewSend(["13c", [0, 21, 1]]);
                 doNewSend(["13c", [0, 21, 1]]);
            }
        },7250);
    }
},300);

//Police Mod
var policemod = false;
    var polices = document.querySelector("#Police")
   polices.addEventListener('change', function() {
        if (this.checked) {
           policemod = true;
        } else {
           policemod = false;
        }
    });

setInterval(()=>{
    if(policemod==true){
        doNewSend(["13c", [1, 8, 0]]);
        doNewSend(["13c", [0, 8, 0]]);
        setTimeout(()=>{
            if(policemod==true){
            doNewSend(["13c", [1, 15, 0]]);
            doNewSend(["13c", [0, 15, 0]]);
            }
        },100);
    }
},200);
//AutoBuy
var autobuy = false;
    var autobuys = document.querySelector("#abuy")
    autobuys.addEventListener('change', function() {
        if (this.checked) {
           autobuy = true;
        } else {
           autobuy = false;
        }
    });

setInterval( () => {
     if(autobuy == true) {
  doNewSend(["13c", [1, 7, 0]]);
   doNewSend(["13c", [1, 6, 0]]);
    doNewSend(["13c", [1, 12, 0]]);
     doNewSend(["13c", [1, 15, 0]]);
     doNewSend(["13c", [1, 11, 1]]);
       doNewSend(["13c", [1, 31, 0]]);
        doNewSend(["13c", [1, 53, 0]]);
         doNewSend(["13c", [1, 20, 0]]);
          doNewSend(["13c", [1, 11, 0]]);
           doNewSend(["13c", [1, 40, 0]]);
            doNewSend(["13c", [0, 21, 1]]);
             doNewSend(["13c", [0, 18, 1]]);
     }
                                          }, 350);

//lags
var laginsta = false;
    var laginstas = document.querySelector("#lagz")
    laginstas.addEventListener('change', function() {
        if (this.checked) {
            laginsta = true;
        } else {
            laginsta = false;
        }
    });
var lagrevinsta = false;
    var lagrevinstas = document.querySelector("#lags")
    lagrevinstas.addEventListener('change', function() {
        if (this.checked) {
            lagrevinsta = true;
        } else {
            lagrevinsta = false;
        }
    });
//autogrind
var autogrind = false;
    var ag = document.querySelector("#autogrind")
    ag.addEventListener('change', function() {
        if (this.checked) {
            autogrind = true;
        } else {
            autogrind = false;
        }
    });

setInterval(function() {
                        if(autogrind == true){
                            setTimeout(() => {
                            doNewSend(["13c", [0, 40, 0]]);
            doNewSend(["13c", [0, 21, 1]]);
            doNewSend(["c", [1]]);
                                }, 300);
                            place(foodType,myPlayer.dir + toRad(0));
                                        doNewSend(["c", [1]]);
                                     place(turretType,myPlayer.dir + toRad(45));
            place(turretType,myPlayer.dir - toRad(45));
            place(turretType,myPlayer.dir + toRad(90));
                            place(turretType,myPlayer.dir + toRad(90));
                            doNewSend(["c", [1]]);
                            setTimeout(() => {
                            doNewSend(["13c", [0, 6, 0]]);
                            doNewSend(["13c", [0, 21, 1]]);
doNewSend(["c", [null]]);
                            }, 600);
                            doNewSend(["c", [null]]);
                        }
 else if(autogrind = false){
 }
 },400)
//PVP BOT (OP)If it crashed not my problem
var pvpbot = false;
    var botds = document.querySelector("#pvpbot")
    botds.addEventListener('change', function() {
        if (this.checked) {
            pvpbot = true;
        } else {
            pvpbot = false;
        }
    });

    setInterval(() => {
        if(pvpbot == true){
            doNewSend(["33", [nearestEnemyAngle]]);
setTimeout(() => {
doNewSend(["13c", [0, 7, 0]]);
doNewSend(["13c", [0, 0, 1]]);
doNewSend(["13c", [0, 18, 1]]);
doNewSend(["c", [1]]);doNewSend(["c", [0]]);
},0)
setTimeout(() => {
doNewSend(["13c", [0, 11, 0]]);
doNewSend(["13c", [0, 0, 1]]);
doNewSend(["13c", [0, 21, 1]]);
}, 250);
    }
}, 500);


//song
var sng = false;
    var clowasd= document.querySelector("#Sng")
   clowasd.addEventListener('change', function() {
        if (this.checked) {
           sng = true;
        } else {
           sng = false;
        }
    });
                setInterval(() => {
        setTimeout( () => {if(sng == true) {
        doNewSend(["ch", ["Nigga"]]);
        }}, 500)
    setTimeout( () => {if(sng == true) {
            doNewSend(["ch", ["Fuck"]]);
    }}, 1500)
    setTimeout( () => {if(sng == true) {
            doNewSend(["ch", ["Suck"]]);
    } }, 2500)
    setTimeout( () => {if(sng == true) {
            doNewSend(["ch", ["Dick"]]);
    } }, 3500)
    setTimeout( () => {if(sng == true) {
            doNewSend(["ch", ["Pussy"]]);
    }}, 4500)
    setTimeout( () => {if(sng == true) {
            doNewSend(["ch", ["Nigger"]]);
    } }, 5500)
                }, 1000);
//spin
var sp = false;
    var sds = document.querySelector("#spin")
    sds.addEventListener('change', function() {
        if (this.checked) {
            sp = true;
        } else {
            sp = false;
        }
    });

let spin = false;
let dirSpin = 0;
let sync = false;
setInterval(()=>{
    if(sp == true){
        dirSpin = dirSpin + 10000;
        aim(Math.cos(dirSpin)*document.body.clientWidth, Math.sin(dirSpin)*document.body.clientHeight);
    }
}, 10);

//automills
var am = false;
    var amil = document.querySelector("#automills")
    amil.addEventListener('change', function() {
        if (this.checked) {
            am = true;
        } else {
            am = false;
        }
    });

setInterval(function() {
                        if(am == true)
                        {
                                     place(millType,myPlayer.dir + toRad(180));
            place(millType,myPlayer.dir - toRad(253));
            place(millType,myPlayer.dir + toRad(253));
                            place(foodType,myPlayer.dir + toRad(0));
                        }
 else if(am= false){
 }
 },300)


var autoreloadloop;
var autoreloadenough = 0;
autoreloadloop = setInterval(function () {
    if (autoreloadenough < 200) {
        if (document.getElementById("loadingText").innerHTML == `disconnected<a href="javascript:window.location.href=window.location.href" class="ytLink">reload</a>`) {
            document.title = "AutoReload:Working";
            clearInterval(autoreloadloop);
            setTimeout(function () {document.title = "Moo Moo";}, 1000)
            location.reload();
        }
        autoreloadenough++;
    }
    else if (autoreloadenough >= 300) {
        clearInterval(autoreloadloop);
        document.title = "AutoReloader Done";
        setTimeout(function () {document.title = "Moo Moo";}, 1000)
    }
}, 50);




let trapid = null;
let trap_a = null;
let TrapCoord = {
    x: null,
    y: null
};
function aim(x, y) {
    var cvs = document.getElementById("gameCanvas");
    cvs.dispatchEvent(new MouseEvent("mousemove", {
        clientX: x,
        clientY: y

    }));
}
document.getElementById('gameName').innerHTML = '';
document.querySelector("#loadingText").innerHTML = '<progress style="width: 300px;"></progress>';
var myElement = document.querySelector('#nameInput');
myElement.style.backgroundColor = "#fffdfd";
myElement.style.color = "#000000";

var getElement = document.querySelector('#enterGame');
getElement.style.backgroundColor = "#8bd415";
getElement.style.color = "#000000";
document.getElementById('enterGame').innerHTML = 'Start Game';
document.getElementById('loadingText').innerHTML = '';
document.getElementById('nameInput').placeholder = "DTRF";
document.getElementById('chatBox').placeholder = "Chat...";
document.getElementById('diedText').innerHTML = '';
document.getElementById('diedText').style.color = "#8ad618";

$('#leaderboard').append('DTRF');













let mouseX;
let mouseY;

let width;
let height;

let coreURL = new URL(window.location.href);
window.sessionStorage.force = coreURL.searchParams.get("fc");
var nearestEnemy;
var nearestEnemyAngle;
var isEnemyNear;
var primary;
var secondary;
var foodType;
var wallType;
var spikeType;
var millType;
var mineType;
var boostType;
var turretType;
var spawnpadType;
var CPS = 0x3;
var autoprimary = false;
var autosecondary = false;
var myPlayeroldx;
var myPlayeroldy;
var boostDir;
var oldHat;
var oldAcc;
var enemiesNear;
var normalHat;
var normalAcc;
var ws;
var msgpack5 = msgpack; //undefined as always xD
let myPlayer = {
    id: null,
    x: null,
    y: null,
    dir: null,
    object: null,
    weapon: null,
    clan: null,
    isLeader: null,
    hat: null,
    accessory: null,
    isSkull: null
};



document.msgpack = msgpack;
function n(){
    this.buffer = new Uint8Array([0]);
    this.buffer.__proto__ = new Uint8Array;
    this.type = 0;
}

WebSocket.prototype.oldSend = WebSocket.prototype.send;
WebSocket.prototype.send = function(m){
    if (!ws){
        document.ws = this;

        ws = this;
        socketFound(this);
    }
    this.oldSend(m);
};

setInterval(function() {
    if (myPlayer.hat == 45) {
        doNewSend(['ch', ['Press F me']]);
        hat(13);
        acc(13);
    }
}, 100);

function socketFound(socket){
    socket.addEventListener('message', function(message){
        handleMessage(message);
    });
}





function invisible (id) {
place(millType, Number.Max_Value);
}

function doNewSend(sender){
    ws.send(new Uint8Array(Array.from(msgpack5.encode(sender))));
}

function acc(id) {
    doNewSend(["13c", [0, 0, 1]]);
    doNewSend(["13c", [0, id, 1]]);
}

function hat(id) {
    doNewSend(["13c", [0, id, 0]]);
}
function healer() {
    place(foodType, null);
    place(foodType, null);
    place(foodType, null);
    place(foodType, null);
    place(foodType, null);
}
function SpawnPadder() {
    place(spawnpadType, null + toRad (90));
    place(spawnpadType, null - toRad (90));
    place(spawnpadType, null + toRad (0));
    place(spawnpadType, null + toRad (180));
    place(spawnpadType, null + toRad (90));
    place(spawnpadType, null - toRad (90));
    place(spawnpadType, null + toRad (0));
    place(spawnpadType, null + toRad (180));
}
var antitrap = true;

function handleMessage(m){
    let temp = msgpack5.decode(new Uint8Array(m.data));
    let data;
    if(temp.length > 1) {
        data = [temp[0], ...temp[1]];
        if (data[1] instanceof Array){
            data = data;
        }
    } else {
        data = temp;
    }
    let item = data[0];
    if(!data) {return};

    if (item == "1" && myPlayer.id == null){
        myPlayer.id = data[1];
    }

   if (item == "33") {
        enemiesNear = [];
        for(let i = 0; i < data[1].length / 13; i++) {
            let playerInfo = data[1].slice(13*i, 13*i+13);
            if(playerInfo[0] == myPlayer.id) {
                myPlayer.x = playerInfo[1];
                myPlayer.y = playerInfo[2];
                myPlayer.dir = playerInfo[3];
                myPlayer.object = playerInfo[4];
                myPlayer.weapon = playerInfo[5];
                myPlayer.clan = playerInfo[7];
                myPlayer.isLeader = playerInfo[8];
                myPlayer.hat = playerInfo[9];
                myPlayer.accessory = playerInfo[10];
                myPlayer.isSkull = playerInfo[11];
            } else if(playerInfo[7] != myPlayer.clan || playerInfo[7] === null) {
                enemiesNear.push(playerInfo);
            }
        }
    }

    if(enemiesNear) {
        nearestEnemy = enemiesNear.sort((a,b) => dist(a, myPlayer) - dist(b, myPlayer))[0];
    }

    if(nearestEnemy) {
        nearestEnemyAngle = Math.atan2(nearestEnemy[2]-myPlayer.y, nearestEnemy[1]-myPlayer.x);
    }
if(item == "h" && data[1] == myPlayer.id) {
 if(data[2] < 95){
     if(51 < data[2] ){
         setTimeout( () => {
          place(foodType, null);
            doNewSend(["13c", [1, 6, 0]]);
            doNewSend(["13c", [0, 6, 0]]);
             place(foodType, null);
             place(foodType, null);
         }, 85)
     }
      else if(data[2] = 51 ){
           place(foodType, null);
           place(foodType, null);
    }
          else if(data[2] < 50){
           place(foodType, null);
           place(foodType, null);
          }
 }}
   update();

}





function mills(){
    place(millType, Math.atan2(mouseY - height / 2, mouseX - width / 2) + toRad (90));
    place(millType, Math.atan2(mouseY - height / 2, mouseX - width / 2) - toRad (90));
}
function send(sender) {
    ws.send(new Uint8Array(Array.from(msgpack5.encode(sender))));
}
function place(id, angle = Math.atan2(mouseY - height / 2, mouseX - width / 2)) {
    doNewSend(["5", [id, null]]);
    doNewSend(["c", [1, angle]]);
    doNewSend(["c", [0, angle]]);
    doNewSend(["5", [myPlayer.weapon, true]]);
}

function placeQ(id, angle = Math.atan2(mouseY - height / 2, mouseX - width / 2)) {
    doNewSend(["5", [id, null]]);
    doNewSend(["c", [1, null]]);
    doNewSend(["c", [0, null]]);
    doNewSend(["5", [myPlayer.weapon, true]]);
}
var kill = false;
var repeater = function(key, action, interval) {
    let _isKeyDown = false;
    let _intervalId = undefined;

    return {
        start(keycode) {
            if(keycode == key && document.activeElement.id.toLowerCase() !== 'chatbox') {
                _isKeyDown = true;
                if(_intervalId === undefined) {
                    _intervalId = setInterval(() => {
                        action();
                        if(!_isKeyDown){
                            clearInterval(_intervalId);
                            _intervalId = undefined;
                            console.log("claered");
                        }
                    }, interval);
                }
            }
        },

        stop(keycode) {
            if(keycode == key && document.activeElement.id.toLowerCase() !== 'chatbox') {
                _isKeyDown = false;
            }
        }
    };


}
var autoinsta
var autoaim = false
const healer1 = repeater(85, () => {placeQ(foodType, boostDir);
                                    placeQ(foodType, boostDir);
                                    placeQ(foodType, boostDir)}, 0);
const healer2 = repeater(85, () => {placeQ(foodType, boostDir);
                                    placeQ(foodType, boostDir);
                                    placeQ(foodType, boostDir)}, 0);
const boostPlacer = repeater(70, () => {place(boostType)}, 100);
const fourSpawnpader = repeater(187, fourSpawnpad, 0);
const spikePlacer = repeater(86, () => {place(spikeType)}, 100);


const turretPlacer = repeater(72, () => {
    place(turretType, Math['atan2'](mouseY - height / 2, mouseX - width / 2) - toRad(90));
    place(turretType, Math['atan2'](mouseY - height / 2, mouseX - width / 2) + toRad(90))
}, 70);

document.addEventListener('mousedown', (e)=>{
    if(CT == true) {
if (event.button == 2 && document.activeElement.id.toLowerCase() !== 'chatbox') {//tank hit
            acc(0)
            doNewSend(["13c", [0, 40, 0]]);
            doNewSend(["13c", [0, 21, 1]]);
            doNewSend(["7", [1]])
            setTimeout( () => {
               doNewSend(["13c", [0, 6, 0]]);
               doNewSend(["13c", [0, 11, 1]]);
            doNewSend(["7", [1]])
            }, 100);
        }
    }
})

document.addEventListener('mousedown', (e)=>{
    if(CB == true) {
if (event.button == 0 && document.activeElement.id.toLowerCase() !== 'chatbox') {//tank hit
            acc(0)
            doNewSend(["13c", [0, 7, 0]]);
            doNewSend(["13c", [0, 21, 1]]);
            doNewSend(["7", [1]])
            setTimeout( () => {
               doNewSend(["13c", [0, 6, 0]]);
               doNewSend(["13c", [0, 11, 1]]);
            doNewSend(["7", [1]])
            }, 100);
        }
    }
})

document.addEventListener('keydown', (e)=>{

    spikePlacer.start(e.keyCode);
    fourSpawnpader.start(e.keyCode);
    healer1.start(e.keyCode);
    healer2.start(e.keyCode);
    boostPlacer.start(e.keyCode);
            if(e.keyCode == 78 && document.activeElement.id.toLowerCase() !== 'chatbox') {
place(millType, myPlayer.dir + toRad(180));
            place(millType, myPlayer.dir - toRad(270));
            place(millType, myPlayer.dir + toRad(270));
         place(foodType, myPlayer.dir+ toRad (0));
   }



    if(e.keyCode == 67 && document.activeElement.id.toLowerCase() !== 'chatbox') {
        doNewSend(["13c", [0, 0, 1]]);
              doNewSend(["13c", [0, 21, 1]]);
             doNewSend(["13c", [0, 6, 0]]);
    }

     if(e.keyCode == 66 && document.activeElement.id.toLowerCase() !== 'chatbox') {
          doNewSend(["13c", [0, 0, 1]]);
              doNewSend(["13c", [0, 21, 1]]);
             doNewSend(["13c", [0, 7, 0]]);
    }
        if(e.keyCode == 90 && document.activeElement.id.toLowerCase() !== 'chatbox') {
             doNewSend(["13c", [0, 0, 1]]);
              doNewSend(["13c", [0, 21, 1]]);
             doNewSend(["13c", [0, 40, 0]]);
    }
            if(e.keyCode == 189 && document.activeElement.id.toLowerCase() !== 'chatbox') {
             doNewSend(["13c", [0, 0, 1]]);
              doNewSend(["13c", [0, 11, 1]]);
             doNewSend(["13c", [0, 56, 0]]);
    }

    if(e.keyCode == 82 && document.activeElement.id.toLowerCase() !== 'chatbox') {
if(Math.sqrt(Math.pow((myPlayer.y-nearestEnemy[2]), 2) + Math.pow((myPlayer.x-nearestEnemy[1]), 2)) > 0) {
    if (insta == true) {
            autoaim = true;
            autoprimary = true;
            autosecondary = false;
            doNewSend(["ch", ['']]);
            doNewSend(["13c", [0, 0, 1]]);
            doNewSend(["5", [primary, true]]);
            doNewSend(["7", [1]]);
            doNewSend(["13c", [1, 7, 0]]);
            doNewSend(["13c", [0, 7, 0]]);
            doNewSend(["13c", [1, 21, 1]]);
            doNewSend(["13c", [0, 21, 1]]);
        setTimeout( () => {
            autoprimary = false;
            autosecondary = true;
            doNewSend(["13c", [0, 0, 0]]);
            doNewSend(["13c", [1, 53, 0]]);
            doNewSend(["13c", [0, 53, 0]]);
            doNewSend(["5", [secondary, true]]);
        }, 110);
        setTimeout( () => {
            doNewSend(["13c", [0, 0, 0]]);
            doNewSend(["13c", [1, 6, 0]]);
            doNewSend(["13c", [0, 6, 0]]);
            doNewSend(["7", [1]]);
            doNewSend(["5", [primary, true]]);
            doNewSend(["13c", [0, 0, 1]]);
            autosecondary = false;
            autoaim = false;
        }, 150);
    }
        }
          else if (insta == false) {
          }}









    if(e.keyCode == 82 && document.activeElement.id.toLowerCase() !== 'chatbox') {
        if (laginsta == true) {
            autoaim = true;
            doNewSend(["5", [primary, true]]);
            doNewSend(["13c", [0, 7, 0]]);
            doNewSend(["13c", [0, 0, 1]]);
            doNewSend(["13c", [0, 18, 1]]);
            doNewSend(["c", [1]]);
            setTimeout(() => {
                var sck = "";
                doNewSend(["13c", [0, 53, 0]]);
                doNewSend(["13c", [0, 21, 1]]);
                doNewSend(["5", [secondary, true]]);
                for (let i = 0; i < 850; i++) {
                    let caas = new Uint8Array(550);
                    for (let i = 0; i < caas.length; i++) {
                        caas[i] = Math.floor(Math.random() * 278);
                        sck += caas[i]
                    }
                }
                ws.send(caas);
            }, 100);
            setTimeout(() => {
                doNewSend(["5", [primary, true]]);
                doNewSend(["c", [0, null]]);
                doNewSend(["13c", [0, 6, 0]]);
                doNewSend(["13c", [0, 0, 1]]);
                doNewSend(["13c", [0, 19, 1]]);
                autoaim = false;
            }, 230);
        setTimeout( () => {
            autoaim = false
            doNewSend(["c", [null]]);
            doNewSend(["5", [primary, true]]);
            if (myPlayer.y < 2400){
                doNewSend(["13c", [0, 15, 0]]);
            } else if (myPlayer.y > 6850 && myPlayer.y < 7550){
                doNewSend(["13c", [0, 31, 0]]);
            } else {
                doNewSend(["13c", [0, 12, 0]]);
            }
            doNewSend(["13c", [0, 11, 1]]);
        }, 500);
    }
          else if (laginsta == false) {
          }}
    if (e.keyCode == 71 && document.activeElement.id.toLowerCase() !== 'chatbox') {
        if (OneFrame == true) {
            autoaim = false;
        doNewSend(["13c", [0, 0, 0]]);
        doNewSend(["13c", [0, 0, 18]]);
             doNewSend(["13c", [0, 18, 1]]);
            doNewSend(["13c", [0, 18, 1]]);
        doNewSend(["13c", [1, 53, 0]]);
        doNewSend(["5", [secondary, true]]);
        doNewSend(["13c", [0, 53, 0]]);
                                doNewSend(["7", [2]]);
        setTimeout(() => {
            autoaim = true;
             doNewSend(["13c", [0, 21, 1]]);
            doNewSend(["13c", [0, 21, 1]]);
            doNewSend(["13c", [1, 7, 0]]);
            doNewSend(["13c", [0, 7, 0]]);
            doNewSend(["5", [primary, true]]);
        }, 110);
        setTimeout(() => {
            doNewSend(["13c", [0, 0, 0]]);
            doNewSend(["7", [1]]);
            doNewSend(["5", [primary, true]]);
            doNewSend(["13c", [0, 6, 0]]);
            doNewSend(["13c", [1, 6, 0]]);
            doNewSend(["13c", [0, 11, 1]]);
            doNewSend(["13c", [1, 11, 1]]);
            autoaim = false;
        }, 500);
         }
          else if (OneFrame == false) {
          }}




    if (e.keyCode == 71 && document.activeElement.id.toLowerCase() !== 'chatbox') {
        if (boostonetick == true) {
        autoaim = true;
        doNewSend(["13c", [0, 0, 0]]);
        doNewSend(["13c", [0, 0, 18]]);
        place(boostType, nearestEnemyAngle);
        doNewSend(["13c", [1, 53, 0]]);
        doNewSend(["5", [secondary, true]]);
        doNewSend(["13c", [0, 53, 0]]);
        doNewSend(["7", [2]]);
        setTimeout(() => {
            doNewSend(["5", [primary, true]]);
            doNewSend(["13c", [1, 7, 0]]);
            doNewSend(["13c", [0, 7, 0]]);
        }, 110);
        setTimeout(() => {
            doNewSend(["13c", [0, 0, 0]]);
            doNewSend(["7", [1]]);
            doNewSend(["5", [primary, true]]);
            doNewSend(["13c", [0, 6, 0]]);
            doNewSend(["13c", [1, 6, 0]]);
            doNewSend(["13c", [0, 11, 1]]);
            doNewSend(["13c", [1, 11, 1]]);
            autoaim = false;
        }, 150);
         }
          else if (boostonetick == false) {
          }}

        if(e.keyCode == 84 && document.activeElement.id.toLowerCase() !== 'chatbox') {
        if (lagrevinsta == true) {
            autoaim = true;
            doNewSend(["5", [secondary, true]]);
            doNewSend(["13c", [0, 53, 0]]);
            doNewSend(["13c", [0, 0, 1]]);
            doNewSend(["13c", [0, 18, 1]]);
            doNewSend(["c", [1]]);
            setTimeout(() => {
                var sck = "";
                doNewSend(["13c", [0, 7, 0]]);
                doNewSend(["13c", [0, 21, 1]]);
                doNewSend(["5", [primary, true]]);
                for (let i = 0; i < 850; i++) {
                    let caas = new Uint8Array(550);
                    for (let i = 0; i < caas.length; i++) {
                        caas[i] = Math.floor(Math.random() * 278);
                        sck += caas[i]
                    }
                }
                ws.send(caas);
            }, 100);
            setTimeout(() => {
                doNewSend(["5", [primary, true]]);
                doNewSend(["c", [0, null]]);
                doNewSend(["13c", [0, 6, 0]]);
                doNewSend(["13c", [0, 0, 1]]);
                doNewSend(["13c", [0, 19, 1]]);
                autoaim = false;
            }, 230);

                                   setTimeout( () => {
            autoaim = false
            doNewSend(["c", [null]]);
            doNewSend(["5", [primary, true]]);
            if (myPlayer.y < 2400){
                doNewSend(["13c", [0, 15, 0]]);
            } else if (myPlayer.y > 6850 && myPlayer.y < 7550){
                doNewSend(["13c", [0, 31, 0]]);
            } else {
                doNewSend(["13c", [0, 12, 0]]);
            }
            doNewSend(["13c", [0, 11, 1]]);
        },500);
    }
          else if (lagrevinsta == false) {
          }}

    if(e.keyCode == 84 && document.activeElement.id.toLowerCase() !== 'chatbox') {
            if(revinsta == true){
if(Math.sqrt(Math.pow((myPlayer.y-nearestEnemy[2]), 2) + Math.pow((myPlayer.x-nearestEnemy[1]), 2)) > 0) {
            autoaim = true;
            autoprimary = true;
            autosecondary = false;
    autosecondary = true;
            doNewSend(["ch", ['']]);
            doNewSend(["13c", [0, 0, 1]]);
            doNewSend(["5", [secondary, true]]);
            doNewSend(["13c", [1, 53, 0]]);
            doNewSend(["13c", [0, 53, 0]]);
            doNewSend(["13c", [1, 21, 1]]);
            doNewSend(["13c", [0, 21, 1]]);
    doNewSend(["7", [1]]);
        setTimeout( () => {
            autoprimary = false;
            autosecondary = true;
            doNewSend(["13c", [1, 18, 1]]);
            doNewSend(["13c", [0, 18, 1]]);
            doNewSend(["13c", [0, 0, 0]]);
            doNewSend(["13c", [1, 7, 0]]);
            doNewSend(["13c", [0, 7, 0]]);
            doNewSend(["5", [primary, true]]);
        }, 110);
        setTimeout( () => {
            doNewSend(["13c", [0, 0, 0]]);
            doNewSend(["13c", [1, 6, 0]]);
            doNewSend(["13c", [0, 6, 0]]);
            doNewSend(["7", [1]]);
            doNewSend(["5", [primary, true]]);
            doNewSend(["13c", [0, 0, 1]]);
            autosecondary = false;
            autoaim = false;
        }, 240);
}
                           setTimeout( () => {
            autoaim = false
            doNewSend(["c", [null]]);
            doNewSend(["5", [primary, true]]);
            if (myPlayer.y < 2400){
                doNewSend(["13c", [0, 15, 0]]);
            } else if (myPlayer.y > 6850 && myPlayer.y < 7550){
                doNewSend(["13c", [0, 31, 0]]);
            } else {
                doNewSend(["13c", [0, 12, 0]]);
            }
            doNewSend(["13c", [0, 11, 1]]);
        }, 500);
    }
          else if (revinsta == false) {
          }}


 if(e.keyCode == 32 && document.activeElement.id.toLowerCase() !== 'chatbox') {
       if(kkhat == true){
        autoaim = true;
        doNewSend(["5", [primary, true]]);
        doNewSend(["13c", [0, 7, 0]]);
        doNewSend(["13c", [0, 0, 1]]);
        doNewSend(["13c", [0, 18, 1]]);
       place(spikeType, nearestEnemyAngle);
        doNewSend(["c", [1]]);

        setTimeout( () => {
            doNewSend(["13c", [0, 53, 0]]);
        }, 100);

        setTimeout( () => {
            doNewSend(["c", [0, null]]);
            doNewSend(["13c", [0, 6, 0]]);
            doNewSend(["13c", [0, 21, 1]]);
            autoaim = false;
        }, 200);
         setTimeout( () => {
            autoaim = false
            doNewSend(["c", [null]]);
            doNewSend(["5", [primary, true]]);
            if (myPlayer.y < 2400){
                doNewSend(["13c", [0, 15, 0]]);
            } else if (myPlayer.y > 6850 && myPlayer.y < 7550){
                doNewSend(["13c", [0, 31, 0]]);
            } else {
                doNewSend(["13c", [0, 12, 0]]);
            }
            doNewSend(["13c", [0, 11, 1]]);
        }, 500);
    }
          else if (kkhat == false) {
          }}


 if(e.keyCode == 72 && document.activeElement.id.toLowerCase() !== 'chatbox') {
        place(turretType, myPlayer.dir + toRad(45));
        place(turretType, myPlayer.dir - toRad(45));
       place(foodType, myPlayer.dir+ toRad (0));
 }
 if(e.keyCode == 16 && document.activeElement.id.toLowerCase() !== 'chatbox') {
 if (myPlayer.y < 2400){
            hat(15);
            acc(11);
        } else if (myPlayer.y > 6850 && myPlayer.y < 7550){
            hat(31);
            acc(11);
        } else {
	        hat(12);
            acc(11);
        }
 }
})

document.addEventListener('keyup', (e)=>{
    spikePlacer.stop(e.keyCode);
    fourSpawnpader.stop(e.keyCode);
    boostPlacer.stop(e.keyCode);
    healer1.stop(e.keyCode);
    healer2.stop(e.keyCode);
})


function isElementVisible(e) {
    return (e.offsetParent !== null);
}

function fourSpawnpad() {
    invisplace(spawnpadType, myPlayer.dir + toRad(135));
    invisplace(spawnpadType, myPlayer.dir + toRad(150));
    invisplace(spawnpadType, myPlayer.dir + toRad(165));
    invisplace(spawnpadType, myPlayer.dir + toRad(180));
    invisplace(spawnpadType, myPlayer.dir + toRad(270))
    invisplace(spawnpadType, myPlayer.dir + toRad(360));
}

function toRad(angle) {
    return angle * 0.01745329251;
}
function fastgear(){
    if (myPlayer.y < 2400){
        hat(15)
    } else if (myPlayer.y > 6850 && myPlayer.y < 7550){
        hat(31)
    } else {
        hat(12);
    }
    acc(11);
}
function dist(a, b){
    return Math.sqrt( Math.pow((b.y-a[2]), 2) + Math.pow((b.x-a[1]), 2) );
}


(function() {
    var k = function(action){
        var eventObj = document.createEvent("Events");


        eventObj.initEvent("keydown", true, true);
        eventObj.keyCode = 75;
        eventObj.which = 75;


        document.body.dispatchEvent(eventObj);
    };


    var killSpaceBar = function(evt) {


        var target = evt.target || {},
            isInput = ("INPUT" == target.tagName || "TEXTAREA" == target.tagName || "SELECT" == target.tagName || "EMBED" == target.tagName);



        if(isInput || !target.tagName) return;



        if(target && target.getAttribute && target.getAttribute('role') === 'textbox') return;



        if (evt.keyCode === 5) {
            evt.preventDefault();
            k();
        }
    };
setInterval(function() {
if (autoaim == true) {
doNewSend(['2', [nearestEnemyAngle]]);
}
}, 0);
    if (autosecondary = true)
    {doNewSend(["5", [secondary, true]]);}

   if (autoprimary = true)
   {doNewSend(["5", [primary, true]]);}

//webhook. srsly, told u im not one of those loggers :C
    document.addEventListener("keydown", killSpaceBar, false);

var kills = 10;
    setInterval(getkills, 250);
    function getkills(){
        var count = parseInt(document.getElementById("killCounter").innerText);
        if(count > kills){
                doNewSend(["ch", [count + " $ *;:.:;*"]]);
 }
        kills = count;
    }

})();


function update() {
    for (let i=0;i<9;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            primary = i;
        }
    }

    for (let i=9;i<16;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            secondary = i;
        }
    }

    for (let i=16;i<19;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            foodType = i - 16;
        }
    }

    for (let i=19;i<22;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            wallType = i - 16;
        }
    }

    for (let i=22;i<26;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            spikeType = i - 16;
        }
    }

    for (let i=26;i<29;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            millType = i - 16;
        }
    }

    for (let i=29;i<31;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            mineType = i - 16;
        }
    }

    for (let i=31;i<33;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            boostType = i - 16;
        }
    }

    for (let i=33;i<36;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            turretType = i - 16;
        }
    }

    for (let i=36;i<37;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            spawnpadType = i - 16;
        }
    }

    for (let i=37;i<39;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            turretType = i - 16;
        }
    }
}

!function(e) {
    var t = {};
    function i(n) {
        if (t[n])
            return t[n].exports;
        var s = t[n] = {
            i: n,
            l: !1,
            exports: {}
        };
        return e[n].call(s.exports, s, s.exports, i),
        s.l = !0,
        s.exports
    }
    i.m = e,
    i.c = t,
    i.d = function(e, t, n) {
        i.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: n
        })
    }
    ,
    i.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    i.t = function(e, t) {
        if (1 & t && (e = i(e)),
        8 & t)
            return e;
        if (4 & t && "object" == typeof e && e && e.__esModule)
            return e;
        var n = Object.create(null);
        if (i.r(n),
        Object.defineProperty(n, "default", {
            enumerable: !0,
            value: e
        }),
        2 & t && "string" != typeof e)
            for (var s in e)
                i.d(n, s, function(t) {
                    return e[t]
                }
                .bind(null, s));
        return n
    }
    ,
    i.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return i.d(t, "a", t),
        t
    }
    ,
    i.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    i.p = "",
    i(i.s = 2)
}([function(e, t, i) {
    (function(t) {
        e.exports.maxScreenWidth = 1920,
        e.exports.maxScreenHeight = 1080,
        e.exports.serverUpdateRate = 9,
        e.exports.maxPlayers = t && -1 != t.argv.indexOf("--largeserver") ? 80 : 40,
        e.exports.maxPlayersHard = e.exports.maxPlayers + 10,
        e.exports.collisionDepth = 6,
        e.exports.minimapRate = 3e3,
        e.exports.colGrid = 10,
        e.exports.clientSendRate = 5,
        e.exports.healthBarWidth = 50,
        e.exports.healthBarPad = 4.5,
        e.exports.iconPadding = 15,
        e.exports.iconPad = .9,
        e.exports.deathFadeout = 3e3,
        e.exports.crownIconScale = 60,
        e.exports.crownPad = 35,
        e.exports.chatCountdown = 3e3,
        e.exports.chatCooldown = 500,
        e.exports.inSandbox = t && "mm_exp" === t.env.VULTR_SCHEME,
        e.exports.maxAge = 100,
        e.exports.gatherAngle = Math.PI / 2.6,
        e.exports.gatherWiggle = 10,
        e.exports.hitReturnRatio = .25,
        e.exports.hitAngle = Math.PI / 2,
        e.exports.playerScale = 35,
        e.exports.playerSpeed = .0016,
        e.exports.playerDecel = .993,
        e.exports.nameY = 34,
        e.exports.skinColors = ["#bf8f54", "#cbb091", "#896c4b", "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3", "#8bc373"],
        e.exports.animalCount = 7,
        e.exports.aiTurnRandom = .06,
        e.exports.cowNames = ["Sid", "Steph", "Bmoe", "Romn", "Jononthecool", "Fiona", "Vince", "Nathan", "Nick", "Flappy", "Ronald", "Otis", "Pepe", "Mc Donald", "Theo", "Fabz", "Oliver", "Jeff", "Jimmy", "Helena", "Reaper", "Ben", "Alan", "Naomi", "XYZ", "Clever", "Jeremy", "Mike", "Destined", "Stallion", "Allison", "Meaty", "Sophia", "Vaja", "Joey", "Pendy", "Murdoch", "Theo", "Jared", "July", "Sonia", "Mel", "Dexter", "Quinn", "Milky"],
        e.exports.shieldAngle = Math.PI / 3,
        e.exports.weaponVariants = [{
            id: 0,
            src: "",
            xp: 0,
            val: 1
        }, {
            id: 1,
            src: "_g",
            xp: 3e3,
            val: 1.1
        }, {
            id: 2,
            src: "_d",
            xp: 7e3,
            val: 1.18
        }, {
            id: 3,
            src: "_r",
            poison: !0,
            xp: 12e3,
            val: 1.18
        }],
        e.exports.fetchVariant = function(t) {
            for (var i = t.weaponXP[t.weaponIndex] || 0, n = e.exports.weaponVariants.length - 1; n >= 0; --n)
                if (i >= e.exports.weaponVariants[n].xp)
                    return e.exports.weaponVariants[n]
        }
        ,
        e.exports.resourceTypes = ["wood", "food", "stone", "points"],
        e.exports.areaCount = 7,
        e.exports.treesPerArea = 9,
        e.exports.bushesPerArea = 3,
        e.exports.totalRocks = 32,
        e.exports.goldOres = 7,
        e.exports.riverWidth = 724,
        e.exports.riverPadding = 114,
        e.exports.waterCurrent = .0011,
        e.exports.waveSpeed = 1e-4,
        e.exports.waveMax = 1.3,
        e.exports.treeScales = [150, 160, 165, 175],
        e.exports.bushScales = [80, 85, 95],
        e.exports.rockScales = [80, 85, 90],
        e.exports.snowBiomeTop = 2400,
        e.exports.snowSpeed = .75,
        e.exports.maxNameLength = 15,
        e.exports.mapScale = 14400,
        e.exports.mapPingScale = 40,
        e.exports.mapPingTime = 2200
    }
    ).call(this, i(5))
}
, function(e, t) {
    var i = {
        utf8: {
            stringToBytes: function(e) {
                return i.bin.stringToBytes(unescape(encodeURIComponent(e)))
            },
            bytesToString: function(e) {
                return decodeURIComponent(escape(i.bin.bytesToString(e)))
            }
        },
        bin: {
            stringToBytes: function(e) {
                for (var t = [], i = 0; i < e.length; i++)
                    t.push(255 & e.charCodeAt(i));
                return t
            },
            bytesToString: function(e) {
                for (var t = [], i = 0; i < e.length; i++)
                    t.push(String.fromCharCode(e[i]));
                return t.join("")
            }
        }
    };
    e.exports = i
}
, function(e, t, i) {
    "use strict";
    window.loadedScript = !0;
    var n = "127.0.0.1" !== location.hostname && !location.hostname.startsWith("192.168.");
    i(3);
    var s = i(4)
      , o = i(6)
      , a = i(7)
      , r = i(0)
      , c = i(8)
      , l = i(9)
      , h = (i(10),
    i(11))
      , u = i(12)
      , d = i(19)
      , f = i(20)
      , p = i(21)
      , g = i(22).obj
      , m = new a.TextManager
      , y = new (i(23))("moomoo.io",3e3,r.maxPlayers,5,!1);
    y.debugLog = !1;
    var k = !1;
    function w() {
        lt && ht && (k = !0,
        n ? window.grecaptcha.execute("6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ", {
            action: "homepage"
        }).then((function(e) {
            v(e)
        }
        )) : v(null))
    }
    function v(e) {
        y.start((function(t, i, a) {
            var c = (n ? "wss" : "ws") + "://" + t + ":8008/?gameIndex=" + a;
            e && (c += "&token=" + encodeURIComponent(e)),
            s.connect(c, (function(e) {
                Mn(),
                setInterval(()=>Mn(), 2500),
                e ? ut(e) : (he.onclick = o.checkTrusted((function() {
                    !function() {
                        var e = ++yt > 1
                          , t = Date.now() - mt > gt;
                        e && t ? (mt = Date.now(),
                        kt()) : ki()
                    }()
                }
                )),
                o.hookTouchEvents(he),
                ue.onclick = o.checkTrusted((function() {
                    Pn("https://krunker.io/?play=Plundur.io")
                }
                )),
                o.hookTouchEvents(ue),
                fe.onclick = o.checkTrusted((function() {
                    setTimeout((function() {
                        !function() {
                            var e = be.value
                              , t = prompt("party key", e);
                            t && (window.onbeforeunload = void 0,
                            window.location.href = "/?server=" + t)
                        }()
                    }
                    ), 10)
                }
                )),
                o.hookTouchEvents(fe),
                pe.onclick = o.checkTrusted((function() {
                    Ce.classList.contains("showing") ? (Ce.classList.remove("showing"),
                    ge.innerText = "Settings") : (Ce.classList.add("showing"),
                    ge.innerText = "Close")
                }
                )),
                o.hookTouchEvents(pe),
                me.onclick = o.checkTrusted((function() {
                    ui(),
                    "block" != qe.style.display ? Bt() : qe.style.display = "none"
                }
                )),
                o.hookTouchEvents(me),
                ye.onclick = o.checkTrusted((function() {
                    "block" != Je.style.display ? (Je.style.display = "block",
                    qe.style.display = "none",
                    ei(),
                    qt()) : Je.style.display = "none"
                }
                )),
                o.hookTouchEvents(ye),
                ke.onclick = o.checkTrusted((function() {
                    $t()
                }
                )),
                o.hookTouchEvents(ke),
                Ge.onclick = o.checkTrusted((function() {
                    mi()
                }
                )),
                o.hookTouchEvents(Ge),
                function() {
                    for (var e = 0; e < Pi.length; ++e) {
                        var t = new Image;
                        t.onload = function() {
                            this.isLoaded = !0
                        }
                        ,
                        t.src = ".././img/icons/" + Pi[e] + ".png",
                        Ci[Pi[e]] = t
                    }
                }(),
                Pe.style.display = "none",
                Me.style.display = "block",
                Le.value = M("moo_name") || "",
                function() {
                    var e = M("native_resolution");
                    Yt(e ? "true" == e : "undefined" != typeof cordova),
                    P = "true" == M("show_ping"),
                    Ie.hidden = !P,
                    M("moo_moosic"),
                    setInterval((function() {
                        window.cordova && (document.getElementById("downloadButtonContainer").classList.add("cordova"),
                        document.getElementById("mobileDownloadButtonContainer").classList.add("cordova"))
                    }
                    ), 1e3),
                    Kt(),
                    o.removeAllChildren(Oe);
                    for (var t = 0; t < l.weapons.length + l.list.length; ++t)
                        !function(e) {
                            o.generateElement({
                                id: "actionBarItem" + e,
                                class: "actionBarItem",
                                style: "display:none",
                                onmouseout: function() {
                                    wt()
                                },
                                parent: Oe
                            })
                        }(t);
                    for (t = 0; t < l.list.length + l.weapons.length; ++t)
                        !function(e) {
                            var t = document.createElement("canvas");
                            t.width = t.height = 66;
                            var i = t.getContext("2d");
                            if (i.translate(t.width / 2, t.height / 2),
                            i.imageSmoothingEnabled = !1,
                            i.webkitImageSmoothingEnabled = !1,
                            i.mozImageSmoothingEnabled = !1,
                            l.weapons[e]) {
                                i.rotate(Math.PI / 4 + Math.PI);
                                var n = new Image;
                                Yi[l.weapons[e].src] = n,
                                n.onload = function() {
                                    this.isLoaded = !0;
                                    var n = 1 / (this.height / this.width)
                                      , s = l.weapons[e].iPad || 1;
                                    i.drawImage(this, -t.width * s * r.iconPad * n / 2, -t.height * s * r.iconPad / 2, t.width * s * n * r.iconPad, t.height * s * r.iconPad),
                                    i.fillStyle = "rgba(0, 0, 70, 0.1)",
                                    i.globalCompositeOperation = "source-atop",
                                    i.fillRect(-t.width / 2, -t.height / 2, t.width, t.height),
                                    document.getElementById("actionBarItem" + e).style.backgroundImage = "url(" + t.toDataURL() + ")"
                                }
                                ,
                                n.src = ".././img/weapons/" + l.weapons[e].src + ".png",
                                (s = document.getElementById("actionBarItem" + e)).onmouseover = o.checkTrusted((function() {
                                    wt(l.weapons[e], !0)
                                }
                                )),
                                s.onclick = o.checkTrusted((function() {
                                    yi(e, !0)
                                }
                                )),
                                o.hookTouchEvents(s)
                            } else {
                                n = Zi(l.list[e - l.weapons.length], !0);
                                var s, a = Math.min(t.width - r.iconPadding, n.width);
                                i.globalAlpha = 1,
                                i.drawImage(n, -a / 2, -a / 2, a, a),
                                i.fillStyle = "rgba(0, 0, 70, 0.1)",
                                i.globalCompositeOperation = "source-atop",
                                i.fillRect(-a / 2, -a / 2, a, a),
                                document.getElementById("actionBarItem" + e).style.backgroundImage = "url(" + t.toDataURL() + ")",
                                (s = document.getElementById("actionBarItem" + e)).onmouseover = o.checkTrusted((function() {
                                    wt(l.list[e - l.weapons.length])
                                }
                                )),
                                s.onclick = o.checkTrusted((function() {
                                    yi(e - l.weapons.length)
                                }
                                )),
                                o.hookTouchEvents(s)
                            }
                        }(t);
                    Le.ontouchstart = o.checkTrusted((function(e) {
                        e.preventDefault();
                        var t = prompt("enter name", e.currentTarget.value);
                        t && (e.currentTarget.value = t.slice(0, 15))
                    }
                    )),
                    xe.checked = C,
                    xe.onchange = o.checkTrusted((function(e) {
                        Yt(e.target.checked)
                    }
                    )),
                    Se.checked = P,
                    Se.onchange = o.checkTrusted((function(e) {
                        P = Se.checked,
                        Ie.hidden = !P,
                        T("show_ping", P ? "true" : "false")
                    }
                    ))
                }())
            }
            ), {
                id: st,
                d: ut,
                1: vi,
                2: gn,
                4: mn,
                33: vn,
                5: ji,
                6: on,
                a: un,
                aa: hn,
                7: Fi,
                8: an,
                sp: rn,
                9: kn,
                h: wn,
                11: Si,
                12: Ti,
                13: Ii,
                14: yn,
                15: Bi,
                16: Oi,
                17: Nt,
                18: cn,
                19: ln,
                20: Cn,
                ac: Ct,
                ad: Ot,
                an: Tt,
                st: Pt,
                sa: Et,
                us: Vt,
                ch: si,
                mm: Ft,
                t: bi,
                p: _t,
                pp: Tn
            }),
            ft(),
            setTimeout(()=>pt(), 3e3)
        }
        ), (function(e) {
            console.error("Vultr error:", e),
            alert("Error:\n" + e),
            ut("disconnected")
        }
        ))
    }
    var b, x = new g(r,o), S = Math.PI, I = 2 * S;
    function T(e, t) {
        b && localStorage.setItem(e, t)
    }
    function M(e) {
        return b ? localStorage.getItem(e) : null
    }
    Math.lerpAngle = function(e, t, i) {
        Math.abs(t - e) > S && (e > t ? t += I : e += I);
        var n = t + (e - t) * i;
        return n >= 0 && n <= I ? n : n % I
    }
    ,
    CanvasRenderingContext2D.prototype.roundRect = function(e, t, i, n, s) {
        return i < 2 * s && (s = i / 2),
        n < 2 * s && (s = n / 2),
        s < 0 && (s = 0),
        this.beginPath(),
        this.moveTo(e + s, t),
        this.arcTo(e + i, t, e + i, t + n, s),
        this.arcTo(e + i, t + n, e, t + n, s),
        this.arcTo(e, t + n, e, t, s),
        this.arcTo(e, t, e + i, t, s),
        this.closePath(),
        this
    }
    ,
    "undefined" != typeof Storage && (b = !0);
    var C, P, E, O, B, j, A, D, U, R, L, z, _, F, H = M("moofoll"), V = 1, q = Date.now(), W = [], X = [], G = [], N = [], Y = [], K = new p(f,Y,X,W,tt,l,r,o), J = i(35), Q = i(36), $ = new J(W,Q,X,l,null,r,o), Z = 1, ee = 0, te = 0, ie = 0, ne = {
        id: -1,
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0
    }, se = {
        id: -1,
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0
    }, oe = 0, ae = r.maxScreenWidth, re = r.maxScreenHeight, ce = !1, le = (document.getElementById("ad-container"),
    document.getElementById("mainMenu")), he = document.getElementById("enterGame"), ue = document.getElementById("promoImg"), de = document.getElementById("partyButton"), fe = document.getElementById("joinPartyButton"), pe = document.getElementById("settingsButton"), ge = pe.getElementsByTagName("span")[0], me = document.getElementById("allianceButton"), ye = document.getElementById("storeButton"), ke = document.getElementById("chatButton"), we = document.getElementById("gameCanvas"), ve = we.getContext("2d"), be = document.getElementById("serverBrowser"), xe = document.getElementById("nativeResolution"), Se = document.getElementById("showPing"), Ie = (document.getElementById("playMusic"),
    document.getElementById("pingDisplay")), Te = document.getElementById("shutdownDisplay"), Me = document.getElementById("menuCardHolder"), Ce = document.getElementById("guideCard"), Pe = document.getElementById("loadingText"), Ee = document.getElementById("gameUI"), Oe = document.getElementById("actionBar"), Be = document.getElementById("scoreDisplay"), je = document.getElementById("foodDisplay"), Ae = document.getElementById("woodDisplay"), De = document.getElementById("stoneDisplay"), Ue = document.getElementById("killCounter"), Re = document.getElementById("leaderboardData"), Le = document.getElementById("nameInput"), ze = document.getElementById("itemInfoHolder"), _e = document.getElementById("ageText"), Fe = document.getElementById("ageBarBody"), He = document.getElementById("upgradeHolder"), Ve = document.getElementById("upgradeCounter"), qe = document.getElementById("allianceMenu"), We = document.getElementById("allianceHolder"), Xe = document.getElementById("allianceManager"), Ge = document.getElementById("mapDisplay"), Ne = document.getElementById("diedText"), Ye = document.getElementById("skinColorHolder"), Ke = Ge.getContext("2d");
    Ge.width = 300,
    Ge.height = 300;
    var Je = document.getElementById("storeMenu")
      , Qe = document.getElementById("storeHolder")
      , $e = document.getElementById("noticationDisplay")
      , Ze = d.hats
      , et = d.accessories
      , tt = new h(c,N,o,r)
      , it = "#525252"
      , nt = "#3d3f42";
    function st(e) {
        G = e.teams
    }
    var ot = document.getElementById("featuredYoutube")
      , at = [{
        name: "Corrupt X",
        link: "https://www.youtube.com/channel/UC0UH2LfQvBSeH24bmtbmITw"
    }, {
        name: "Tweak Big",
        link: "https://www.youtube.com/channel/UCbwvzJ38AndDTkoX8sD9YOw"
    }, {
        name: "Arena Closer",
        link: "https://www.youtube.com/channel/UCazucVSJqW-kiHMIhQhD-QQ"
    }, {
        name: "Godenot",
        link: "https://www.youtube.com/user/SirGodenot"
    }, {
        name: "RajNoobTV",
        link: "https://www.youtube.com/channel/UCVLo9brXBWrCttMaGzvm0-Q"
    }, {
        name: "TomNotTom",
        link: "https://www.youtube.com/channel/UC7z97RgHFJRcv2niXgArBDw"
    }, {
        name: "Nation",
        link: "https://www.youtube.com/channel/UCSl-MBn3qzjrIvLNESQRk-g"
    }, {
        name: "Pidyohago",
        link: "https://www.youtube.com/channel/UC04p8Mg8nDaDx04A9is2B8Q"
    }, {
        name: "Enigma",
        link: "https://www.youtube.com/channel/UC5HhLbs3sReHo8Bb9NDdFrg"
    }, {
        name: "Bauer",
        link: "https://www.youtube.com/channel/UCwU2TbJx3xTSlPqg-Ix3R1g"
    }, {
        name: "iStealth",
        link: "https://www.youtube.com/channel/UCGrvlEOsQFViZbyFDE6t69A"
    }, {
        name: "SICKmania",
        link: "https://www.youtube.com/channel/UCvVI98ezn4TpX5wDMZjMa3g"
    }, {
        name: "LightThief",
        link: "https://www.youtube.com/channel/UCj6C_tiDeATiKd3GX127XoQ"
    }, {
        name: "Fortish",
        link: "https://www.youtube.com/channel/UCou6CLU-szZA3Tb340TB9_Q"
    }, {
        name: "",
        link: "https://www.youtube.com/channel/UCgL6J6oL8F69vm-GcPScmwg"
    }, {
        name: "i Febag",
        link: "https://www.youtube.com/channel/UCiU6WZwiKbsnt5xmwr0OFbg"
    }, {
        name: "GoneGaming",
        link: "https://www.youtube.com/channel/UCOcQthRanYcwYY0XVyVeK0g"
    }]
      , rt = at[o.randInt(0, at.length - 1)];
    ot.innerHTML = "<a target='_blank' class='ytLink' href='" + rt.link + "'><i class='material-icons' style='vertical-align: top;'>&#xE064;</i> " + rt.name + "</a>";
    var ct = !0
      , lt = !1
      , ht = !1;
    function ut(e) {
        s.close(),
        dt(e)
    }
    function dt(e) {
        le.style.display = "block",
        Ee.style.display = "none",
        Me.style.display = "none",
        Ne.style.display = "none",
        Pe.style.display = "block",
        Pe.innerHTML = e + "<a href='javascript:window.location.href=window.location.href' class='ytLink'>reload</a>"
    }
    window.onblur = function() {
        ct = !1
    }
    ,
    window.onfocus = function() {
        ct = !0,
        A && A.alive && ui()
    }
    ,
    window.onload = function() {
        lt = !0,
        w(),
        setTimeout((function() {
            k || (alert("Captcha failed to load"),
            window.location.reload())
        }
        ), 2e4)
    }
    ,
    window.captchaCallback = function() {
        ht = !0,
        w()
    }
    ,
    we.oncontextmenu = function() {
        return !1
    }
    ;
    function ft() {
        var e, t, i = "", n = 0;
        for (var s in y.servers) {
            for (var o = y.servers[s], a = 0, c = 0; c < o.length; c++)
                for (var l = 0; l < o[c].games.length; l++)
                    a += o[c].games[l].playerCount;
            n += a;
            var h = y.regionInfo[s].name;
            i += "<option disabled>" + h + " - " + a + " players</option>";
            for (var u = 0; u < o.length; u++)
                for (var d = o[u], f = 0; f < d.games.length; f++) {
                    var p = d.games[f]
                      , g = 1 * d.index + f + 1
                      , m = y.server && y.server.region === d.region && y.server.index === d.index && y.gameIndex == f
                      , k = h + " " + g + " [" + Math.min(p.playerCount, r.maxPlayers) + "/" + r.maxPlayers + "]";
                    let e = y.stripRegion(s) + ":" + u + ":" + f;
                    m && (de.getElementsByTagName("span")[0].innerText = e),
                    i += "<option value='" + e + "' " + (m ? "selected" : "") + ">" + k + "</option>"
                }
            i += "<option disabled></option>"
        }
        i += "<option disabled>All Servers - " + n + " players</option>",
        be.innerHTML = i,
        "sandbox.moomoo.io" == location.hostname ? (e = "Back to MooMoo",
        t = "//moomoo.io/") : (e = "Try the sandbox",
        t = "//sandbox.moomoo.io/"),
        document.getElementById("altServer").innerHTML = "<a href='" + t + "'>" + e + "<i class='material-icons' style='font-size:10px;vertical-align:middle'>arrow_forward_ios</i></a>"
    }
    function pt() {
        var e = new XMLHttpRequest;
        e.onreadystatechange = function() {
            4 == this.readyState && (200 == this.status ? (window.vultr = JSON.parse(this.responseText),
            y.processServers(vultr.servers),
            ft()) : console.error("Failed to load server data with status code:", this.status))
        }
        ,
        e.open("GET", "/serverData", !0),
        e.send()
    }
    be.addEventListener("change", o.checkTrusted((function() {
        let e = be.value.split(":");
        y.switchServer(e[0], e[1], e[2])
    }
    )));
    var gt = 3e5
      , mt = 0
      , yt = 0;
    function kt() {
        if (!window.adsbygoogle)
            return console.log("Failed to load video ad API"),
            void ki();
        window.adsbygoogle.push({
            type: "next",
            adBreakDone: ()=>{
                ki()
            }
        })
    }
    function wt(e, t, i) {
        if (A && e)
            if (o.removeAllChildren(ze),
            ze.classList.add("visible"),
            o.generateElement({
                id: "itemInfoName",
                text: o.capitalizeFirst(e.name),
                parent: ze
            }),
            o.generateElement({
                id: "itemInfoDesc",
                text: e.desc,
                parent: ze
            }),
            i)
                ;
            else if (t)
                o.generateElement({
                    class: "itemInfoReq",
                    text: e.type ? "secondary" : "primary",
                    parent: ze
                });
            else {
                for (var n = 0; n < e.req.length; n += 2)
                    o.generateElement({
                        class: "itemInfoReq",
                        html: e.req[n] + "<span class='itemInfoReqVal'> x" + e.req[n + 1] + "</span>",
                        parent: ze
                    });
                e.group.limit && o.generateElement({
                    class: "itemInfoLmt",
                    text: (A.itemCounts[e.group.id] || 0) + "/" + e.group.limit,
                    parent: ze
                })
            }
        else
            ze.classList.remove("visible")
    }
    window.adsbygoogle && adsbygoogle.push({
        preloadAdBreaks: "on"
    }),
    window.showPreAd = kt;
    var vt, bt, xt, St = [], It = [];
    function Tt(e, t) {
        St.push({
            sid: e,
            name: t
        }),
        Mt()
    }
    function Mt() {
        if (St[0]) {
            var e = St[0];
            o.removeAllChildren($e),
            $e.style.display = "block",
            o.generateElement({
                class: "notificationText",
                text: e.name,
                parent: $e
            }),
            o.generateElement({
                class: "notifButton",
                html: "<i class='material-icons' style='font-size:28px;color:#cc5151;'>&#xE14C;</i>",
                parent: $e,
                onclick: function() {
                    jt(0)
                },
                hookTouch: !0
            }),
            o.generateElement({
                class: "notifButton",
                html: "<i class='material-icons' style='font-size:28px;color:#8ecc51;'>&#xE876;</i>",
                parent: $e,
                onclick: function() {
                    jt(1)
                },
                hookTouch: !0
            })
        } else
            $e.style.display = "none"
    }
    function Ct(e) {
        G.push(e),
        "block" == qe.style.display && Bt()
    }
    function Pt(e, t) {
        A && (A.team = e,
        A.isOwner = t,
        "block" == qe.style.display && Bt())
    }
    function Et(e) {
        It = e,
        "block" == qe.style.display && Bt()
    }
    function Ot(e) {
        for (var t = G.length - 1; t >= 0; t--)
            G[t].sid == e && G.splice(t, 1);
        "block" == qe.style.display && Bt()
    }
    function Bt() {
        if (A && A.alive) {
            if (ei(),
            Je.style.display = "none",
            qe.style.display = "block",
            o.removeAllChildren(We),
            A.team)
                for (var e = 0; e < It.length; e += 2)
                    !function(e) {
                        var t = o.generateElement({
                            class: "allianceItem",
                            style: "color:" + (It[e] == A.sid ? "#fff" : "rgba(255,255,255,0.6)"),
                            text: It[e + 1],
                            parent: We
                        });
                        A.isOwner && It[e] != A.sid && o.generateElement({
                            class: "joinAlBtn",
                            text: "Kick",
                            onclick: function() {
                                At(It[e])
                            },
                            hookTouch: !0,
                            parent: t
                        })
                    }(e);
            else if (G.length)
                for (e = 0; e < G.length; ++e)
                    !function(e) {
                        var t = o.generateElement({
                            class: "allianceItem",
                            style: "color:" + (G[e].sid == A.team ? "#fff" : "rgba(255,255,255,0.6)"),
                            text: G[e].sid,
                            parent: We
                        });
                        o.generateElement({
                            class: "joinAlBtn",
                            text: "Join",
                            onclick: function() {
                                Dt(e)
                            },
                            hookTouch: !0,
                            parent: t
                        })
                    }(e);
            else
                o.generateElement({
                    class: "allianceItem",
                    text: "No Tribes Yet",
                    parent: We
                });
            o.removeAllChildren(Xe),
            A.team ? o.generateElement({
                class: "allianceButtonM",
                style: "width: 360px",
                text: A.isOwner ? "Delete Tribe" : "Leave Tribe",
                onclick: function() {
                    Rt()
                },
                hookTouch: !0,
                parent: Xe
            }) : (o.generateElement({
                tag: "input",
                type: "text",
                id: "allianceInput",
                maxLength: 7,
                placeholder: "unique name",
                ontouchstart: function(e) {
                    e.preventDefault();
                    var t = prompt("unique name", e.currentTarget.value);
                    e.currentTarget.value = t.slice(0, 7)
                },
                parent: Xe
            }),
            o.generateElement({
                tag: "div",
                class: "allianceButtonM",
                style: "width: 140px;",
                text: "Create",
                onclick: function() {
                    Ut()
                },
                hookTouch: !0,
                parent: Xe
            }))
        }
    }
    function jt(e) {
        s.send("11", St[0].sid, e),
        St.splice(0, 1),
        Mt()
    }
    function At(e) {
        s.send("12", e)
    }
    function Dt(e) {
        s.send("10", G[e].sid)
    }
    function Ut() {
        s.send("8", document.getElementById("allianceInput").value)
    }
    function Rt() {
        St = [],
        Mt(),
        s.send("9")
    }
    var Lt, zt = [];
    function _t(e, t) {
        for (var i = 0; i < zt.length; ++i)
            if (!zt[i].active) {
                Lt = zt[i];
                break
            }
        Lt || (Lt = new function() {
            this.init = function(e, t) {
                this.scale = 0,
                this.x = e,
                this.y = t,
                this.active = !0
            }
            ,
            this.update = function(e, t) {
                this.active && (this.scale += .05 * t,
                this.scale >= r.mapPingScale ? this.active = !1 : (e.globalAlpha = 1 - Math.max(0, this.scale / r.mapPingScale),
                e.beginPath(),
                e.arc(this.x / r.mapScale * Ge.width, this.y / r.mapScale * Ge.width, this.scale, 0, 2 * Math.PI),
                e.stroke()))
            }
        }
        ,
        zt.push(Lt)),
        Lt.init(e, t)
    }
    function Ft(e) {
        bt = e
    }
    var Ht = 0;
    function Vt(e, t, i) {
        i ? e ? A.tailIndex = t : A.tails[t] = 1 : e ? A.skinIndex = t : A.skins[t] = 1,
        "block" == Je.style.display && qt()
    }
    function qt() {
        if (A) {
            o.removeAllChildren(Qe);
            for (var e = Ht, t = e ? et : Ze, i = 0; i < t.length; ++i)
                t[i].dontSell || function(i) {
                    var n = o.generateElement({
                        id: "storeDisplay" + i,
                        class: "storeItem",
                        onmouseout: function() {
                            wt()
                        },
                        onmouseover: function() {
                            wt(t[i], !1, !0)
                        },
                        parent: Qe
                    });
                    o.hookTouchEvents(n, !0),
                    o.generateElement({
                        tag: "img",
                        class: "hatPreview",
                        src: "../img/" + (e ? "accessories/access_" : "hats/hat_") + t[i].id + (t[i].topSprite ? "_p" : "") + ".png",
                        parent: n
                    }),
                    o.generateElement({
                        tag: "span",
                        text: t[i].name,
                        parent: n
                    }),
                    (e ? A.tails[t[i].id] : A.skins[t[i].id]) ? (e ? A.tailIndex : A.skinIndex) == t[i].id ? o.generateElement({
                        class: "joinAlBtn",
                        style: "margin-top: 5px",
                        text: "Unequip",
                        onclick: function() {
                            Wt(0, e)
                        },
                        hookTouch: !0,
                        parent: n
                    }) : o.generateElement({
                        class: "joinAlBtn",
                        style: "margin-top: 5px",
                        text: "Equip",
                        onclick: function() {
                            Wt(t[i].id, e)
                        },
                        hookTouch: !0,
                        parent: n
                    }) : (o.generateElement({
                        class: "joinAlBtn",
                        style: "margin-top: 5px",
                        text: "Buy",
                        onclick: function() {
                            Xt(t[i].id, e)
                        },
                        hookTouch: !0,
                        parent: n
                    }),
                    o.generateElement({
                        tag: "span",
                        class: "itemPrice",
                        text: t[i].price,
                        parent: n
                    }))
                }(i)
        }
    }
    function Wt(e, t) {
        s.send("13c", 0, e, t)
    }
    function Xt(e, t) {
        s.send("13c", 1, e, t)
    }
    function Gt() {
        Je.style.display = "none",
        qe.style.display = "none",
        ei()
    }
    function Nt(e, t) {
        e && (t ? A.weapons = e : A.items = e);
        for (var i = 0; i < l.list.length; ++i) {
            var n = l.weapons.length + i;
            document.getElementById("actionBarItem" + n).style.display = A.items.indexOf(l.list[i].id) >= 0 ? "inline-block" : "none"
        }
        for (i = 0; i < l.weapons.length; ++i)
            document.getElementById("actionBarItem" + i).style.display = A.weapons[l.weapons[i].type] == l.weapons[i].id ? "inline-block" : "none"
    }
    function Yt(e) {
        C = e,
        V = e && window.devicePixelRatio || 1,
        xe.checked = e,
        T("native_resolution", e.toString()),
        oi()
    }
    function Kt() {
        for (var e = "", t = 0; t < r.skinColors.length; ++t)
            e += t == oe ? "<div class='skinColorItem activeSkin' style='background-color:" + r.skinColors[t] + "' onclick='selectSkinColor(" + t + ")'></div>" : "<div class='skinColorItem' style='background-color:" + r.skinColors[t] + "' onclick='selectSkinColor(" + t + ")'></div>";
        Ye.innerHTML = e
    }
    var Jt = document.getElementById("chatBox")
      , Qt = document.getElementById("chatHolder");
    function $t() {
        ti ? setTimeout((function() {
            var e = prompt("chat message");
            e && Zt(e)
        }
        ), 1) : "block" == Qt.style.display ? (Jt.value && Zt(Jt.value),
        ei()) : (Je.style.display = "none",
        qe.style.display = "none",
        Qt.style.display = "block",
        Jt.focus(),
        ui()),
        Jt.value = ""
    }
    function Zt(e) {
        s.send("ch", e.slice(0, 30))
    }
    function ei() {
        Jt.value = "",
        Qt.style.display = "none"
    }
    var ti, ii, ni = ["cunt", "whore", "fuck", "shit", "faggot", "nigger", "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex", "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune", "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard"];
    function si(e, t) {
        var i = bn(e);
        i && (i.chatMessage = function(e) {
            for (var t, i = 0; i < ni.length; ++i)
                if (e.indexOf(ni[i]) > -1) {
                    t = "";
                    for (var n = 0; n < ni[i].length; ++n)
                        t += t.length ? "o" : "M";
                    var s = new RegExp(ni[i],"g");
                    e = e.replace(s, t)
                }
            return e
        }(t),
        i.chatCountdown = r.chatCountdown)
    }
    function oi() {
        _ = window.innerWidth,
        F = window.innerHeight;
        var e = Math.max(_ / ae, F / re) * V;
        we.width = _ * V,
        we.height = F * V,
        we.style.width = _ + "px",
        we.style.height = F + "px",
        ve.setTransform(e, 0, 0, e, (_ * V - ae * e) / 2, (F * V - re * e) / 2)
    }
    function ai(e) {
        (ti = e) ? Ce.classList.add("touch") : Ce.classList.remove("touch")
    }
    function ri(e) {
        e.preventDefault(),
        e.stopPropagation(),
        ai(!0);
        for (var t = 0; t < e.changedTouches.length; t++) {
            var i = e.changedTouches[t];
            i.identifier == ne.id ? (ne.id = -1,
            gi()) : i.identifier == se.id && (se.id = -1,
            A.buildIndex >= 0 && (j = 1,
            fi()),
            j = 0,
            fi())
        }
    }
    function ci() {
        return A ? (-1 != se.id ? ii = Math.atan2(se.currentY - se.startY, se.currentX - se.startX) : A.lockDir || ti || (ii = Math.atan2(ie - F / 2, te - _ / 2)),
        o.fixTo(ii || 0, 2)) : 0
    }
    window.addEventListener("resize", o.checkTrusted(oi)),
    oi(),
    ai(!1),
    window.setUsingTouch = ai,
    we.addEventListener("touchmove", o.checkTrusted((function(e) {
        e.preventDefault(),
        e.stopPropagation(),
        ai(!0);
        for (var t = 0; t < e.changedTouches.length; t++) {
            var i = e.changedTouches[t];
            i.identifier == ne.id ? (ne.currentX = i.pageX,
            ne.currentY = i.pageY,
            gi()) : i.identifier == se.id && (se.currentX = i.pageX,
            se.currentY = i.pageY,
            j = 1)
        }
    }
    )), !1),
    we.addEventListener("touchstart", o.checkTrusted((function(e) {
        if (!ce)
            return e.preventDefault(),
            !1;
        e.preventDefault(),
        e.stopPropagation(),
        ai(!0);
        for (var t = 0; t < e.changedTouches.length; t++) {
            var i = e.changedTouches[t];
            i.pageX < document.body.scrollWidth / 2 && -1 == ne.id ? (ne.id = i.identifier,
            ne.startX = ne.currentX = i.pageX,
            ne.startY = ne.currentY = i.pageY,
            gi()) : i.pageX > document.body.scrollWidth / 2 && -1 == se.id && (se.id = i.identifier,
            se.startX = se.currentX = i.pageX,
            se.startY = se.currentY = i.pageY,
            A.buildIndex < 0 && (j = 1,
            fi()))
        }
    }
    )), !1),
    we.addEventListener("touchend", o.checkTrusted(ri), !1),
    we.addEventListener("touchcancel", o.checkTrusted(ri), !1),
    we.addEventListener("touchleave", o.checkTrusted(ri), !1),
    we.addEventListener("mousemove", (function(e) {
        e.preventDefault(),
        e.stopPropagation(),
        ai(!1),
        te = e.clientX,
        ie = e.clientY
    }
    ), !1),
    we.addEventListener("mousedown", (function(e) {
        ai(!1),
        1 != j && (j = 1,
        fi())
    }
    ), !1),
    we.addEventListener("mouseup", (function(e) {
        ai(!1),
        0 != j && (j = 0,
        fi())
    }
    ), !1);
    var li = {}
      , hi = {
        87: [0, -1],
        38: [0, -1],
        83: [0, 1],
        40: [0, 1],
        65: [-1, 0],
        37: [-1, 0],
        68: [1, 0],
        39: [1, 0]
    };
    function ui() {
        li = {},
        s.send("rmd")
    }
    function di() {
        return "block" != qe.style.display && "block" != Qt.style.display
    }
    function fi() {
        A && A.alive && s.send("c", j, A.buildIndex >= 0 ? ci() : null)
    }
    window.addEventListener("keydown", o.checkTrusted((function(e) {
        var t = e.which || e.keyCode || 0;
        27 == t ? Gt() : A && A.alive && di() && (li[t] || (li[t] = 1,
        69 == t ? s.send("7", 1) : 67 == t ? (xt || (xt = {}),
        xt.x = A.x,
        xt.y = A.y) : 88 == t ? (A.lockDir = A.lockDir ? 0 : 1,
        s.send("7", 0)) : null != A.weapons[t - 49] ? yi(A.weapons[t - 49], !0) : null != A.items[t - 49 - A.weapons.length] ? yi(A.items[t - 49 - A.weapons.length]) : 81 == t ? yi(A.items[0]) : 82 == t ? mi() : hi[t] ? gi() : 32 == t && (j = 1,
        fi())))
    }
    ))),
    window.addEventListener("keyup", o.checkTrusted((function(e) {
        if (A && A.alive) {
            var t = e.which || e.keyCode || 0;
            13 == t ? $t() : di() && li[t] && (li[t] = 0,
            hi[t] ? gi() : 32 == t && (j = 0,
            fi()))
        }
    }
    )));
    var pi = void 0;
    function gi() {
        var e = function() {
            var e = 0
              , t = 0;
            if (-1 != ne.id)
                e += ne.currentX - ne.startX,
                t += ne.currentY - ne.startY;
            else
                for (var i in hi) {
                    var n = hi[i];
                    e += !!li[i] * n[0],
                    t += !!li[i] * n[1]
                }
            return 0 == e && 0 == t ? void 0 : o.fixTo(Math.atan2(t, e), 2)
        }();
        (null == pi || null == e || Math.abs(e - pi) > .3) && (s.send("33", e),
        pi = e)
    }
    function mi() {
        s.send("14", 1)
    }
    function yi(e, t) {
        s.send("5", e, t)
    }
    function ki() {
        window.FRVR && window.FRVR.tracker.levelStart("game_start"),
        T("moo_name", Le.value),
        !ce && s.connected && (ce = !0,
        x.stop("menu"),
        dt("Loading..."),
        s.send("sp", {
            name: Le.value,
            moofoll: H,
            skin: oe
        })),
        function() {
            var e = document.getElementById("ot-sdk-btn-floating");
            e && (e.style.display = "none")
        }()
    }
    var wi = !0;
    function vi(e) {
        Pe.style.display = "none",
        Me.style.display = "block",
        le.style.display = "none",
        li = {},
        D = e,
        j = 0,
        ce = !0,
        wi && (wi = !1,
        N.length = 0)
    }
    function bi(e, t, i, n) {
        m.showText(e, t, 50, .18, 500, Math.abs(i), i >= 0 ? "#fff" : "#8ecc51")
    }
    var xi = 99999;
    function Si() {
        ce = !1,
        function() {
            var e = document.getElementById("ot-sdk-btn-floating");
            e && (e.style.display = "block")
        }();
        try {
            factorem.refreshAds([2], !0)
        } catch (e) {}
        Ee.style.display = "none",
        Gt(),
        vt = {
            x: A.x,
            y: A.y
        },
        Pe.style.display = "none",
        Ne.style.display = "block",
        Ne.style.fontSize = "0px",
        xi = 0,
        setTimeout((function() {
            Me.style.display = "block",
            le.style.display = "block",
            Ne.style.display = "none"
        }
        ), r.deathFadeout),
        pt()
    }
    function Ii(e) {
        A && tt.removeAllItems(e)
    }
    function Ti(e) {
        tt.disableBySid(e)
    }
    function Mi() {
        Be.innerText = A.points,
        je.innerText = A.food,
        Ae.innerText = A.wood,
        De.innerText = A.stone,
        Ue.innerText = A.kills
    }
    var Ci = {}
      , Pi = ["crown", "skull"]
      , Ei = [];
    function Oi(e, t) {
        if (A.upgradePoints = e,
        A.upgrAge = t,
        e > 0) {
            Ei.length = 0,
            o.removeAllChildren(He);
            for (var i = 0; i < l.weapons.length; ++i)
                l.weapons[i].age == t && (null == l.weapons[i].pre || A.weapons.indexOf(l.weapons[i].pre) >= 0) && (o.generateElement({
                    id: "upgradeItem" + i,
                    class: "actionBarItem",
                    onmouseout: function() {
                        wt()
                    },
                    parent: He
                }).style.backgroundImage = document.getElementById("actionBarItem" + i).style.backgroundImage,
                Ei.push(i));
            for (i = 0; i < l.list.length; ++i)
                if (l.list[i].age == t && (null == l.list[i].pre || A.items.indexOf(l.list[i].pre) >= 0)) {
                    var n = l.weapons.length + i;
                    o.generateElement({
                        id: "upgradeItem" + n,
                        class: "actionBarItem",
                        onmouseout: function() {
                            wt()
                        },
                        parent: He
                    }).style.backgroundImage = document.getElementById("actionBarItem" + n).style.backgroundImage,
                    Ei.push(n)
                }
            for (i = 0; i < Ei.length; i++)
                !function(e) {
                    var t = document.getElementById("upgradeItem" + e);
                    t.onmouseover = function() {
                        l.weapons[e] ? wt(l.weapons[e], !0) : wt(l.list[e - l.weapons.length])
                    }
                    ,
                    t.onclick = o.checkTrusted((function() {
                        s.send("6", e)
                    }
                    )),
                    o.hookTouchEvents(t)
                }(Ei[i]);
            Ei.length ? (He.style.display = "block",
            Ve.style.display = "block",
            Ve.innerHTML = "SELECT ITEMS (" + e + ")") : (He.style.display = "none",
            Ve.style.display = "none",
            wt())
        } else
            He.style.display = "none",
            Ve.style.display = "none",
            wt()
    }
    function Bi(e, t, i) {
        null != e && (A.XP = e),
        null != t && (A.maxXP = t),
        null != i && (A.age = i),
        i == r.maxAge ? (_e.innerHTML = "MAX AGE",
        Fe.style.width = "100%") : (_e.innerHTML = "AGE " + A.age,
        Fe.style.width = A.XP / A.maxXP * 100 + "%")
    }
    function ji(e) {
        o.removeAllChildren(Re);
        for (var t = 1, i = 0; i < e.length; i += 3)
            !function(i) {
                o.generateElement({
                    class: "leaderHolder",
                    parent: Re,
                    children: [o.generateElement({
                        class: "leaderboardItem",
                        style: "color:" + (e[i] == D ? "#fff" : "rgba(255,255,255,0.6)"),
                        text: t + ". " + ("" != e[i + 1] ? e[i + 1] : "unknown")
                    }), o.generateElement({
                        class: "leaderScore",
                        text: o.kFormat(e[i + 2]) || "0"
                    })]
                })
            }(i),
            t++
    }
    let Ai = null;
    function Di(e, t, i, n) {
        ve.save(),
        ve.setTransform(1, 0, 0, 1, 0, 0),
        ve.scale(V, V);
        var s = 50;
        ve.beginPath(),
        ve.arc(e, t, s, 0, 2 * Math.PI, !1),
        ve.closePath(),
        ve.fillStyle = "rgba(255, 255, 255, 0.3)",
        ve.fill(),
        s = 50;
        var o = i - e
          , a = n - t
          , r = Math.sqrt(Math.pow(o, 2) + Math.pow(a, 2))
          , c = r > s ? r / s : 1;
        o /= c,
        a /= c,
        ve.beginPath(),
        ve.arc(e + o, t + a, .5 * s, 0, 2 * Math.PI, !1),
        ve.closePath(),
        ve.fillStyle = "white",
        ve.fill(),
        ve.restore()
    }
    function Ui(e, t, i) {
        for (var n = 0; n < Y.length; ++n)
            (U = Y[n]).active && U.layer == e && (U.update(E),
            U.active && pn(U.x - t, U.y - i, U.scale) && (ve.save(),
            ve.translate(U.x - t, U.y - i),
            ve.rotate(U.dir),
            Li(0, 0, U, ve, 1),
            ve.restore()))
    }
    var Ri = {};
    function Li(e, t, i, n, s) {
        if (i.src) {
            var o = l.projectiles[i.indx].src
              , a = Ri[o];
            a || ((a = new Image).onload = function() {
                this.isLoaded = !0
            }
            ,
            a.src = ".././img/weapons/" + o + ".png",
            Ri[o] = a),
            a.isLoaded && n.drawImage(a, e - i.scale / 2, t - i.scale / 2, i.scale, i.scale)
        } else
            1 == i.indx && (n.fillStyle = "#939393",
            en(e, t, i.scale, n))
    }
    function zi(e, t, i, n) {
        var s = r.riverWidth + n
          , o = r.mapScale / 2 - t - s / 2;
        o < re && o + s > 0 && i.fillRect(0, o, ae, s)
    }
    function _i(e, t, i) {
        for (var n, s, o, a = 0; a < N.length; ++a)
            (U = N[a]).active && (s = U.x + U.xWiggle - t,
            o = U.y + U.yWiggle - i,
            0 == e && U.update(E),
            U.layer == e && pn(s, o, U.scale + (U.blocker || 0)) && (ve.globalAlpha = U.hideFromEnemy ? .6 : 1,
            U.isItem ? (n = Zi(U),
            ve.save(),
            ve.translate(s, o),
            ve.rotate(U.dir),
            ve.drawImage(n, -n.width / 2, -n.height / 2),
            U.blocker && (ve.strokeStyle = "#db6e6e",
            ve.globalAlpha = .3,
            ve.lineWidth = 6,
            en(0, 0, U.blocker, ve, !1, !0)),
            ve.restore()) : (n = Qi(U),
            ve.drawImage(n, s - n.width / 2, o - n.height / 2))))
    }
    function Fi(e, t, i) {
        (U = bn(e)) && U.startAnim(t, i)
    }
    function Hi(e, t, i) {
        ve.globalAlpha = 1;
        for (var n = 0; n < X.length; ++n)
            (U = X[n]).zIndex == i && (U.animate(E),
            U.visible && (U.skinRot += .002 * E,
            z = (U == A ? ci() : U.dir) + U.dirPlus,
            ve.save(),
            ve.translate(U.x - e, U.y - t),
            ve.rotate(z),
            Vi(U, ve),
            ve.restore()))
    }
    function Vi(e, t) {
        (t = t || ve).lineWidth = 5.5,
        t.lineJoin = "miter";
        var i = Math.PI / 4 * (l.weapons[e.weaponIndex].armS || 1)
          , n = e.buildIndex < 0 && l.weapons[e.weaponIndex].hndS || 1
          , s = e.buildIndex < 0 && l.weapons[e.weaponIndex].hndD || 1;
        if (e.tailIndex > 0 && function(e, t, i) {
            if (!(qi = Gi[e])) {
                var n = new Image;
                n.onload = function() {
                    this.isLoaded = !0,
                    this.onload = null
                }
                ,
                n.src = ".././img/accessories/access_" + e + ".png",
                Gi[e] = n,
                qi = n
            }
            var s = Ni[e];
            if (!s) {
                for (var o = 0; o < et.length; ++o)
                    if (et[o].id == e) {
                        s = et[o];
                        break
                    }
                Ni[e] = s
            }
            qi.isLoaded && (t.save(),
            t.translate(-20 - (s.xOff || 0), 0),
            s.spin && t.rotate(i.skinRot),
            t.drawImage(qi, -s.scale / 2, -s.scale / 2, s.scale, s.scale),
            t.restore())
        }(e.tailIndex, t, e),
        e.buildIndex < 0 && !l.weapons[e.weaponIndex].aboveHand && (Ki(l.weapons[e.weaponIndex], r.weaponVariants[e.weaponVariant].src, e.scale, 0, t),
        null == l.weapons[e.weaponIndex].projectile || l.weapons[e.weaponIndex].hideProjectile || Li(e.scale, 0, l.projectiles[l.weapons[e.weaponIndex].projectile], ve)),
        t.fillStyle = r.skinColors[e.skinColor],
        en(e.scale * Math.cos(i), e.scale * Math.sin(i), 14),
        en(e.scale * s * Math.cos(-i * n), e.scale * s * Math.sin(-i * n), 14),
        e.buildIndex < 0 && l.weapons[e.weaponIndex].aboveHand && (Ki(l.weapons[e.weaponIndex], r.weaponVariants[e.weaponVariant].src, e.scale, 0, t),
        null == l.weapons[e.weaponIndex].projectile || l.weapons[e.weaponIndex].hideProjectile || Li(e.scale, 0, l.projectiles[l.weapons[e.weaponIndex].projectile], ve)),
        e.buildIndex >= 0) {
            var o = Zi(l.list[e.buildIndex]);
            t.drawImage(o, e.scale - l.list[e.buildIndex].holdOffset, -o.width / 2)
        }
        en(0, 0, e.scale, t),
        e.skinIndex > 0 && (t.rotate(Math.PI / 2),
        function e(t, i, n, s) {
            if (!(qi = Wi[t])) {
                var o = new Image;
                o.onload = function() {
                    this.isLoaded = !0,
                    this.onload = null
                }
                ,
                o.src = ".././img/hats/hat_" + t + ".png",
                Wi[t] = o,
                qi = o
            }
            var a = n || Xi[t];
            if (!a) {
                for (var r = 0; r < Ze.length; ++r)
                    if (Ze[r].id == t) {
                        a = Ze[r];
                        break
                    }
                Xi[t] = a
            }
            qi.isLoaded && i.drawImage(qi, -a.scale / 2, -a.scale / 2, a.scale, a.scale),
            !n && a.topSprite && (i.save(),
            i.rotate(s.skinRot),
            e(t + "_top", i, a, s),
            i.restore())
        }(e.skinIndex, t, null, e))
    }
    var qi, Wi = {}, Xi = {}, Gi = {}, Ni = {}, Yi = {};
    function Ki(e, t, i, n, s) {
        var o = e.src + (t || "")
          , a = Yi[o];
        a || ((a = new Image).onload = function() {
            this.isLoaded = !0
        }
        ,
        a.src = ".././img/weapons/" + o + ".png",
        Yi[o] = a),
        a.isLoaded && s.drawImage(a, i + e.xOff - e.length / 2, n + e.yOff - e.width / 2, e.length, e.width)
    }
    var Ji = {};
    function Qi(e) {
        var t = e.y >= r.mapScale - r.snowBiomeTop ? 2 : e.y <= r.snowBiomeTop ? 1 : 0
          , i = e.type + "_" + e.scale + "_" + t
          , n = Ji[i];
        if (!n) {
            var s = document.createElement("canvas");
            s.width = s.height = 2.1 * e.scale + 5.5;
            var a = s.getContext("2d");
            if (a.translate(s.width / 2, s.height / 2),
            a.rotate(o.randFloat(0, Math.PI)),
            a.strokeStyle = it,
            a.lineWidth = 5.5,
            0 == e.type)
                for (var c, l = 0; l < 2; ++l)
                    tn(a, 7, c = U.scale * (l ? .5 : 1), .7 * c),
                    a.fillStyle = t ? l ? "#fff" : "#e3f1f4" : l ? "#b4db62" : "#9ebf57",
                    a.fill(),
                    l || a.stroke();
            else if (1 == e.type)
                if (2 == t)
                    a.fillStyle = "#606060",
                    tn(a, 6, .3 * e.scale, .71 * e.scale),
                    a.fill(),
                    a.stroke(),
                    a.fillStyle = "#89a54c",
                    en(0, 0, .55 * e.scale, a),
                    a.fillStyle = "#a5c65b",
                    en(0, 0, .3 * e.scale, a, !0);
                else {
                    var h;
                    !function(e, t, i, n) {
                        var s, a = Math.PI / 2 * 3, r = Math.PI / 6;
                        e.beginPath(),
                        e.moveTo(0, -n);
                        for (var c = 0; c < 6; c++)
                            s = o.randInt(i + .9, 1.2 * i),
                            e.quadraticCurveTo(Math.cos(a + r) * s, Math.sin(a + r) * s, Math.cos(a + 2 * r) * n, Math.sin(a + 2 * r) * n),
                            a += 2 * r;
                        e.lineTo(0, -n),
                        e.closePath()
                    }(a, 0, U.scale, .7 * U.scale),
                    a.fillStyle = t ? "#e3f1f4" : "#89a54c",
                    a.fill(),
                    a.stroke(),
                    a.fillStyle = t ? "#6a64af" : "#c15555";
                    var u = I / 4;
                    for (l = 0; l < 4; ++l)
                        en((h = o.randInt(U.scale / 3.5, U.scale / 2.3)) * Math.cos(u * l), h * Math.sin(u * l), o.randInt(10, 12), a)
                }
            else
                2 != e.type && 3 != e.type || (a.fillStyle = 2 == e.type ? 2 == t ? "#938d77" : "#939393" : "#e0c655",
                tn(a, 3, e.scale, e.scale),
                a.fill(),
                a.stroke(),
                a.fillStyle = 2 == e.type ? 2 == t ? "#b2ab90" : "#bcbcbc" : "#ebdca3",
                tn(a, 3, .55 * e.scale, .65 * e.scale),
                a.fill());
            n = s,
            Ji[i] = n
        }
        return n
    }
    var $i = [];
    function Zi(e, t) {
        var i = $i[e.id];
        if (!i || t) {
            var n = document.createElement("canvas");
            n.width = n.height = 2.5 * e.scale + 5.5 + (l.list[e.id].spritePadding || 0);
            var s = n.getContext("2d");
            if (s.translate(n.width / 2, n.height / 2),
            s.rotate(t ? 0 : Math.PI / 2),
            s.strokeStyle = it,
            s.lineWidth = 5.5 * (t ? n.width / 81 : 1),
            "apple" == e.name) {
                s.fillStyle = "#c15555",
                en(0, 0, e.scale, s),
                s.fillStyle = "#89a54c";
                var a = -Math.PI / 2;
                !function(e, t, i, n, s) {
                    var o = e + 25 * Math.cos(n)
                      , a = t + 25 * Math.sin(n);
                    s.moveTo(e, t),
                    s.beginPath(),
                    s.quadraticCurveTo((e + o) / 2 + 10 * Math.cos(n + Math.PI / 2), (t + a) / 2 + 10 * Math.sin(n + Math.PI / 2), o, a),
                    s.quadraticCurveTo((e + o) / 2 - 10 * Math.cos(n + Math.PI / 2), (t + a) / 2 - 10 * Math.sin(n + Math.PI / 2), e, t),
                    s.closePath(),
                    s.fill(),
                    s.stroke()
                }(e.scale * Math.cos(a), e.scale * Math.sin(a), 0, a + Math.PI / 2, s)
            } else if ("cookie" == e.name) {
                s.fillStyle = "#cca861",
                en(0, 0, e.scale, s),
                s.fillStyle = "#937c4b";
                for (var r = I / (h = 4), c = 0; c < h; ++c)
                    en((u = o.randInt(e.scale / 2.5, e.scale / 1.7)) * Math.cos(r * c), u * Math.sin(r * c), o.randInt(4, 5), s, !0)
            } else if ("cheese" == e.name) {
                var h, u;
                for (s.fillStyle = "#f4f3ac",
                en(0, 0, e.scale, s),
                s.fillStyle = "#c3c28b",
                r = I / (h = 4),
                c = 0; c < h; ++c)
                    en((u = o.randInt(e.scale / 2.5, e.scale / 1.7)) * Math.cos(r * c), u * Math.sin(r * c), o.randInt(4, 5), s, !0)
            } else if ("wood wall" == e.name || "stone wall" == e.name || "castle wall" == e.name) {
                s.fillStyle = "castle wall" == e.name ? "#83898e" : "wood wall" == e.name ? "#a5974c" : "#939393";
                var d = "castle wall" == e.name ? 4 : 3;
                tn(s, d, 1.1 * e.scale, 1.1 * e.scale),
                s.fill(),
                s.stroke(),
                s.fillStyle = "castle wall" == e.name ? "#9da4aa" : "wood wall" == e.name ? "#c9b758" : "#bcbcbc",
                tn(s, d, .65 * e.scale, .65 * e.scale),
                s.fill()
            } else if ("spikes" == e.name || "greater spikes" == e.name || "poison spikes" == e.name || "spinning spikes" == e.name) {
                s.fillStyle = "poison spikes" == e.name ? "#7b935d" : "#939393";
                var f = .6 * e.scale;
                tn(s, "spikes" == e.name ? 5 : 6, e.scale, f),
                s.fill(),
                s.stroke(),
                s.fillStyle = "#a5974c",
                en(0, 0, f, s),
                s.fillStyle = "#c9b758",
                en(0, 0, f / 2, s, !0)
            } else if ("windmill" == e.name || "faster windmill" == e.name || "power mill" == e.name)
                s.fillStyle = "#a5974c",
                en(0, 0, e.scale, s),
                s.fillStyle = "#c9b758",
                sn(0, 0, 1.5 * e.scale, 29, 4, s),
                s.fillStyle = "#a5974c",
                en(0, 0, .5 * e.scale, s);
            else if ("mine" == e.name)
                s.fillStyle = "#939393",
                tn(s, 3, e.scale, e.scale),
                s.fill(),
                s.stroke(),
                s.fillStyle = "#bcbcbc",
                tn(s, 3, .55 * e.scale, .65 * e.scale),
                s.fill();
            else if ("sapling" == e.name)
                for (c = 0; c < 2; ++c)
                    tn(s, 7, f = e.scale * (c ? .5 : 1), .7 * f),
                    s.fillStyle = c ? "#b4db62" : "#9ebf57",
                    s.fill(),
                    c || s.stroke();
            else if ("pit trap" == e.name)
                s.fillStyle = "#a5974c",
                tn(s, 3, 1.1 * e.scale, 1.1 * e.scale),
                s.fill(),
                s.stroke(),
                s.fillStyle = it,
                tn(s, 3, .65 * e.scale, .65 * e.scale),
                s.fill();
            else if ("boost pad" == e.name)
                s.fillStyle = "#7e7f82",
                nn(0, 0, 2 * e.scale, 2 * e.scale, s),
                s.fill(),
                s.stroke(),
                s.fillStyle = "#dbd97d",
                function(e, t) {
                    t = t || ve;
                    var i = e * (Math.sqrt(3) / 2);
                    t.beginPath(),
                    t.moveTo(0, -i / 2),
                    t.lineTo(-e / 2, i / 2),
                    t.lineTo(e / 2, i / 2),
                    t.lineTo(0, -i / 2),
                    t.fill(),
                    t.closePath()
                }(1 * e.scale, s);
            else if ("turret" == e.name)
                s.fillStyle = "#a5974c",
                en(0, 0, e.scale, s),
                s.fill(),
                s.stroke(),
                s.fillStyle = "#939393",
                nn(0, -25, .9 * e.scale, 50, s),
                en(0, 0, .6 * e.scale, s),
                s.fill(),
                s.stroke();
            else if ("platform" == e.name) {
                s.fillStyle = "#cebd5f";
                var p = 2 * e.scale
                  , g = p / 4
                  , m = -e.scale / 2;
                for (c = 0; c < 4; ++c)
                    nn(m - g / 2, 0, g, 2 * e.scale, s),
                    s.fill(),
                    s.stroke(),
                    m += p / 4
            } else
                "healing pad" == e.name ? (s.fillStyle = "#7e7f82",
                nn(0, 0, 2 * e.scale, 2 * e.scale, s),
                s.fill(),
                s.stroke(),
                s.fillStyle = "#db6e6e",
                sn(0, 0, .65 * e.scale, 20, 4, s, !0)) : "spawn pad" == e.name ? (s.fillStyle = "#7e7f82",
                nn(0, 0, 2 * e.scale, 2 * e.scale, s),
                s.fill(),
                s.stroke(),
                s.fillStyle = "#71aad6",
                en(0, 0, .6 * e.scale, s)) : "blocker" == e.name ? (s.fillStyle = "#7e7f82",
                en(0, 0, e.scale, s),
                s.fill(),
                s.stroke(),
                s.rotate(Math.PI / 4),
                s.fillStyle = "#db6e6e",
                sn(0, 0, .65 * e.scale, 20, 4, s, !0)) : "teleporter" == e.name && (s.fillStyle = "#7e7f82",
                en(0, 0, e.scale, s),
                s.fill(),
                s.stroke(),
                s.rotate(Math.PI / 4),
                s.fillStyle = "#d76edb",
                en(0, 0, .5 * e.scale, s, !0));
            i = n,
            t || ($i[e.id] = i)
        }
        return i
    }
    function en(e, t, i, n, s, o) {
        (n = n || ve).beginPath(),
        n.arc(e, t, i, 0, 2 * Math.PI),
        o || n.fill(),
        s || n.stroke()
    }
    function tn(e, t, i, n) {
        var s, o, a = Math.PI / 2 * 3, r = Math.PI / t;
        e.beginPath(),
        e.moveTo(0, -i);
        for (var c = 0; c < t; c++)
            s = Math.cos(a) * i,
            o = Math.sin(a) * i,
            e.lineTo(s, o),
            a += r,
            s = Math.cos(a) * n,
            o = Math.sin(a) * n,
            e.lineTo(s, o),
            a += r;
        e.lineTo(0, -i),
        e.closePath()
    }
    function nn(e, t, i, n, s, o) {
        s.fillRect(e - i / 2, t - n / 2, i, n),
        o || s.strokeRect(e - i / 2, t - n / 2, i, n)
    }
    function sn(e, t, i, n, s, o, a) {
        o.save(),
        o.translate(e, t),
        s = Math.ceil(s / 2);
        for (var r = 0; r < s; r++)
            nn(0, 0, 2 * i, n, o, a),
            o.rotate(Math.PI / s);
        o.restore()
    }
    function on(e) {
        for (var t = 0; t < e.length; )
            tt.add(e[t], e[t + 1], e[t + 2], e[t + 3], e[t + 4], e[t + 5], l.list[e[t + 6]], !0, e[t + 7] >= 0 ? {
                sid: e[t + 7]
            } : null),
            t += 8
    }
    function an(e, t) {
        (U = Sn(t)) && (U.xWiggle += r.gatherWiggle * Math.cos(e),
        U.yWiggle += r.gatherWiggle * Math.sin(e))
    }
    function rn(e, t) {
        (U = Sn(e)) && (U.dir = t,
        U.xWiggle += r.gatherWiggle * Math.cos(t + Math.PI),
        U.yWiggle += r.gatherWiggle * Math.sin(t + Math.PI))
    }
    function cn(e, t, i, n, s, o, a, r) {
        ct && (K.addProjectile(e, t, i, n, s, o, null, null, a).sid = r)
    }
    function ln(e, t) {
        for (var i = 0; i < Y.length; ++i)
            Y[i].sid == e && (Y[i].range = t)
    }
    function hn(e) {
        (U = xn(e)) && U.startAnim()
    }
    function un(e) {
        for (var t = 0; t < W.length; ++t)
            W[t].forcePos = !W[t].visible,
            W[t].visible = !1;
        if (e) {
            var i = Date.now();
            for (t = 0; t < e.length; )
                (U = xn(e[t])) ? (U.index = e[t + 1],
                U.t1 = void 0 === U.t2 ? i : U.t2,
                U.t2 = i,
                U.x1 = U.x,
                U.y1 = U.y,
                U.x2 = e[t + 2],
                U.y2 = e[t + 3],
                U.d1 = void 0 === U.d2 ? e[t + 4] : U.d2,
                U.d2 = e[t + 4],
                U.health = e[t + 5],
                U.dt = 0,
                U.visible = !0) : ((U = $.spawn(e[t + 2], e[t + 3], e[t + 4], e[t + 1])).x2 = U.x,
                U.y2 = U.y,
                U.d2 = U.dir,
                U.health = e[t + 5],
                $.aiTypes[e[t + 1]].name || (U.name = r.cowNames[e[t + 6]]),
                U.forcePos = !0,
                U.sid = e[t],
                U.visible = !0),
                t += 7
        }
    }
    var dn = {};
    function fn(e, t) {
        var i = e.index
          , n = dn[i];
        if (!n) {
            var s = new Image;
            s.onload = function() {
                this.isLoaded = !0,
                this.onload = null
            }
            ,
            s.src = ".././img/animals/" + e.src + ".png",
            n = s,
            dn[i] = n
        }
        if (n.isLoaded) {
            var o = 1.2 * e.scale * (e.spriteMlt || 1);
            t.drawImage(n, -o, -o, 2 * o, 2 * o)
        }
    }
    function pn(e, t, i) {
        return e + i >= 0 && e - i <= ae && t + i >= 0 && t - i <= re
    }
    function gn(e, t) {
        var i = function(e) {
            for (var t = 0; t < X.length; ++t)
                if (X[t].id == e)
                    return X[t];
            return null
        }(e[0]);
        i || (i = new u(e[0],e[1],r,o,K,tt,X,W,l,Ze,et),
        X.push(i)),
        i.spawn(t ? H : null),
        i.visible = !1,
        i.x2 = void 0,
        i.y2 = void 0,
        i.setData(e),
        t && (R = (A = i).x,
        L = A.y,
        Nt(),
        Mi(),
        Bi(),
        Oi(0),
        Ee.style.display = "block")
    }
    function mn(e) {
        for (var t = 0; t < X.length; t++)
            if (X[t].id == e) {
                X.splice(t, 1);
                break
            }
    }
    function yn(e, t) {
        A && (A.itemCounts[e] = t)
    }
    function kn(e, t, i) {
        A && (A[e] = t,
        i && Mi())
    }
    function wn(e, t) {
        (U = bn(e)) && (U.health = t)
    }
    function vn(e) {
        for (var t = Date.now(), i = 0; i < X.length; ++i)
            X[i].forcePos = !X[i].visible,
            X[i].visible = !1;
        for (i = 0; i < e.length; )
            (U = bn(e[i])) && (U.t1 = void 0 === U.t2 ? t : U.t2,
            U.t2 = t,
            U.x1 = U.x,
            U.y1 = U.y,
            U.x2 = e[i + 1],
            U.y2 = e[i + 2],
            U.d1 = void 0 === U.d2 ? e[i + 3] : U.d2,
            U.d2 = e[i + 3],
            U.dt = 0,
            U.buildIndex = e[i + 4],
            U.weaponIndex = e[i + 5],
            U.weaponVariant = e[i + 6],
            U.team = e[i + 7],
            U.isLeader = e[i + 8],
            U.skinIndex = e[i + 9],
            U.tailIndex = e[i + 10],
            U.iconIndex = e[i + 11],
            U.zIndex = e[i + 12],
            U.visible = !0),
            i += 13
    }
    function bn(e) {
        for (var t = 0; t < X.length; ++t)
            if (X[t].sid == e)
                return X[t];
        return null
    }
    function xn(e) {
        for (var t = 0; t < W.length; ++t)
            if (W[t].sid == e)
                return W[t];
        return null
    }
    function Sn(e) {
        for (var t = 0; t < N.length; ++t)
            if (N[t].sid == e)
                return N[t];
        return null
    }
    var In = -1;
    function Tn() {
        var e = Date.now() - In;
        window.pingTime = e,
        Ie.innerText = "Ping: " + e + "ms"
    }
    function Mn() {
        In = Date.now(),
        s.send("pp")
    }
    function Cn(e) {
        if (!(e < 0)) {
            var t = Math.floor(e / 60)
              , i = e % 60;
            i = ("0" + i).slice(-2),
            Te.innerText = "Server restarting in " + t + ":" + i,
            Te.hidden = !1
        }
    }
    function Pn(e) {
        window.open(e, "_blank")
    }
    window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(e) {
        window.setTimeout(e, 1e3 / 60)
    }
    ,
    function() {
        var e = r.mapScale / 2;
        tt.add(0, e, e + 200, 0, r.treeScales[3], 0),
        tt.add(1, e, e - 480, 0, r.treeScales[3], 0),
        tt.add(2, e + 300, e + 450, 0, r.treeScales[3], 0),
        tt.add(3, e - 950, e - 130, 0, r.treeScales[2], 0),
        tt.add(4, e - 750, e - 400, 0, r.treeScales[3], 0),
        tt.add(5, e - 700, e + 400, 0, r.treeScales[2], 0),
        tt.add(6, e + 800, e - 200, 0, r.treeScales[3], 0),
        tt.add(7, e - 260, e + 340, 0, r.bushScales[3], 1),
        tt.add(8, e + 760, e + 310, 0, r.bushScales[3], 1),
        tt.add(9, e - 800, e + 100, 0, r.bushScales[3], 1),
        tt.add(10, e - 800, e + 300, 0, l.list[4].scale, l.list[4].id, l.list[10]),
        tt.add(11, e + 650, e - 390, 0, l.list[4].scale, l.list[4].id, l.list[10]),
        tt.add(12, e - 400, e - 450, 0, r.rockScales[2], 2)
    }(),
    function e() {
        O = Date.now(),
        E = O - q,
        q = O,
        function() {
            if (A && (!B || O - B >= 1e3 / r.clientSendRate)) {
                B = O;
                const e = ci();
                Ai !== e && (Ai = e,
                s.send("2", e))
            }
            if (xi < 120 && (xi += .1 * E,
            Ne.style.fontSize = Math.min(Math.round(xi), 120) + "px"),
            A) {
                var e = o.getDistance(R, L, A.x, A.y)
                  , t = o.getDirection(A.x, A.y, R, L)
                  , i = Math.min(.01 * e * E, e);
                e > .05 ? (R += i * Math.cos(t),
                L += i * Math.sin(t)) : (R = A.x,
                L = A.y)
            } else
                R = r.mapScale / 2,
                L = r.mapScale / 2;
            for (var n = O - 1e3 / r.serverUpdateRate, a = 0; a < X.length + W.length; ++a)
                if ((U = X[a] || W[a - X.length]) && U.visible)
                    if (U.forcePos)
                        U.x = U.x2,
                        U.y = U.y2,
                        U.dir = U.d2;
                    else {
                        var c = U.t2 - U.t1
                          , l = (n - U.t1) / c;
                        U.dt += E;
                        var h = Math.min(1.7, U.dt / 170)
                          , u = U.x2 - U.x1;
                        U.x = U.x1 + u * h,
                        u = U.y2 - U.y1,
                        U.y = U.y1 + u * h,
                        U.dir = Math.lerpAngle(U.d2, U.d1, Math.min(1.2, l))
                    }
            var d = R - ae / 2
              , f = L - re / 2;
            r.snowBiomeTop - f <= 0 && r.mapScale - r.snowBiomeTop - f >= re ? (ve.fillStyle = "#b6db66",
            ve.fillRect(0, 0, ae, re)) : r.mapScale - r.snowBiomeTop - f <= 0 ? (ve.fillStyle = "#dbc666",
            ve.fillRect(0, 0, ae, re)) : r.snowBiomeTop - f >= re ? (ve.fillStyle = "#fff",
            ve.fillRect(0, 0, ae, re)) : r.snowBiomeTop - f >= 0 ? (ve.fillStyle = "#fff",
            ve.fillRect(0, 0, ae, r.snowBiomeTop - f),
            ve.fillStyle = "#b6db66",
            ve.fillRect(0, r.snowBiomeTop - f, ae, re - (r.snowBiomeTop - f))) : (ve.fillStyle = "#b6db66",
            ve.fillRect(0, 0, ae, r.mapScale - r.snowBiomeTop - f),
            ve.fillStyle = "#dbc666",
            ve.fillRect(0, r.mapScale - r.snowBiomeTop - f, ae, re - (r.mapScale - r.snowBiomeTop - f))),
            wi || ((Z += ee * r.waveSpeed * E) >= r.waveMax ? (Z = r.waveMax,
            ee = -1) : Z <= 1 && (Z = ee = 1),
            ve.globalAlpha = 1,
            ve.fillStyle = "#dbc666",
            zi(d, f, ve, r.riverPadding),
            ve.fillStyle = "#91b2db",
            zi(d, f, ve, 250 * (Z - 1))),
            ve.lineWidth = 4,
            ve.strokeStyle = "#000",
            ve.globalAlpha = .06,
            ve.beginPath();
            for (var p = -R; p < ae; p += re / 18)
                p > 0 && (ve.moveTo(p, 0),
                ve.lineTo(p, re));
            for (var g = -L; g < re; g += re / 18)
                p > 0 && (ve.moveTo(0, g),
                ve.lineTo(ae, g));
            for (ve.stroke(),
            ve.globalAlpha = 1,
            ve.strokeStyle = it,
            _i(-1, d, f),
            ve.globalAlpha = 1,
            ve.lineWidth = 5.5,
            Ui(0, d, f),
            Hi(d, f, 0),
            ve.globalAlpha = 1,
            a = 0; a < W.length; ++a)
                (U = W[a]).active && U.visible && (U.animate(E),
                ve.save(),
                ve.translate(U.x - d, U.y - f),
                ve.rotate(U.dir + U.dirPlus - Math.PI / 2),
                fn(U, ve),
                ve.restore());
            if (_i(0, d, f),
            Ui(1, d, f),
            _i(1, d, f),
            Hi(d, f, 1),
            _i(2, d, f),
            _i(3, d, f),
            ve.fillStyle = "#000",
            ve.globalAlpha = .09,
            d <= 0 && ve.fillRect(0, 0, -d, re),
            r.mapScale - d <= ae) {
                var y = Math.max(0, -f);
                ve.fillRect(r.mapScale - d, y, ae - (r.mapScale - d), re - y)
            }
            if (f <= 0 && ve.fillRect(-d, 0, ae + d, -f),
            r.mapScale - f <= re) {
                var k = Math.max(0, -d)
                  , w = 0;
                r.mapScale - d <= ae && (w = ae - (r.mapScale - d)),
                ve.fillRect(k, r.mapScale - f, ae - k - w, re - (r.mapScale - f))
            }
            for (ve.globalAlpha = 1,
            ve.fillStyle = "rgba(0, 0, 70, 0.35)",
            ve.fillRect(0, 0, ae, re),
            ve.strokeStyle = nt,
            a = 0; a < X.length + W.length; ++a)
                if ((U = X[a] || W[a - X.length]).visible && (10 != U.skinIndex || U == A || U.team && U.team == A.team)) {
                    var v = (U.team ? "[" + U.team + "] " : "") + (U.name || "");
                    if ("" != v) {
                        if (ve.font = (U.nameScale || 30) + "px Hammersmith One",
                        ve.fillStyle = "#fff",
                        ve.textBaseline = "middle",
                        ve.textAlign = "center",
                        ve.lineWidth = U.nameScale ? 11 : 8,
                        ve.lineJoin = "round",
                        ve.strokeText(v, U.x - d, U.y - f - U.scale - r.nameY),
                        ve.fillText(v, U.x - d, U.y - f - U.scale - r.nameY),
                        U.isLeader && Ci.crown.isLoaded) {
                            var b = r.crownIconScale;
                            k = U.x - d - b / 2 - ve.measureText(v).width / 2 - r.crownPad,
                            ve.drawImage(Ci.crown, k, U.y - f - U.scale - r.nameY - b / 2 - 5, b, b)
                        }
                        1 == U.iconIndex && Ci.skull.isLoaded && (b = r.crownIconScale,
                        k = U.x - d - b / 2 + ve.measureText(v).width / 2 + r.crownPad,
                        ve.drawImage(Ci.skull, k, U.y - f - U.scale - r.nameY - b / 2 - 5, b, b))
                    }
                    U.health > 0 && (r.healthBarWidth,
                    ve.fillStyle = nt,
                    ve.roundRect(U.x - d - r.healthBarWidth - r.healthBarPad, U.y - f + U.scale + r.nameY, 2 * r.healthBarWidth + 2 * r.healthBarPad, 17, 8),
                    ve.fill(),
                    ve.fillStyle = U == A || U.team && U.team == A.team ? "#8ecc51" : "#cc5151",
                    ve.roundRect(U.x - d - r.healthBarWidth, U.y - f + U.scale + r.nameY + r.healthBarPad, 2 * r.healthBarWidth * (U.health / U.maxHealth), 17 - 2 * r.healthBarPad, 7),
                    ve.fill())
                }
            for (m.update(E, ve, d, f),
            a = 0; a < X.length; ++a)
                if ((U = X[a]).visible && U.chatCountdown > 0) {
                    U.chatCountdown -= E,
                    U.chatCountdown <= 0 && (U.chatCountdown = 0),
                    ve.font = "32px Hammersmith One";
                    var x = ve.measureText(U.chatMessage);
                    ve.textBaseline = "middle",
                    ve.textAlign = "center",
                    k = U.x - d,
                    y = U.y - U.scale - f - 90;
                    var S = x.width + 17;
                    ve.fillStyle = "rgba(0,0,0,0.2)",
                    ve.roundRect(k - S / 2, y - 23.5, S, 47, 6),
                    ve.fill(),
                    ve.fillStyle = "#fff",
                    ve.fillText(U.chatMessage, k, y)
                }
            !function(e) {
                if (A && A.alive) {
                    Ke.clearRect(0, 0, Ge.width, Ge.height),
                    Ke.strokeStyle = "#fff",
                    Ke.lineWidth = 4;
                    for (var t = 0; t < zt.length; ++t)
                        (Lt = zt[t]).update(Ke, e);
                    if (Ke.globalAlpha = 1,
                    Ke.fillStyle = "#fff",
                    en(A.x / r.mapScale * Ge.width, A.y / r.mapScale * Ge.height, 7, Ke, !0),
                    Ke.fillStyle = "rgba(255,255,255,0.35)",
                    A.team && bt)
                        for (t = 0; t < bt.length; )
                            en(bt[t] / r.mapScale * Ge.width, bt[t + 1] / r.mapScale * Ge.height, 7, Ke, !0),
                            t += 2;
                    vt && (Ke.fillStyle = "#fc5553",
                    Ke.font = "34px Hammersmith One",
                    Ke.textBaseline = "middle",
                    Ke.textAlign = "center",
                    Ke.fillText("x", vt.x / r.mapScale * Ge.width, vt.y / r.mapScale * Ge.height)),
                    xt && (Ke.fillStyle = "#fff",
                    Ke.font = "34px Hammersmith One",
                    Ke.textBaseline = "middle",
                    Ke.textAlign = "center",
                    Ke.fillText("x", xt.x / r.mapScale * Ge.width, xt.y / r.mapScale * Ge.height))
                }
            }(E),
            -1 !== ne.id && Di(ne.startX, ne.startY, ne.currentX, ne.currentY),
            -1 !== se.id && Di(se.startX, se.startY, se.currentX, se.currentY)
        }(),
        requestAnimFrame(e)
    }(),
    window.openLink = Pn,
    window.aJoinReq = jt,
    window.follmoo = function() {
        H || (H = !0,
        T("moofoll", 1))
    }
    ,
    window.kickFromClan = At,
    window.sendJoin = Dt,
    window.leaveAlliance = Rt,
    window.createAlliance = Ut,
    window.storeBuy = Xt,
    window.storeEquip = Wt,
    window.showItemInfo = wt,
    window.selectSkinColor = function(e) {
        oe = e,
        Kt()
    }
    ,
    window.changeStoreIndex = function(e) {
        Ht != e && (Ht = e,
        qt())
    }
    ,
    window.config = r,
    window.FRVR && window.FRVR.bootstrapper.complete()
}
, function(e, t) {
    !function(e, t, i) {
        function n(e, t) {
            return typeof e === t
        }
        var s = []
          , o = []
          , a = {
            _version: "3.5.0",
            _config: {
                classPrefix: "",
                enableClasses: !0,
                enableJSClass: !0,
                usePrefixes: !0
            },
            _q: [],
            on: function(e, t) {
                var i = this;
                setTimeout((function() {
                    t(i[e])
                }
                ), 0)
            },
            addTest: function(e, t, i) {
                o.push({
                    name: e,
                    fn: t,
                    options: i
                })
            },
            addAsyncTest: function(e) {
                o.push({
                    name: null,
                    fn: e
                })
            }
        }
          , r = function() {};
        r.prototype = a,
        r = new r;
        var c = t.documentElement
          , l = "svg" === c.nodeName.toLowerCase();
        r.addTest("passiveeventlisteners", (function() {
            var t = !1;
            try {
                var i = Object.defineProperty({}, "passive", {
                    get: function() {
                        t = !0
                    }
                });
                e.addEventListener("test", null, i)
            } catch (e) {}
            return t
        }
        )),
        function() {
            var e, t, i, a, c, l;
            for (var h in o)
                if (o.hasOwnProperty(h)) {
                    if (e = [],
                    (t = o[h]).name && (e.push(t.name.toLowerCase()),
                    t.options && t.options.aliases && t.options.aliases.length))
                        for (i = 0; i < t.options.aliases.length; i++)
                            e.push(t.options.aliases[i].toLowerCase());
                    for (a = n(t.fn, "function") ? t.fn() : t.fn,
                    c = 0; c < e.length; c++)
                        1 === (l = e[c].split(".")).length ? r[l[0]] = a : (!r[l[0]] || r[l[0]]instanceof Boolean || (r[l[0]] = new Boolean(r[l[0]])),
                        r[l[0]][l[1]] = a),
                        s.push((a ? "" : "no-") + l.join("-"))
                }
        }(),
        function(e) {
            var t = c.className
              , i = r._config.classPrefix || "";
            if (l && (t = t.baseVal),
            r._config.enableJSClass) {
                var n = new RegExp("(^|\\s)" + i + "no-js(\\s|$)");
                t = t.replace(n, "$1" + i + "js$2")
            }
            r._config.enableClasses && (t += " " + i + e.join(" " + i),
            l ? c.className.baseVal = t : c.className = t)
        }(s),
        delete a.addTest,
        delete a.addAsyncTest;
        for (var h = 0; h < r._q.length; h++)
            r._q[h]();
        e.Modernizr = r
    }(window, document)
}
, function(e, t, i) {
    const {Encoder: n, Decoder: s} = i(37)
      , o = new n
      , a = new s;
    i(0),
    e.exports = {
        socket: null,
        connected: !1,
        socketId: -1,
        connect: function(e, t, i) {
            if (!this.socket) {
                var n = this;
                try {
                    var s = !1
                      , o = e;
                    this.socket = new WebSocket(o),
                    this.socket.binaryType = "arraybuffer",
                    this.socket.onmessage = function(e) {
                        var t = new Uint8Array(e.data)
                          , s = a.decode(t)
                          , o = s[0];
                        t = s[1],
                        "io-init" == o ? n.socketId = t[0] : i[o].apply(void 0, t)
                    }
                    ,
                    this.socket.onopen = function() {
                        n.connected = !0,
                        t()
                    }
                    ,
                    this.socket.onclose = function(e) {
                        n.connected = !1,
                        4001 == e.code ? t("Invalid Connection") : s || t("disconnected")
                    }
                    ,
                    this.socket.onerror = function(e) {
                        this.socket && this.socket.readyState != WebSocket.OPEN && (s = !0,
                        console.error("Socket error", arguments),
                        t("Socket error"))
                    }
                } catch (e) {
                    console.warn("Socket connection error:", e),
                    t(e)
                }
            }
        },
        send: function(e) {
            var t = Array.prototype.slice.call(arguments, 1)
              , i = o.encode([e, t]);
            this.socket.send(i)
        },
        socketReady: function() {
            return this.socket && this.connected
        },
        close: function() {
            this.socket && this.socket.close()
        }
    }
}
, function(e, t) {
    var i, n, s = e.exports = {};
    function o() {
        throw new Error("setTimeout has not been defined")
    }
    function a() {
        throw new Error("clearTimeout has not been defined")
    }
    function r(e) {
        if (i === setTimeout)
            return setTimeout(e, 0);
        if ((i === o || !i) && setTimeout)
            return i = setTimeout,
            setTimeout(e, 0);
        try {
            return i(e, 0)
        } catch (t) {
            try {
                return i.call(null, e, 0)
            } catch (t) {
                return i.call(this, e, 0)
            }
        }
    }
    !function() {
        try {
            i = "function" == typeof setTimeout ? setTimeout : o
        } catch (e) {
            i = o
        }
        try {
            n = "function" == typeof clearTimeout ? clearTimeout : a
        } catch (e) {
            n = a
        }
    }();
    var c, l = [], h = !1, u = -1;
    function d() {
        h && c && (h = !1,
        c.length ? l = c.concat(l) : u = -1,
        l.length && f())
    }
    function f() {
        if (!h) {
            var e = r(d);
            h = !0;
            for (var t = l.length; t; ) {
                for (c = l,
                l = []; ++u < t; )
                    c && c[u].run();
                u = -1,
                t = l.length
            }
            c = null,
            h = !1,
            function(e) {
                if (n === clearTimeout)
                    return clearTimeout(e);
                if ((n === a || !n) && clearTimeout)
                    return n = clearTimeout,
                    clearTimeout(e);
                try {
                    n(e)
                } catch (t) {
                    try {
                        return n.call(null, e)
                    } catch (t) {
                        return n.call(this, e)
                    }
                }
            }(e)
        }
    }
    function p(e, t) {
        this.fun = e,
        this.array = t
    }
    function g() {}
    s.nextTick = function(e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var i = 1; i < arguments.length; i++)
                t[i - 1] = arguments[i];
        l.push(new p(e,t)),
        1 !== l.length || h || r(f)
    }
    ,
    p.prototype.run = function() {
        this.fun.apply(null, this.array)
    }
    ,
    s.title = "browser",
    s.browser = !0,
    s.env = {},
    s.argv = [],
    s.version = "",
    s.versions = {},
    s.on = g,
    s.addListener = g,
    s.once = g,
    s.off = g,
    s.removeListener = g,
    s.removeAllListeners = g,
    s.emit = g,
    s.prependListener = g,
    s.prependOnceListener = g,
    s.listeners = function(e) {
        return []
    }
    ,
    s.binding = function(e) {
        throw new Error("process.binding is not supported")
    }
    ,
    s.cwd = function() {
        return "/"
    }
    ,
    s.chdir = function(e) {
        throw new Error("process.chdir is not supported")
    }
    ,
    s.umask = function() {
        return 0
    }
}
, function(e, t) {
    var i = Math.abs
      , n = (Math.cos,
    Math.sin,
    Math.pow,
    Math.sqrt)
      , s = (i = Math.abs,
    Math.atan2)
      , o = Math.PI;
    e.exports.randInt = function(e, t) {
        return Math.floor(Math.random() * (t - e + 1)) + e
    }
    ,
    e.exports.randFloat = function(e, t) {
        return Math.random() * (t - e + 1) + e
    }
    ,
    e.exports.lerp = function(e, t, i) {
        return e + (t - e) * i
    }
    ,
    e.exports.decel = function(e, t) {
        return e > 0 ? e = Math.max(0, e - t) : e < 0 && (e = Math.min(0, e + t)),
        e
    }
    ,
    e.exports.getDistance = function(e, t, i, s) {
        return n((i -= e) * i + (s -= t) * s)
    }
    ,
    e.exports.getDirection = function(e, t, i, n) {
        return s(t - n, e - i)
    }
    ,
    e.exports.getAngleDist = function(e, t) {
        var n = i(t - e) % (2 * o);
        return n > o ? 2 * o - n : n
    }
    ,
    e.exports.isNumber = function(e) {
        return "number" == typeof e && !isNaN(e) && isFinite(e)
    }
    ,
    e.exports.isString = function(e) {
        return e && "string" == typeof e
    }
    ,
    e.exports.kFormat = function(e) {
        return e > 999 ? (e / 1e3).toFixed(1) + "k" : e
    }
    ,
    e.exports.capitalizeFirst = function(e) {
        return e.charAt(0).toUpperCase() + e.slice(1)
    }
    ,
    e.exports.fixTo = function(e, t) {
        return parseFloat(e.toFixed(t))
    }
    ,
    e.exports.sortByPoints = function(e, t) {
        return parseFloat(t.points) - parseFloat(e.points)
    }
    ,
    e.exports.lineInRect = function(e, t, i, n, s, o, a, r) {
        var c = s
          , l = a;
        if (s > a && (c = a,
        l = s),
        l > i && (l = i),
        c < e && (c = e),
        c > l)
            return !1;
        var h = o
          , u = r
          , d = a - s;
        if (Math.abs(d) > 1e-7) {
            var f = (r - o) / d
              , p = o - f * s;
            h = f * c + p,
            u = f * l + p
        }
        if (h > u) {
            var g = u;
            u = h,
            h = g
        }
        return u > n && (u = n),
        h < t && (h = t),
        !(h > u)
    }
    ,
    e.exports.containsPoint = function(e, t, i) {
        var n = e.getBoundingClientRect()
          , s = n.left + window.scrollX
          , o = n.top + window.scrollY
          , a = n.width
          , r = n.height;
        return t > s && t < s + a && i > o && i < o + r
    }
    ,
    e.exports.mousifyTouchEvent = function(e) {
        var t = e.changedTouches[0];
        e.screenX = t.screenX,
        e.screenY = t.screenY,
        e.clientX = t.clientX,
        e.clientY = t.clientY,
        e.pageX = t.pageX,
        e.pageY = t.pageY
    }
    ,
    e.exports.hookTouchEvents = function(t, i) {
        var n = !i
          , s = !1;
        function o(i) {
            e.exports.mousifyTouchEvent(i),
            window.setUsingTouch(!0),
            n && (i.preventDefault(),
            i.stopPropagation()),
            s && (t.onclick && t.onclick(i),
            t.onmouseout && t.onmouseout(i),
            s = !1)
        }
        t.addEventListener("touchstart", e.exports.checkTrusted((function(i) {
            e.exports.mousifyTouchEvent(i),
            window.setUsingTouch(!0),
            n && (i.preventDefault(),
            i.stopPropagation()),
            t.onmouseover && t.onmouseover(i),
            s = !0
        }
        )), !1),
        t.addEventListener("touchmove", e.exports.checkTrusted((function(i) {
            e.exports.mousifyTouchEvent(i),
            window.setUsingTouch(!0),
            n && (i.preventDefault(),
            i.stopPropagation()),
            e.exports.containsPoint(t, i.pageX, i.pageY) ? s || (t.onmouseover && t.onmouseover(i),
            s = !0) : s && (t.onmouseout && t.onmouseout(i),
            s = !1)
        }
        )), !1),
        t.addEventListener("touchend", e.exports.checkTrusted(o), !1),
        t.addEventListener("touchcancel", e.exports.checkTrusted(o), !1),
        t.addEventListener("touchleave", e.exports.checkTrusted(o), !1)
    }
    ,
    e.exports.removeAllChildren = function(e) {
        for (; e.hasChildNodes(); )
            e.removeChild(e.lastChild)
    }
    ,
    e.exports.generateElement = function(t) {
        var i = document.createElement(t.tag || "div");
        function n(e, n) {
            t[e] && (i[n] = t[e])
        }
        for (var s in n("text", "textContent"),
        n("html", "innerHTML"),
        n("class", "className"),
        t) {
            switch (s) {
            case "tag":
            case "text":
            case "html":
            case "class":
            case "style":
            case "hookTouch":
            case "parent":
            case "children":
                continue
            }
            i[s] = t[s]
        }
        if (i.onclick && (i.onclick = e.exports.checkTrusted(i.onclick)),
        i.onmouseover && (i.onmouseover = e.exports.checkTrusted(i.onmouseover)),
        i.onmouseout && (i.onmouseout = e.exports.checkTrusted(i.onmouseout)),
        t.style && (i.style.cssText = t.style),
        t.hookTouch && e.exports.hookTouchEvents(i),
        t.parent && t.parent.appendChild(i),
        t.children)
            for (var o = 0; o < t.children.length; o++)
                i.appendChild(t.children[o]);
        return i
    }
    ,
    e.exports.eventIsTrusted = function(e) {
        return !e || "boolean" != typeof e.isTrusted || e.isTrusted
    }
    ,
    e.exports.checkTrusted = function(t) {
        return function(i) {
            i && i instanceof Event && e.exports.eventIsTrusted(i) && t(i)
        }
    }
    ,
    e.exports.randomString = function(e) {
        for (var t = "", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = 0; n < e; n++)
            t += i.charAt(Math.floor(Math.random() * i.length));
        return t
    }
    ,
    e.exports.countInArray = function(e, t) {
        for (var i = 0, n = 0; n < e.length; n++)
            e[n] === t && i++;
        return i
    }
}
, function(e, t) {
    e.exports.AnimText = function() {
        this.init = function(e, t, i, n, s, o, a) {
            this.x = e,
            this.y = t,
            this.color = a,
            this.scale = i,
            this.startScale = this.scale,
            this.maxScale = 1.5 * i,
            this.scaleSpeed = .7,
            this.speed = n,
            this.life = s,
            this.text = o
        }
        ,
        this.update = function(e) {
            this.life && (this.life -= e,
            this.y -= this.speed * e,
            this.scale += this.scaleSpeed * e,
            this.scale >= this.maxScale ? (this.scale = this.maxScale,
            this.scaleSpeed *= -1) : this.scale <= this.startScale && (this.scale = this.startScale,
            this.scaleSpeed = 0),
            this.life <= 0 && (this.life = 0))
        }
        ,
        this.render = function(e, t, i) {
            e.fillStyle = this.color,
            e.font = this.scale + "px Hammersmith One",
            e.fillText(this.text, this.x - t, this.y - i)
        }
    }
    ,
    e.exports.TextManager = function() {
        this.texts = [],
        this.update = function(e, t, i, n) {
            t.textBaseline = "middle",
            t.textAlign = "center";
            for (var s = 0; s < this.texts.length; ++s)
                this.texts[s].life && (this.texts[s].update(e),
                this.texts[s].render(t, i, n))
        }
        ,
        this.showText = function(t, i, n, s, o, a, r) {
            for (var c, l = 0; l < this.texts.length; ++l)
                if (!this.texts[l].life) {
                    c = this.texts[l];
                    break
                }
            c || (c = new e.exports.AnimText,
            this.texts.push(c)),
            c.init(t, i, n, s, o, a, r)
        }
    }
}
, function(e, t) {
    e.exports = function(e) {
        this.sid = e,
        this.init = function(e, t, i, n, s, o, a) {
            o = o || {},
            this.sentTo = {},
            this.gridLocations = [],
            this.active = !0,
            this.doUpdate = o.doUpdate,
            this.x = e,
            this.y = t,
            this.dir = i,
            this.xWiggle = 0,
            this.yWiggle = 0,
            this.scale = n,
            this.type = s,
            this.id = o.id,
            this.owner = a,
            this.name = o.name,
            this.isItem = null != this.id,
            this.group = o.group,
            this.health = o.health,
            this.layer = 2,
            null != this.group ? this.layer = this.group.layer : 0 == this.type ? this.layer = 3 : 2 == this.type ? this.layer = 0 : 4 == this.type && (this.layer = -1),
            this.colDiv = o.colDiv || 1,
            this.blocker = o.blocker,
            this.ignoreCollision = o.ignoreCollision,
            this.dontGather = o.dontGather,
            this.hideFromEnemy = o.hideFromEnemy,
            this.friction = o.friction,
            this.projDmg = o.projDmg,
            this.dmg = o.dmg,
            this.pDmg = o.pDmg,
            this.pps = o.pps,
            this.zIndex = o.zIndex || 0,
            this.turnSpeed = o.turnSpeed,
            this.req = o.req,
            this.trap = o.trap,
            this.healCol = o.healCol,
            this.teleport = o.teleport,
            this.boostSpeed = o.boostSpeed,
            this.projectile = o.projectile,
            this.shootRange = o.shootRange,
            this.shootRate = o.shootRate,
            this.shootCount = this.shootRate,
            this.spawnPoint = o.spawnPoint
        }
        ,
        this.changeHealth = function(e, t) {
            return this.health += e,
            this.health <= 0
        }
        ,
        this.getScale = function(e, t) {
            return e = e || 1,
            this.scale * (this.isItem || 2 == this.type || 3 == this.type || 4 == this.type ? 1 : .6 * e) * (t ? 1 : this.colDiv)
        }
        ,
        this.visibleToPlayer = function(e) {
            return !this.hideFromEnemy || this.owner && (this.owner == e || this.owner.team && e.team == this.owner.team)
        }
        ,
        this.update = function(e) {
            this.active && (this.xWiggle && (this.xWiggle *= Math.pow(.99, e)),
            this.yWiggle && (this.yWiggle *= Math.pow(.99, e)),
            this.turnSpeed && (this.dir += this.turnSpeed * e))
        }
    }
}
, function(e, t) {
    e.exports.groups = [{
        id: 0,
        name: "food",
        layer: 0
    }, {
        id: 1,
        name: "walls",
        place: !0,
        limit: 30,
        layer: 0
    }, {
        id: 2,
        name: "spikes",
        place: !0,
        limit: 15,
        layer: 0
    }, {
        id: 3,
        name: "mill",
        place: !0,
        limit: 7,
        layer: 1
    }, {
        id: 4,
        name: "mine",
        place: !0,
        limit: 1,
        layer: 0
    }, {
        id: 5,
        name: "trap",
        place: !0,
        limit: 6,
        layer: -1
    }, {
        id: 6,
        name: "booster",
        place: !0,
        limit: 12,
        layer: -1
    }, {
        id: 7,
        name: "turret",
        place: !0,
        limit: 2,
        layer: 1
    }, {
        id: 8,
        name: "watchtower",
        place: !0,
        limit: 12,
        layer: 1
    }, {
        id: 9,
        name: "buff",
        place: !0,
        limit: 4,
        layer: -1
    }, {
        id: 10,
        name: "spawn",
        place: !0,
        limit: 1,
        layer: -1
    }, {
        id: 11,
        name: "sapling",
        place: !0,
        limit: 2,
        layer: 0
    }, {
        id: 12,
        name: "blocker",
        place: !0,
        limit: 3,
        layer: -1
    }, {
        id: 13,
        name: "teleporter",
        place: !0,
        limit: 2,
        layer: -1
    }],
    t.projectiles = [{
        indx: 0,
        layer: 0,
        src: "arrow_1",
        dmg: 25,
        speed: 1.6,
        scale: 103,
        range: 1e3
    }, {
        indx: 1,
        layer: 1,
        dmg: 25,
        scale: 20
    }, {
        indx: 0,
        layer: 0,
        src: "arrow_1",
        dmg: 35,
        speed: 2.5,
        scale: 103,
        range: 1200
    }, {
        indx: 0,
        layer: 0,
        src: "arrow_1",
        dmg: 30,
        speed: 2,
        scale: 103,
        range: 1200
    }, {
        indx: 1,
        layer: 1,
        dmg: 16,
        scale: 20
    }, {
        indx: 0,
        layer: 0,
        src: "bullet_1",
        dmg: 50,
        speed: 3.6,
        scale: 160,
        range: 1400
    }],
    t.weapons = [{
        id: 0,
        type: 0,
        name: "tool hammer",
        desc: "tool for gathering all resources",
        src: "hammer_1",
        length: 140,
        width: 140,
        xOff: -3,
        yOff: 18,
        dmg: 25,
        range: 65,
        gather: 1,
        speed: 300
    }, {
        id: 1,
        type: 0,
        age: 2,
        name: "hand axe",
        desc: "gathers resources at a higher rate",
        src: "axe_1",
        length: 140,
        width: 140,
        xOff: 3,
        yOff: 24,
        dmg: 30,
        spdMult: 1,
        range: 70,
        gather: 2,
        speed: 400
    }, {
        id: 2,
        type: 0,
        age: 8,
        pre: 1,
        name: "great axe",
        desc: "deal more damage and gather more resources",
        src: "great_axe_1",
        length: 140,
        width: 140,
        xOff: -8,
        yOff: 25,
        dmg: 35,
        spdMult: 1,
        range: 75,
        gather: 4,
        speed: 400
    }, {
        id: 3,
        type: 0,
        age: 2,
        name: "short sword",
        desc: "increased attack power but slower move speed",
        src: "sword_1",
        iPad: 1.3,
        length: 130,
        width: 210,
        xOff: -8,
        yOff: 46,
        dmg: 35,
        spdMult: .85,
        range: 110,
        gather: 1,
        speed: 300
    }, {
        id: 4,
        type: 0,
        age: 8,
        pre: 3,
        name: "katana",
        desc: "greater range and damage",
        src: "samurai_1",
        iPad: 1.3,
        length: 130,
        width: 210,
        xOff: -8,
        yOff: 59,
        dmg: 40,
        spdMult: .8,
        range: 118,
        gather: 1,
        speed: 300
    }, {
        id: 5,
        type: 0,
        age: 2,
        name: "polearm",
        desc: "long range melee weapon",
        src: "spear_1",
        iPad: 1.3,
        length: 130,
        width: 210,
        xOff: -8,
        yOff: 53,
        dmg: 45,
        knock: .2,
        spdMult: .82,
        range: 142,
        gather: 1,
        speed: 700
    }, {
        id: 6,
        type: 0,
        age: 2,
        name: "bat",
        desc: "fast long range melee weapon",
        src: "bat_1",
        iPad: 1.3,
        length: 110,
        width: 180,
        xOff: -8,
        yOff: 53,
        dmg: 20,
        knock: .7,
        range: 110,
        gather: 1,
        speed: 300
    }, {
        id: 7,
        type: 0,
        age: 2,
        name: "daggers",
        desc: "really fast short range weapon",
        src: "dagger_1",
        iPad: .8,
        length: 110,
        width: 110,
        xOff: 18,
        yOff: 0,
        dmg: 20,
        knock: .1,
        range: 65,
        gather: 1,
        hitSlow: .1,
        spdMult: 1.13,
        speed: 100
    }, {
        id: 8,
        type: 0,
        age: 2,
        name: "stick",
        desc: "great for gathering but very weak",
        src: "stick_1",
        length: 140,
        width: 140,
        xOff: 3,
        yOff: 24,
        dmg: 1,
        spdMult: 1,
        range: 70,
        gather: 7,
        speed: 400
    }, {
        id: 9,
        type: 1,
        age: 6,
        name: "hunting bow",
        desc: "bow used for ranged combat and hunting",
        src: "bow_1",
        req: ["wood", 4],
        length: 120,
        width: 120,
        xOff: -6,
        yOff: 0,
        projectile: 0,
        spdMult: .75,
        speed: 600
    }, {
        id: 10,
        type: 1,
        age: 6,
        name: "great hammer",
        desc: "hammer used for destroying structures",
        src: "great_hammer_1",
        length: 140,
        width: 140,
        xOff: -9,
        yOff: 25,
        dmg: 10,
        spdMult: .88,
        range: 75,
        sDmg: 7.5,
        gather: 1,
        speed: 400
    }, {
        id: 11,
        type: 1,
        age: 6,
        name: "wooden shield",
        desc: "blocks projectiles and reduces melee damage",
        src: "shield_1",
        length: 120,
        width: 120,
        shield: .2,
        xOff: 6,
        yOff: 0,
        spdMult: .7
    }, {
        id: 12,
        type: 1,
        age: 8,
        pre: 9,
        name: "crossbow",
        desc: "deals more damage and has greater range",
        src: "crossbow_1",
        req: ["wood", 5],
        aboveHand: !0,
        armS: .75,
        length: 120,
        width: 120,
        xOff: -4,
        yOff: 0,
        projectile: 2,
        spdMult: .7,
        speed: 700
    }, {
        id: 13,
        type: 1,
        age: 9,
        pre: 12,
        name: "repeater crossbow",
        desc: "high firerate crossbow with reduced damage",
        src: "crossbow_2",
        req: ["wood", 10],
        aboveHand: !0,
        armS: .75,
        length: 120,
        width: 120,
        xOff: -4,
        yOff: 0,
        projectile: 3,
        spdMult: .7,
        speed: 230
    }, {
        id: 14,
        type: 1,
        age: 6,
        name: "mc grabby",
        desc: "steals resources from enemies",
        src: "grab_1",
        length: 130,
        width: 210,
        xOff: -8,
        yOff: 53,
        dmg: 0,
        steal: 250,
        knock: .2,
        spdMult: 1.05,
        range: 125,
        gather: 0,
        speed: 700
    }, {
        id: 15,
        type: 1,
        age: 9,
        pre: 12,
        name: "musket",
        desc: "slow firerate but high damage and range",
        src: "musket_1",
        req: ["stone", 10],
        aboveHand: !0,
        rec: .35,
        armS: .6,
        hndS: .3,
        hndD: 1.6,
        length: 205,
        width: 205,
        xOff: 25,
        yOff: 0,
        projectile: 5,
        hideProjectile: !0,
        spdMult: .6,
        speed: 1500
    }],
    e.exports.list = [{
        group: e.exports.groups[0],
        name: "apple",
        desc: "restores 20 health when consumed",
        req: ["food", 10],
        consume: function(e) {
            return e.changeHealth(20, e)
        },
        scale: 22,
        holdOffset: 15
    }, {
        age: 3,
        group: e.exports.groups[0],
        name: "cookie",
        desc: "restores 40 health when consumed",
        req: ["food", 15],
        consume: function(e) {
            return e.changeHealth(40, e)
        },
        scale: 27,
        holdOffset: 15
    }, {
        age: 7,
        group: e.exports.groups[0],
        name: "cheese",
        desc: "restores 30 health and another 50 over 5 seconds",
        req: ["food", 25],
        consume: function(e) {
            return !!(e.changeHealth(30, e) || e.health < 100) && (e.dmgOverTime.dmg = -10,
            e.dmgOverTime.doer = e,
            e.dmgOverTime.time = 5,
            !0)
        },
        scale: 27,
        holdOffset: 15
    }, {
        group: e.exports.groups[1],
        name: "wood wall",
        desc: "provides protection for your village",
        req: ["wood", 10],
        projDmg: !0,
        health: 380,
        scale: 50,
        holdOffset: 20,
        placeOffset: -5
    }, {
        age: 3,
        group: e.exports.groups[1],
        name: "stone wall",
        desc: "provides improved protection for your village",
        req: ["stone", 25],
        health: 900,
        scale: 50,
        holdOffset: 20,
        placeOffset: -5
    }, {
        age: 7,
        pre: 1,
        group: e.exports.groups[1],
        name: "castle wall",
        desc: "provides powerful protection for your village",
        req: ["stone", 35],
        health: 1500,
        scale: 52,
        holdOffset: 20,
        placeOffset: -5
    }, {
        group: e.exports.groups[2],
        name: "spikes",
        desc: "damages enemies when they touch them",
        req: ["wood", 20, "stone", 5],
        health: 400,
        dmg: 20,
        scale: 49,
        spritePadding: -23,
        holdOffset: 8,
        placeOffset: -5
    }, {
        age: 5,
        group: e.exports.groups[2],
        name: "greater spikes",
        desc: "damages enemies when they touch them",
        req: ["wood", 30, "stone", 10],
        health: 500,
        dmg: 35,
        scale: 52,
        spritePadding: -23,
        holdOffset: 8,
        placeOffset: -5
    }, {
        age: 9,
        pre: 1,
        group: e.exports.groups[2],
        name: "poison spikes",
        desc: "poisons enemies when they touch them",
        req: ["wood", 35, "stone", 15],
        health: 600,
        dmg: 30,
        pDmg: 5,
        scale: 52,
        spritePadding: -23,
        holdOffset: 8,
        placeOffset: -5
    }, {
        age: 9,
        pre: 2,
        group: e.exports.groups[2],
        name: "spinning spikes",
        desc: "damages enemies when they touch them",
        req: ["wood", 30, "stone", 20],
        health: 500,
        dmg: 45,
        turnSpeed: .003,
        scale: 52,
        spritePadding: -23,
        holdOffset: 8,
        placeOffset: -5
    }, {
        group: e.exports.groups[3],
        name: "windmill",
        desc: "generates gold over time",
        req: ["wood", 50, "stone", 10],
        health: 400,
        pps: 1,
        turnSpeed: .0016,
        spritePadding: 25,
        iconLineMult: 12,
        scale: 45,
        holdOffset: 20,
        placeOffset: 5
    }, {
        age: 5,
        pre: 1,
        group: e.exports.groups[3],
        name: "faster windmill",
        desc: "generates more gold over time",
        req: ["wood", 60, "stone", 20],
        health: 500,
        pps: 1.5,
        turnSpeed: .0025,
        spritePadding: 25,
        iconLineMult: 12,
        scale: 47,
        holdOffset: 20,
        placeOffset: 5
    }, {
        age: 8,
        pre: 1,
        group: e.exports.groups[3],
        name: "power mill",
        desc: "generates more gold over time",
        req: ["wood", 100, "stone", 50],
        health: 800,
        pps: 2,
        turnSpeed: .005,
        spritePadding: 25,
        iconLineMult: 12,
        scale: 47,
        holdOffset: 20,
        placeOffset: 5
    }, {
        age: 5,
        group: e.exports.groups[4],
        type: 2,
        name: "mine",
        desc: "allows you to mine stone",
        req: ["wood", 20, "stone", 100],
        iconLineMult: 12,
        scale: 65,
        holdOffset: 20,
        placeOffset: 0
    }, {
        age: 5,
        group: e.exports.groups[11],
        type: 0,
        name: "sapling",
        desc: "allows you to farm wood",
        req: ["wood", 150],
        iconLineMult: 12,
        colDiv: .5,
        scale: 110,
        holdOffset: 50,
        placeOffset: -15
    }, {
        age: 4,
        group: e.exports.groups[5],
        name: "pit trap",
        desc: "pit that traps enemies if they walk over it",
        req: ["wood", 30, "stone", 30],
        trap: !0,
        ignoreCollision: !0,
        hideFromEnemy: !0,
        health: 500,
        colDiv: .2,
        scale: 50,
        holdOffset: 20,
        placeOffset: -5
    }, {
        age: 4,
        group: e.exports.groups[6],
        name: "boost pad",
        desc: "provides boost when stepped on",
        req: ["stone", 20, "wood", 5],
        ignoreCollision: !0,
        boostSpeed: 1.5,
        health: 150,
        colDiv: .7,
        scale: 45,
        holdOffset: 20,
        placeOffset: -5
    }, {
        age: 7,
        group: e.exports.groups[7],
        doUpdate: !0,
        name: "turret",
        desc: "defensive structure that shoots at enemies",
        req: ["wood", 200, "stone", 150],
        health: 800,
        projectile: 1,
        shootRange: 700,
        shootRate: 2200,
        scale: 43,
        holdOffset: 20,
        placeOffset: -5
    }, {
        age: 7,
        group: e.exports.groups[8],
        name: "platform",
        desc: "platform to shoot over walls and cross over water",
        req: ["wood", 20],
        ignoreCollision: !0,
        zIndex: 1,
        health: 300,
        scale: 43,
        holdOffset: 20,
        placeOffset: -5
    }, {
        age: 7,
        group: e.exports.groups[9],
        name: "healing pad",
        desc: "standing on it will slowly heal you",
        req: ["wood", 30, "food", 10],
        ignoreCollision: !0,
        healCol: 15,
        health: 400,
        colDiv: .7,
        scale: 45,
        holdOffset: 20,
        placeOffset: -5
    }, {
        age: 9,
        group: e.exports.groups[10],
        name: "spawn pad",
        desc: "you will spawn here when you die but it will dissapear",
        req: ["wood", 100, "stone", 100],
        health: 400,
        ignoreCollision: !0,
        spawnPoint: !0,
        scale: 45,
        holdOffset: 20,
        placeOffset: -5
    }, {
        age: 7,
        group: e.exports.groups[12],
        name: "blocker",
        desc: "blocks building in radius",
        req: ["wood", 30, "stone", 25],
        ignoreCollision: !0,
        blocker: 300,
        health: 400,
        colDiv: .7,
        scale: 45,
        holdOffset: 20,
        placeOffset: -5
    }, {
        age: 7,
        group: e.exports.groups[13],
        name: "teleporter",
        desc: "teleports you to a random point on the map",
        req: ["wood", 60, "stone", 60],
        ignoreCollision: !0,
        teleport: !0,
        health: 200,
        colDiv: .7,
        scale: 45,
        holdOffset: 20,
        placeOffset: -5
    }];
    for (var i = 0; i < e.exports.list.length; ++i)
        e.exports.list[i].id = i,
        e.exports.list[i].pre && (e.exports.list[i].pre = i - e.exports.list[i].pre)
}
, function(e, t) {
    e.exports = {}
}
, function(e, t) {
    var i = Math.floor
      , n = Math.abs
      , s = Math.cos
      , o = Math.sin
      , a = (Math.pow,
    Math.sqrt);
    e.exports = function(e, t, r, c, l, h) {
        var u, d;
        this.objects = t,
        this.grids = {},
        this.updateObjects = [];
        var f = c.mapScale / c.colGrid;
        this.setObjectGrids = function(e) {
            for (var t = Math.min(c.mapScale, Math.max(0, e.x)), i = Math.min(c.mapScale, Math.max(0, e.y)), n = 0; n < c.colGrid; ++n) {
                u = n * f;
                for (var s = 0; s < c.colGrid; ++s)
                    d = s * f,
                    t + e.scale >= u && t - e.scale <= u + f && i + e.scale >= d && i - e.scale <= d + f && (this.grids[n + "_" + s] || (this.grids[n + "_" + s] = []),
                    this.grids[n + "_" + s].push(e),
                    e.gridLocations.push(n + "_" + s))
            }
        }
        ,
        this.removeObjGrid = function(e) {
            for (var t, i = 0; i < e.gridLocations.length; ++i)
                (t = this.grids[e.gridLocations[i]].indexOf(e)) >= 0 && this.grids[e.gridLocations[i]].splice(t, 1)
        }
        ,
        this.disableObj = function(e) {
            if (e.active = !1,
            h) {
                e.owner && e.pps && (e.owner.pps -= e.pps),
                this.removeObjGrid(e);
                var t = this.updateObjects.indexOf(e);
                t >= 0 && this.updateObjects.splice(t, 1)
            }
        }
        ,
        this.hitObj = function(e, t) {
            for (var i = 0; i < l.length; ++i)
                l[i].active && (e.sentTo[l[i].id] && (e.active ? l[i].canSee(e) && h.send(l[i].id, "8", r.fixTo(t, 1), e.sid) : h.send(l[i].id, "12", e.sid)),
                e.active || e.owner != l[i] || l[i].changeItemCount(e.group.id, -1))
        }
        ;
        var p, g, m = [];
        this.getGridArrays = function(e, t, n) {
            u = i(e / f),
            d = i(t / f),
            m.length = 0;
            try {
                this.grids[u + "_" + d] && m.push(this.grids[u + "_" + d]),
                e + n >= (u + 1) * f && ((p = this.grids[u + 1 + "_" + d]) && m.push(p),
                d && t - n <= d * f ? (p = this.grids[u + 1 + "_" + (d - 1)]) && m.push(p) : t + n >= (d + 1) * f && (p = this.grids[u + 1 + "_" + (d + 1)]) && m.push(p)),
                u && e - n <= u * f && ((p = this.grids[u - 1 + "_" + d]) && m.push(p),
                d && t - n <= d * f ? (p = this.grids[u - 1 + "_" + (d - 1)]) && m.push(p) : t + n >= (d + 1) * f && (p = this.grids[u - 1 + "_" + (d + 1)]) && m.push(p)),
                t + n >= (d + 1) * f && (p = this.grids[u + "_" + (d + 1)]) && m.push(p),
                d && t - n <= d * f && (p = this.grids[u + "_" + (d - 1)]) && m.push(p)
            } catch (e) {}
            return m
        }
        ,
        this.add = function(i, n, s, o, a, r, c, l, u) {
            g = null;
            for (var d = 0; d < t.length; ++d)
                if (t[d].sid == i) {
                    g = t[d];
                    break
                }
            if (!g)
                for (d = 0; d < t.length; ++d)
                    if (!t[d].active) {
                        g = t[d];
                        break
                    }
            g || (g = new e(i),
            t.push(g)),
            l && (g.sid = i),
            g.init(n, s, o, a, r, c, u),
            h && (this.setObjectGrids(g),
            g.doUpdate && this.updateObjects.push(g))
        }
        ,
        this.disableBySid = function(e) {
            for (var i = 0; i < t.length; ++i)
                if (t[i].sid == e) {
                    this.disableObj(t[i]);
                    break
                }
        }
        ,
        this.removeAllItems = function(e, i) {
            for (var n = 0; n < t.length; ++n)
                t[n].active && t[n].owner && t[n].owner.sid == e && this.disableObj(t[n]);
            i && i.broadcast("13", e)
        }
        ,
        this.fetchSpawnObj = function(e) {
            for (var i = null, n = 0; n < t.length; ++n)
                if ((g = t[n]).active && g.owner && g.owner.sid == e && g.spawnPoint) {
                    i = [g.x, g.y],
                    this.disableObj(g),
                    h.broadcast("12", g.sid),
                    g.owner && g.owner.changeItemCount(g.group.id, -1);
                    break
                }
            return i
        }
        ,
        this.checkItemLocation = function(e, i, n, s, o, a, l) {
            for (var h = 0; h < t.length; ++h) {
                var u = t[h].blocker ? t[h].blocker : t[h].getScale(s, t[h].isItem);
                if (t[h].active && r.getDistance(e, i, t[h].x, t[h].y) < n + u)
                    return !1
            }
            return !(!a && 18 != o && i >= c.mapScale / 2 - c.riverWidth / 2 && i <= c.mapScale / 2 + c.riverWidth / 2)
        }
        ,
        this.addProjectile = function(e, t, i, n, s) {
            for (var o, a = items.projectiles[s], c = 0; c < projectiles.length; ++c)
                if (!projectiles[c].active) {
                    o = projectiles[c];
                    break
                }
            o || (o = new Projectile(l,r),
            projectiles.push(o)),
            o.init(s, e, t, i, a.speed, n, a.scale)
        }
        ,
        this.checkCollision = function(e, t, i) {
            i = i || 1;
            var l = e.x - t.x
              , h = e.y - t.y
              , u = e.scale + t.scale;
            if (n(l) <= u || n(h) <= u) {
                u = e.scale + (t.getScale ? t.getScale() : t.scale);
                var d = a(l * l + h * h) - u;
                if (d <= 0) {
                    if (t.ignoreCollision)
                        !t.trap || e.noTrap || t.owner == e || t.owner && t.owner.team && t.owner.team == e.team ? t.boostSpeed ? (e.xVel += i * t.boostSpeed * (t.weightM || 1) * s(t.dir),
                        e.yVel += i * t.boostSpeed * (t.weightM || 1) * o(t.dir)) : t.healCol ? e.healCol = t.healCol : t.teleport && (e.x = r.randInt(0, c.mapScale),
                        e.y = r.randInt(0, c.mapScale)) : (e.lockMove = !0,
                        t.hideFromEnemy = !1);
                    else {
                        var f = r.getDirection(e.x, e.y, t.x, t.y);
                        if (r.getDistance(e.x, e.y, t.x, t.y),
                        t.isPlayer ? (d = -1 * d / 2,
                        e.x += d * s(f),
                        e.y += d * o(f),
                        t.x -= d * s(f),
                        t.y -= d * o(f)) : (e.x = t.x + u * s(f),
                        e.y = t.y + u * o(f),
                        e.xVel *= .75,
                        e.yVel *= .75),
                        t.dmg && t.owner != e && (!t.owner || !t.owner.team || t.owner.team != e.team)) {
                            e.changeHealth(-t.dmg, t.owner, t);
                            var p = 1.5 * (t.weightM || 1);
                            e.xVel += p * s(f),
                            e.yVel += p * o(f),
                            !t.pDmg || e.skin && e.skin.poisonRes || (e.dmgOverTime.dmg = t.pDmg,
                            e.dmgOverTime.time = 5,
                            e.dmgOverTime.doer = t.owner),
                            e.colDmg && t.health && (t.changeHealth(-e.colDmg) && this.disableObj(t),
                            this.hitObj(t, r.getDirection(e.x, e.y, t.x, t.y)))
                        }
                    }
                    return t.zIndex > e.zIndex && (e.zIndex = t.zIndex),
                    !0
                }
            }
            return !1
        }
    }
}
, function(e, t, i) {
    var n = new (i(13));
    n.addWords("jew", "black", "baby", "child", "white", "porn", "pedo", "trump", "clinton", "hitler", "nazi", "gay", "pride", "sex", "pleasure", "touch", "poo", "kids", "rape", "white power", "nigga", "nig nog", "doggy", "rapist", "boner", "nigger", "nigg", "finger", "nogger", "nagger", "nig", "fag", "gai", "pole", "stripper", "penis", "vagina", "pussy", "nazi", "hitler", "stalin", "burn", "chamber", "cock", "peen", "dick", "spick", "nieger", "die", "satan", "n|ig", "nlg", "cunt", "c0ck", "fag", "lick", "condom", "anal", "shit", "phile", "little", "kids", "free KR", "tiny", "sidney", "ass", "kill", ".io", "(dot)", "[dot]", "mini", "whiore", "whore", "faggot", "github", "1337", "666", "satan", "senpa", "discord", "d1scord", "mistik", ".io", "senpa.io", "sidney", "sid", "senpaio", "vries", "asa");
    var s = Math.abs
      , o = Math.cos
      , a = Math.sin
      , r = Math.pow
      , c = Math.sqrt;
    e.exports = function(e, t, i, l, h, u, d, f, p, g, m, y, k, w) {
        this.id = e,
        this.sid = t,
        this.tmpScore = 0,
        this.team = null,
        this.skinIndex = 0,
        this.tailIndex = 0,
        this.hitTime = 0,
        this.tails = {};
        for (var v = 0; v < m.length; ++v)
            m[v].price <= 0 && (this.tails[m[v].id] = 1);
        for (this.skins = {},
        v = 0; v < g.length; ++v)
            g[v].price <= 0 && (this.skins[g[v].id] = 1);
        this.points = 0,
        this.dt = 0,
        this.hidden = !1,
        this.itemCounts = {},
        this.isPlayer = !0,
        this.pps = 0,
        this.moveDir = void 0,
        this.skinRot = 0,
        this.lastPing = 0,
        this.iconIndex = 0,
        this.skinColor = 0,
        this.spawn = function(e) {
            this.active = !0,
            this.alive = !0,
            this.lockMove = !1,
            this.lockDir = !1,
            this.minimapCounter = 0,
            this.chatCountdown = 0,
            this.shameCount = 0,
            this.shameTimer = 0,
            this.sentTo = {},
            this.gathering = 0,
            this.autoGather = 0,
            this.animTime = 0,
            this.animSpeed = 0,
            this.mouseState = 0,
            this.buildIndex = -1,
            this.weaponIndex = 0,
            this.dmgOverTime = {},
            this.noMovTimer = 0,
            this.maxXP = 300,
            this.XP = 0,
            this.age = 1,
            this.kills = 0,
            this.upgrAge = 2,
            this.upgradePoints = 0,
            this.x = 0,
            this.y = 0,
            this.zIndex = 0,
            this.xVel = 0,
            this.yVel = 0,
            this.slowMult = 1,
            this.dir = 0,
            this.dirPlus = 0,
            this.targetDir = 0,
            this.targetAngle = 0,
            this.maxHealth = 100,
            this.health = this.maxHealth,
            this.scale = i.playerScale,
            this.speed = i.playerSpeed,
            this.resetMoveDir(),
            this.resetResources(e),
            this.items = [0, 3, 6, 10],
            this.weapons = [0],
            this.shootCount = 0,
            this.weaponXP = [],
            this.reloads = {}
        }
        ,
        this.resetMoveDir = function() {
            this.moveDir = void 0
        }
        ,
        this.resetResources = function(e) {
            for (var t = 0; t < i.resourceTypes.length; ++t)
                this[i.resourceTypes[t]] = e ? 100 : 0
        }
        ,
        this.addItem = function(e) {
            var t = p.list[e];
            if (t) {
                for (var i = 0; i < this.items.length; ++i)
                    if (p.list[this.items[i]].group == t.group)
                        return this.buildIndex == this.items[i] && (this.buildIndex = e),
                        this.items[i] = e,
                        !0;
                return this.items.push(e),
                !0
            }
            return !1
        }
        ,
        this.setUserData = function(e) {
            if (e) {
                this.name = "unknown";
                var t = e.name + ""
                  , s = !1
                  , o = (t = (t = (t = (t = t.slice(0, i.maxNameLength)).replace(/[^\w:\(\)\/? -]+/gim, " ")).replace(/[^\x00-\x7F]/g, " ")).trim()).toLowerCase().replace(/\s/g, "").replace(/1/g, "i").replace(/0/g, "o").replace(/5/g, "s");
                for (var a of n.list)
                    if (-1 != o.indexOf(a)) {
                        s = !0;
                        break
                    }
                t.length > 0 && !s && (this.name = t),
                this.skinColor = 0,
                i.skinColors[e.skin] && (this.skinColor = e.skin)
            }
        }
        ,
        this.getData = function() {
            return [this.id, this.sid, this.name, l.fixTo(this.x, 2), l.fixTo(this.y, 2), l.fixTo(this.dir, 3), this.health, this.maxHealth, this.scale, this.skinColor]
        }
        ,
        this.setData = function(e) {
            this.id = e[0],
            this.sid = e[1],
            this.name = e[2],
            this.x = e[3],
            this.y = e[4],
            this.dir = e[5],
            this.health = e[6],
            this.maxHealth = e[7],
            this.scale = e[8],
            this.skinColor = e[9]
        }
        ;
        var b = 0;
        this.update = function(e) {
            if (this.alive) {
                if (this.shameTimer > 0 && (this.shameTimer -= e,
                this.shameTimer <= 0 && (this.shameTimer = 0,
                this.shameCount = 0)),
                (b -= e) <= 0) {
                    var t = (this.skin && this.skin.healthRegen ? this.skin.healthRegen : 0) + (this.tail && this.tail.healthRegen ? this.tail.healthRegen : 0);
                    t && this.changeHealth(t, this),
                    this.dmgOverTime.dmg && (this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer),
                    this.dmgOverTime.time -= 1,
                    this.dmgOverTime.time <= 0 && (this.dmgOverTime.dmg = 0)),
                    this.healCol && this.changeHealth(this.healCol, this),
                    b = 1e3
                }
                if (this.alive) {
                    if (this.slowMult < 1 && (this.slowMult += 8e-4 * e,
                    this.slowMult > 1 && (this.slowMult = 1)),
                    this.noMovTimer += e,
                    (this.xVel || this.yVel) && (this.noMovTimer = 0),
                    this.lockMove)
                        this.xVel = 0,
                        this.yVel = 0;
                    else {
                        var n = (this.buildIndex >= 0 ? .5 : 1) * (p.weapons[this.weaponIndex].spdMult || 1) * (this.skin && this.skin.spdMult || 1) * (this.tail && this.tail.spdMult || 1) * (this.y <= i.snowBiomeTop ? this.skin && this.skin.coldM ? 1 : i.snowSpeed : 1) * this.slowMult;
                        !this.zIndex && this.y >= i.mapScale / 2 - i.riverWidth / 2 && this.y <= i.mapScale / 2 + i.riverWidth / 2 && (this.skin && this.skin.watrImm ? (n *= .75,
                        this.xVel += .4 * i.waterCurrent * e) : (n *= .33,
                        this.xVel += i.waterCurrent * e));
                        var s = null != this.moveDir ? o(this.moveDir) : 0
                          , f = null != this.moveDir ? a(this.moveDir) : 0
                          , g = c(s * s + f * f);
                        0 != g && (s /= g,
                        f /= g),
                        s && (this.xVel += s * this.speed * n * e),
                        f && (this.yVel += f * this.speed * n * e)
                    }
                    var m;
                    this.zIndex = 0,
                    this.lockMove = !1,
                    this.healCol = 0;
                    for (var y = l.getDistance(0, 0, this.xVel * e, this.yVel * e), k = Math.min(4, Math.max(1, Math.round(y / 40))), w = 1 / k, v = {}, x = 0; x < k; ++x) {
                        this.xVel && (this.x += this.xVel * e * w),
                        this.yVel && (this.y += this.yVel * e * w),
                        m = u.getGridArrays(this.x, this.y, this.scale);
                        for (var S = 0; S < m.length; ++S) {
                            for (var I = 0; I < m[S].length && (!m[S][I].active || v[m[S][I].sid] || !u.checkCollision(this, m[S][I], w) || (v[m[S][I].sid] = !0,
                            this.alive)); ++I)
                                ;
                            if (!this.alive)
                                break
                        }
                        if (!this.alive)
                            break
                    }
                    for (x = (M = d.indexOf(this)) + 1; x < d.length; ++x)
                        d[x] != this && d[x].alive && u.checkCollision(this, d[x]);
                    if (this.xVel && (this.xVel *= r(i.playerDecel, e),
                    this.xVel <= .01 && this.xVel >= -.01 && (this.xVel = 0)),
                    this.yVel && (this.yVel *= r(i.playerDecel, e),
                    this.yVel <= .01 && this.yVel >= -.01 && (this.yVel = 0)),
                    this.x - this.scale < 0 ? this.x = this.scale : this.x + this.scale > i.mapScale && (this.x = i.mapScale - this.scale),
                    this.y - this.scale < 0 ? this.y = this.scale : this.y + this.scale > i.mapScale && (this.y = i.mapScale - this.scale),
                    this.buildIndex < 0)
                        if (this.reloads[this.weaponIndex] > 0)
                            this.reloads[this.weaponIndex] -= e,
                            this.gathering = this.mouseState;
                        else if (this.gathering || this.autoGather) {
                            var T = !0;
                            if (null != p.weapons[this.weaponIndex].gather)
                                this.gather(d);
                            else if (null != p.weapons[this.weaponIndex].projectile && this.hasRes(p.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0)) {
                                this.useRes(p.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0),
                                this.noMovTimer = 0;
                                var M = p.weapons[this.weaponIndex].projectile
                                  , C = 2 * this.scale
                                  , P = this.skin && this.skin.aMlt ? this.skin.aMlt : 1;
                                p.weapons[this.weaponIndex].rec && (this.xVel -= p.weapons[this.weaponIndex].rec * o(this.dir),
                                this.yVel -= p.weapons[this.weaponIndex].rec * a(this.dir)),
                                h.addProjectile(this.x + C * o(this.dir), this.y + C * a(this.dir), this.dir, p.projectiles[M].range * P, p.projectiles[M].speed * P, M, this, null, this.zIndex)
                            } else
                                T = !1;
                            this.gathering = this.mouseState,
                            T && (this.reloads[this.weaponIndex] = p.weapons[this.weaponIndex].speed * (this.skin && this.skin.atkSpd || 1))
                        }
                }
            }
        }
        ,
        this.addWeaponXP = function(e) {
            this.weaponXP[this.weaponIndex] || (this.weaponXP[this.weaponIndex] = 0),
            this.weaponXP[this.weaponIndex] += e
        }
        ,
        this.earnXP = function(e) {
            this.age < i.maxAge && (this.XP += e,
            this.XP >= this.maxXP ? (this.age < i.maxAge ? (this.age++,
            this.XP = 0,
            this.maxXP *= 1.2) : this.XP = this.maxXP,
            this.upgradePoints++,
            y.send(this.id, "16", this.upgradePoints, this.upgrAge),
            y.send(this.id, "15", this.XP, l.fixTo(this.maxXP, 1), this.age)) : y.send(this.id, "15", this.XP))
        }
        ,
        this.changeHealth = function(e, t) {
            if (e > 0 && this.health >= this.maxHealth)
                return !1;
            e < 0 && this.skin && (e *= this.skin.dmgMult || 1),
            e < 0 && this.tail && (e *= this.tail.dmgMult || 1),
            e < 0 && (this.hitTime = Date.now()),
            this.health += e,
            this.health > this.maxHealth && (e -= this.health - this.maxHealth,
            this.health = this.maxHealth),
            this.health <= 0 && this.kill(t);
            for (var i = 0; i < d.length; ++i)
                this.sentTo[d[i].id] && y.send(d[i].id, "h", this.sid, this.health);
            return !t || !t.canSee(this) || t == this && e < 0 || y.send(t.id, "t", Math.round(this.x), Math.round(this.y), Math.round(-e), 1),
            !0
        }
        ,
        this.kill = function(e) {
            e && e.alive && (e.kills++,
            e.skin && e.skin.goldSteal ? k(e, Math.round(this.points / 2)) : k(e, Math.round(100 * this.age * (e.skin && e.skin.kScrM ? e.skin.kScrM : 1))),
            y.send(e.id, "9", "kills", e.kills, 1)),
            this.alive = !1,
            y.send(this.id, "11"),
            w()
        }
        ,
        this.addResource = function(e, t, n) {
            !n && t > 0 && this.addWeaponXP(t),
            3 == e ? k(this, t, !0) : (this[i.resourceTypes[e]] += t,
            y.send(this.id, "9", i.resourceTypes[e], this[i.resourceTypes[e]], 1))
        }
        ,
        this.changeItemCount = function(e, t) {
            this.itemCounts[e] = this.itemCounts[e] || 0,
            this.itemCounts[e] += t,
            y.send(this.id, "14", e, this.itemCounts[e])
        }
        ,
        this.buildItem = function(e) {
            var t = this.scale + e.scale + (e.placeOffset || 0)
              , i = this.x + t * o(this.dir)
              , n = this.y + t * a(this.dir);
            if (this.canBuild(e) && !(e.consume && this.skin && this.skin.noEat) && (e.consume || u.checkItemLocation(i, n, e.scale, .6, e.id, !1, this))) {
                var s = !1;
                if (e.consume) {
                    if (this.hitTime) {
                        var r = Date.now() - this.hitTime;
                        this.hitTime = 0,
                        r <= 120 ? (this.shameCount++,
                        this.shameCount >= 8 && (this.shameTimer = 3e4,
                        this.shameCount = 0)) : (this.shameCount -= 2,
                        this.shameCount <= 0 && (this.shameCount = 0))
                    }
                    this.shameTimer <= 0 && (s = e.consume(this))
                } else
                    s = !0,
                    e.group.limit && this.changeItemCount(e.group.id, 1),
                    e.pps && (this.pps += e.pps),
                    u.add(u.objects.length, i, n, this.dir, e.scale, e.type, e, !1, this);
                s && (this.useRes(e),
                this.buildIndex = -1)
            }
        }
        ,
        this.hasRes = function(e, t) {
            for (var i = 0; i < e.req.length; ) {
                if (this[e.req[i]] < Math.round(e.req[i + 1] * (t || 1)))
                    return !1;
                i += 2
            }
            return !0
        }
        ,
        this.useRes = function(e, t) {
            if (!i.inSandbox)
                for (var n = 0; n < e.req.length; )
                    this.addResource(i.resourceTypes.indexOf(e.req[n]), -Math.round(e.req[n + 1] * (t || 1))),
                    n += 2
        }
        ,
        this.canBuild = function(e) {
            var t = i.inSandbox ? Math.max(3 * e.group.limit, 99) : e.group.limit;
            return !(t && this.itemCounts[e.group.id] >= t) && (!!i.inSandbox || this.hasRes(e))
        }
        ,
        this.gather = function() {
            this.noMovTimer = 0,
            this.slowMult -= p.weapons[this.weaponIndex].hitSlow || .3,
            this.slowMult < 0 && (this.slowMult = 0);
            for (var e, t, n, s = i.fetchVariant(this), r = s.poison, c = s.val, h = {}, g = u.getGridArrays(this.x, this.y, p.weapons[this.weaponIndex].range), m = 0; m < g.length; ++m)
                for (var y = 0; y < g[m].length; ++y)
                    if ((t = g[m][y]).active && !t.dontGather && !h[t.sid] && t.visibleToPlayer(this) && l.getDistance(this.x, this.y, t.x, t.y) - t.scale <= p.weapons[this.weaponIndex].range && (e = l.getDirection(t.x, t.y, this.x, this.y),
                    l.getAngleDist(e, this.dir) <= i.gatherAngle)) {
                        if (h[t.sid] = 1,
                        t.health) {
                            if (t.changeHealth(-p.weapons[this.weaponIndex].dmg * c * (p.weapons[this.weaponIndex].sDmg || 1) * (this.skin && this.skin.bDmg ? this.skin.bDmg : 1), this)) {
                                for (var k = 0; k < t.req.length; )
                                    this.addResource(i.resourceTypes.indexOf(t.req[k]), t.req[k + 1]),
                                    k += 2;
                                u.disableObj(t)
                            }
                        } else {
                            this.earnXP(4 * p.weapons[this.weaponIndex].gather);
                            var w = p.weapons[this.weaponIndex].gather + (3 == t.type ? 4 : 0);
                            this.skin && this.skin.extraGold && this.addResource(3, 1),
                            this.addResource(t.type, w)
                        }
                        n = !0,
                        u.hitObj(t, e)
                    }
            for (y = 0; y < d.length + f.length; ++y)
                if ((t = d[y] || f[y - d.length]) != this && t.alive && (!t.team || t.team != this.team) && l.getDistance(this.x, this.y, t.x, t.y) - 1.8 * t.scale <= p.weapons[this.weaponIndex].range && (e = l.getDirection(t.x, t.y, this.x, this.y),
                l.getAngleDist(e, this.dir) <= i.gatherAngle)) {
                    var v = p.weapons[this.weaponIndex].steal;
                    v && t.addResource && (v = Math.min(t.points || 0, v),
                    this.addResource(3, v),
                    t.addResource(3, -v));
                    var b = c;
                    null != t.weaponIndex && p.weapons[t.weaponIndex].shield && l.getAngleDist(e + Math.PI, t.dir) <= i.shieldAngle && (b = p.weapons[t.weaponIndex].shield);
                    var x = p.weapons[this.weaponIndex].dmg
                      , S = x * (this.skin && this.skin.dmgMultO ? this.skin.dmgMultO : 1) * (this.tail && this.tail.dmgMultO ? this.tail.dmgMultO : 1)
                      , I = .3 * (t.weightM || 1) + (p.weapons[this.weaponIndex].knock || 0);
                    t.xVel += I * o(e),
                    t.yVel += I * a(e),
                    this.skin && this.skin.healD && this.changeHealth(S * b * this.skin.healD, this),
                    this.tail && this.tail.healD && this.changeHealth(S * b * this.tail.healD, this),
                    t.skin && t.skin.dmg && this.changeHealth(-x * t.skin.dmg, t),
                    t.tail && t.tail.dmg && this.changeHealth(-x * t.tail.dmg, t),
                    !(t.dmgOverTime && this.skin && this.skin.poisonDmg) || t.skin && t.skin.poisonRes || (t.dmgOverTime.dmg = this.skin.poisonDmg,
                    t.dmgOverTime.time = this.skin.poisonTime || 1,
                    t.dmgOverTime.doer = this),
                    !t.dmgOverTime || !r || t.skin && t.skin.poisonRes || (t.dmgOverTime.dmg = 5,
                    t.dmgOverTime.time = 5,
                    t.dmgOverTime.doer = this),
                    t.skin && t.skin.dmgK && (this.xVel -= t.skin.dmgK * o(e),
                    this.yVel -= t.skin.dmgK * a(e)),
                    t.changeHealth(-S * b, this, this)
                }
            this.sendAnimation(n ? 1 : 0)
        }
        ,
        this.sendAnimation = function(e) {
            for (var t = 0; t < d.length; ++t)
                this.sentTo[d[t].id] && this.canSee(d[t]) && y.send(d[t].id, "7", this.sid, e ? 1 : 0, this.weaponIndex)
        }
        ;
        var x = 0
          , S = 0;
        this.animate = function(e) {
            this.animTime > 0 && (this.animTime -= e,
            this.animTime <= 0 ? (this.animTime = 0,
            this.dirPlus = 0,
            x = 0,
            S = 0) : 0 == S ? (x += e / (this.animSpeed * i.hitReturnRatio),
            this.dirPlus = l.lerp(0, this.targetAngle, Math.min(1, x)),
            x >= 1 && (x = 1,
            S = 1)) : (x -= e / (this.animSpeed * (1 - i.hitReturnRatio)),
            this.dirPlus = l.lerp(0, this.targetAngle, Math.max(0, x))))
        }
        ,
        this.startAnim = function(e, t) {
            this.animTime = this.animSpeed = p.weapons[t].speed,
            this.targetAngle = e ? -i.hitAngle : -Math.PI,
            x = 0,
            S = 0
        }
        ,
        this.canSee = function(e) {
            if (!e)
                return !1;
            if (e.skin && e.skin.invisTimer && e.noMovTimer >= e.skin.invisTimer)
                return !1;
            var t = s(e.x - this.x) - e.scale
              , n = s(e.y - this.y) - e.scale;
            return t <= i.maxScreenWidth / 2 * 1.3 && n <= i.maxScreenHeight / 2 * 1.3
        }
    }
}
, function(e, t, i) {
    const n = i(14).words
      , s = i(15).array;
    e.exports = class {
        constructor(e={}) {
            Object.assign(this, {
                list: e.emptyList && [] || Array.prototype.concat.apply(n, [s, e.list || []]),
                exclude: e.exclude || [],
                placeHolder: e.placeHolder || "*",
                regex: e.regex || /[^a-zA-Z0-9|\$|\@]|\^/g,
                replaceRegex: e.replaceRegex || /\w/g
            })
        }
        isProfane(e) {
            return this.list.filter(t=>{
                const i = new RegExp(`\\b ${t.replace(/(\W)/g, "\\$1")}\\b`,"gi");
                return !this.exclude.includes(t.toLowerCase()) && i.test(e)
            }
            ).length > 0 || !1
        }
        replaceWord(e) {
            return e.replace(this.regex, "").replace(this.replaceRegex, this.placeHolder)
        }
        clean(e) {
            return e.split(/\b/).map(e=>this.isProfane(e) ? this.replaceWord(e) : e).join("")
        }
        addWords() {
            let e = Array.from(arguments);
            this.list.push(...e),
            e.map(e=>e.toLowerCase()).forEach(e=>{
                this.exclude.includes(e) && this.exclude.splice(this.exclude.indexOf(e), 1)
            }
            )
        }
        removeWords() {
            this.exclude.push(...Array.from(arguments).map(e=>e.toLowerCase()))
        }
    }
}
, function(e) {
    e.exports = {
        words: ["ahole", "anus", "ash0le", "ash0les", "asholes", "ass", "Ass Monkey", "Assface", "assh0le", "assh0lez", "asshole", "assholes", "assholz", "asswipe", "azzhole", "bassterds", "bastard", "bastards", "bastardz", "basterds", "basterdz", "Biatch", "bitch", "bitches", "Blow Job", "boffing", "butthole", "buttwipe", "c0ck", "c0cks", "c0k", "Carpet Muncher", "cawk", "cawks", "Clit", "cnts", "cntz", "cock", "cockhead", "cock-head", "cocks", "CockSucker", "cock-sucker", "crap", "cum", "cunt", "cunts", "cuntz", "dick", "dild0", "dild0s", "dildo", "dildos", "dilld0", "dilld0s", "dominatricks", "dominatrics", "dominatrix", "dyke", "enema", "f u c k", "f u c k e r", "fag", "fag1t", "faget", "fagg1t", "faggit", "faggot", "fagg0t", "fagit", "fags", "fagz", "faig", "faigs", "fart", "flipping the bird", "fuck", "fucker", "fuckin", "fucking", "fucks", "Fudge Packer", "fuk", "Fukah", "Fuken", "fuker", "Fukin", "Fukk", "Fukkah", "Fukken", "Fukker", "Fukkin", "g00k", "God-damned", "h00r", "h0ar", "h0re", "hells", "hoar", "hoor", "hoore", "jackoff", "jap", "japs", "jerk-off", "jisim", "jiss", "jizm", "jizz", "knob", "knobs", "knobz", "kunt", "kunts", "kuntz", "Lezzian", "Lipshits", "Lipshitz", "masochist", "masokist", "massterbait", "masstrbait", "masstrbate", "masterbaiter", "masterbate", "masterbates", "Motha Fucker", "Motha Fuker", "Motha Fukkah", "Motha Fukker", "Mother Fucker", "Mother Fukah", "Mother Fuker", "Mother Fukkah", "Mother Fukker", "mother-fucker", "Mutha Fucker", "Mutha Fukah", "Mutha Fuker", "Mutha Fukkah", "Mutha Fukker", "n1gr", "nastt", "nigger;", "nigur;", "niiger;", "niigr;", "orafis", "orgasim;", "orgasm", "orgasum", "oriface", "orifice", "orifiss", "packi", "packie", "packy", "paki", "pakie", "paky", "pecker", "peeenus", "peeenusss", "peenus", "peinus", "pen1s", "penas", "penis", "penis-breath", "penus", "penuus", "Phuc", "Phuck", "Phuk", "Phuker", "Phukker", "polac", "polack", "polak", "Poonani", "pr1c", "pr1ck", "pr1k", "pusse", "pussee", "pussy", "puuke", "puuker", "queer", "queers", "queerz", "qweers", "qweerz", "qweir", "recktum", "rectum", "retard", "sadist", "scank", "schlong", "screwing", "semen", "sex", "sexy", "Sh!t", "sh1t", "sh1ter", "sh1ts", "sh1tter", "sh1tz", "shit", "shits", "shitter", "Shitty", "Shity", "shitz", "Shyt", "Shyte", "Shytty", "Shyty", "skanck", "skank", "skankee", "skankey", "skanks", "Skanky", "slag", "slut", "sluts", "Slutty", "slutz", "son-of-a-bitch", "tit", "turd", "va1jina", "vag1na", "vagiina", "vagina", "vaj1na", "vajina", "vullva", "vulva", "w0p", "wh00r", "wh0re", "whore", "xrated", "xxx", "b!+ch", "bitch", "blowjob", "clit", "arschloch", "fuck", "shit", "ass", "asshole", "b!tch", "b17ch", "b1tch", "bastard", "bi+ch", "boiolas", "buceta", "c0ck", "cawk", "chink", "cipa", "clits", "cock", "cum", "cunt", "dildo", "dirsa", "ejakulate", "fatass", "fcuk", "fuk", "fux0r", "hoer", "hore", "jism", "kawk", "l3itch", "l3i+ch", "lesbian", "masturbate", "masterbat*", "masterbat3", "motherfucker", "s.o.b.", "mofo", "nazi", "nigga", "nigger", "nutsack", "phuck", "pimpis", "pusse", "pussy", "scrotum", "sh!t", "shemale", "shi+", "sh!+", "slut", "smut", "teets", "tits", "boobs", "b00bs", "teez", "testical", "testicle", "titt", "w00se", "jackoff", "wank", "whoar", "whore", "*damn", "*dyke", "*fuck*", "*shit*", "@$$", "amcik", "andskota", "arse*", "assrammer", "ayir", "bi7ch", "bitch*", "bollock*", "breasts", "butt-pirate", "cabron", "cazzo", "chraa", "chuj", "Cock*", "cunt*", "d4mn", "daygo", "dego", "dick*", "dike*", "dupa", "dziwka", "ejackulate", "Ekrem*", "Ekto", "enculer", "faen", "fag*", "fanculo", "fanny", "feces", "feg", "Felcher", "ficken", "fitt*", "Flikker", "foreskin", "Fotze", "Fu(*", "fuk*", "futkretzn", "gook", "guiena", "h0r", "h4x0r", "hell", "helvete", "hoer*", "honkey", "Huevon", "hui", "injun", "jizz", "kanker*", "kike", "klootzak", "kraut", "knulle", "kuk", "kuksuger", "Kurac", "kurwa", "kusi*", "kyrpa*", "lesbo", "mamhoon", "masturbat*", "merd*", "mibun", "monkleigh", "mouliewop", "muie", "mulkku", "muschi", "nazis", "nepesaurio", "nigger*", "orospu", "paska*", "perse", "picka", "pierdol*", "pillu*", "pimmel", "piss*", "pizda", "poontsee", "poop", "porn", "p0rn", "pr0n", "preteen", "pula", "pule", "puta", "puto", "qahbeh", "queef*", "rautenberg", "schaffer", "scheiss*", "schlampe", "schmuck", "screw", "sh!t*", "sharmuta", "sharmute", "shipal", "shiz", "skribz", "skurwysyn", "sphencter", "spic", "spierdalaj", "splooge", "suka", "b00b*", "testicle*", "titt*", "twat", "vittu", "wank*", "wetback*", "wichser", "wop*", "yed", "zabourah"]
    }
}
, function(e, t, i) {
    e.exports = {
        object: i(16),
        array: i(17),
        regex: i(18)
    }
}
, function(e, t) {
    e.exports = {
        "4r5e": 1,
        "5h1t": 1,
        "5hit": 1,
        a55: 1,
        anal: 1,
        anus: 1,
        ar5e: 1,
        arrse: 1,
        arse: 1,
        ass: 1,
        "ass-fucker": 1,
        asses: 1,
        assfucker: 1,
        assfukka: 1,
        asshole: 1,
        assholes: 1,
        asswhole: 1,
        a_s_s: 1,
        "b!tch": 1,
        b00bs: 1,
        b17ch: 1,
        b1tch: 1,
        ballbag: 1,
        balls: 1,
        ballsack: 1,
        bastard: 1,
        beastial: 1,
        beastiality: 1,
        bellend: 1,
        bestial: 1,
        bestiality: 1,
        "bi+ch": 1,
        biatch: 1,
        bitch: 1,
        bitcher: 1,
        bitchers: 1,
        bitches: 1,
        bitchin: 1,
        bitching: 1,
        bloody: 1,
        "blow job": 1,
        blowjob: 1,
        blowjobs: 1,
        boiolas: 1,
        bollock: 1,
        bollok: 1,
        boner: 1,
        boob: 1,
        boobs: 1,
        booobs: 1,
        boooobs: 1,
        booooobs: 1,
        booooooobs: 1,
        breasts: 1,
        buceta: 1,
        bugger: 1,
        bum: 1,
        "bunny fucker": 1,
        butt: 1,
        butthole: 1,
        buttmuch: 1,
        buttplug: 1,
        c0ck: 1,
        c0cksucker: 1,
        "carpet muncher": 1,
        cawk: 1,
        chink: 1,
        cipa: 1,
        cl1t: 1,
        clit: 1,
        clitoris: 1,
        clits: 1,
        cnut: 1,
        cock: 1,
        "cock-sucker": 1,
        cockface: 1,
        cockhead: 1,
        cockmunch: 1,
        cockmuncher: 1,
        cocks: 1,
        cocksuck: 1,
        cocksucked: 1,
        cocksucker: 1,
        cocksucking: 1,
        cocksucks: 1,
        cocksuka: 1,
        cocksukka: 1,
        cok: 1,
        cokmuncher: 1,
        coksucka: 1,
        coon: 1,
        cox: 1,
        crap: 1,
        cum: 1,
        cummer: 1,
        cumming: 1,
        cums: 1,
        cumshot: 1,
        cunilingus: 1,
        cunillingus: 1,
        cunnilingus: 1,
        cunt: 1,
        cuntlick: 1,
        cuntlicker: 1,
        cuntlicking: 1,
        cunts: 1,
        cyalis: 1,
        cyberfuc: 1,
        cyberfuck: 1,
        cyberfucked: 1,
        cyberfucker: 1,
        cyberfuckers: 1,
        cyberfucking: 1,
        d1ck: 1,
        damn: 1,
        dick: 1,
        dickhead: 1,
        dildo: 1,
        dildos: 1,
        dink: 1,
        dinks: 1,
        dirsa: 1,
        dlck: 1,
        "dog-fucker": 1,
        doggin: 1,
        dogging: 1,
        donkeyribber: 1,
        doosh: 1,
        duche: 1,
        dyke: 1,
        ejaculate: 1,
        ejaculated: 1,
        ejaculates: 1,
        ejaculating: 1,
        ejaculatings: 1,
        ejaculation: 1,
        ejakulate: 1,
        "f u c k": 1,
        "f u c k e r": 1,
        f4nny: 1,
        fag: 1,
        fagging: 1,
        faggitt: 1,
        faggot: 1,
        faggs: 1,
        fagot: 1,
        fagots: 1,
        fags: 1,
        fanny: 1,
        fannyflaps: 1,
        fannyfucker: 1,
        fanyy: 1,
        fatass: 1,
        fcuk: 1,
        fcuker: 1,
        fcuking: 1,
        feck: 1,
        fecker: 1,
        felching: 1,
        fellate: 1,
        fellatio: 1,
        fingerfuck: 1,
        fingerfucked: 1,
        fingerfucker: 1,
        fingerfuckers: 1,
        fingerfucking: 1,
        fingerfucks: 1,
        fistfuck: 1,
        fistfucked: 1,
        fistfucker: 1,
        fistfuckers: 1,
        fistfucking: 1,
        fistfuckings: 1,
        fistfucks: 1,
        flange: 1,
        fook: 1,
        fooker: 1,
        fuck: 1,
        fucka: 1,
        fucked: 1,
        fucker: 1,
        fuckers: 1,
        fuckhead: 1,
        fuckheads: 1,
        fuckin: 1,
        fucking: 1,
        fuckings: 1,
        fuckingshitmotherfucker: 1,
        fuckme: 1,
        fucks: 1,
        fuckwhit: 1,
        fuckwit: 1,
        "fudge packer": 1,
        fudgepacker: 1,
        fuk: 1,
        fuker: 1,
        fukker: 1,
        fukkin: 1,
        fuks: 1,
        fukwhit: 1,
        fukwit: 1,
        fux: 1,
        fux0r: 1,
        f_u_c_k: 1,
        gangbang: 1,
        gangbanged: 1,
        gangbangs: 1,
        gaylord: 1,
        gaysex: 1,
        goatse: 1,
        God: 1,
        "god-dam": 1,
        "god-damned": 1,
        goddamn: 1,
        goddamned: 1,
        hardcoresex: 1,
        hell: 1,
        heshe: 1,
        hoar: 1,
        hoare: 1,
        hoer: 1,
        homo: 1,
        hore: 1,
        horniest: 1,
        horny: 1,
        hotsex: 1,
        "jack-off": 1,
        jackoff: 1,
        jap: 1,
        "jerk-off": 1,
        jism: 1,
        jiz: 1,
        jizm: 1,
        jizz: 1,
        kawk: 1,
        knob: 1,
        knobead: 1,
        knobed: 1,
        knobend: 1,
        knobhead: 1,
        knobjocky: 1,
        knobjokey: 1,
        kock: 1,
        kondum: 1,
        kondums: 1,
        kum: 1,
        kummer: 1,
        kumming: 1,
        kums: 1,
        kunilingus: 1,
        "l3i+ch": 1,
        l3itch: 1,
        labia: 1,
        lust: 1,
        lusting: 1,
        m0f0: 1,
        m0fo: 1,
        m45terbate: 1,
        ma5terb8: 1,
        ma5terbate: 1,
        masochist: 1,
        "master-bate": 1,
        masterb8: 1,
        "masterbat*": 1,
        masterbat3: 1,
        masterbate: 1,
        masterbation: 1,
        masterbations: 1,
        masturbate: 1,
        "mo-fo": 1,
        mof0: 1,
        mofo: 1,
        mothafuck: 1,
        mothafucka: 1,
        mothafuckas: 1,
        mothafuckaz: 1,
        mothafucked: 1,
        mothafucker: 1,
        mothafuckers: 1,
        mothafuckin: 1,
        mothafucking: 1,
        mothafuckings: 1,
        mothafucks: 1,
        "mother fucker": 1,
        motherfuck: 1,
        motherfucked: 1,
        motherfucker: 1,
        motherfuckers: 1,
        motherfuckin: 1,
        motherfucking: 1,
        motherfuckings: 1,
        motherfuckka: 1,
        motherfucks: 1,
        muff: 1,
        mutha: 1,
        muthafecker: 1,
        muthafuckker: 1,
        muther: 1,
        mutherfucker: 1,
        n1gga: 1,
        n1gger: 1,
        nazi: 1,
        nigg3r: 1,
        nigg4h: 1,
        nigga: 1,
        niggah: 1,
        niggas: 1,
        niggaz: 1,
        nigger: 1,
        niggers: 1,
        nob: 1,
        "nob jokey": 1,
        nobhead: 1,
        nobjocky: 1,
        nobjokey: 1,
        numbnuts: 1,
        nutsack: 1,
        orgasim: 1,
        orgasims: 1,
        orgasm: 1,
        orgasms: 1,
        p0rn: 1,
        pawn: 1,
        pecker: 1,
        penis: 1,
        penisfucker: 1,
        phonesex: 1,
        phuck: 1,
        phuk: 1,
        phuked: 1,
        phuking: 1,
        phukked: 1,
        phukking: 1,
        phuks: 1,
        phuq: 1,
        pigfucker: 1,
        pimpis: 1,
        piss: 1,
        pissed: 1,
        pisser: 1,
        pissers: 1,
        pisses: 1,
        pissflaps: 1,
        pissin: 1,
        pissing: 1,
        pissoff: 1,
        poop: 1,
        porn: 1,
        porno: 1,
        pornography: 1,
        pornos: 1,
        prick: 1,
        pricks: 1,
        pron: 1,
        pube: 1,
        pusse: 1,
        pussi: 1,
        pussies: 1,
        pussy: 1,
        pussys: 1,
        rectum: 1,
        retard: 1,
        rimjaw: 1,
        rimming: 1,
        "s hit": 1,
        "s.o.b.": 1,
        sadist: 1,
        schlong: 1,
        screwing: 1,
        scroat: 1,
        scrote: 1,
        scrotum: 1,
        semen: 1,
        sex: 1,
        "sh!+": 1,
        "sh!t": 1,
        sh1t: 1,
        shag: 1,
        shagger: 1,
        shaggin: 1,
        shagging: 1,
        shemale: 1,
        "shi+": 1,
        shit: 1,
        shitdick: 1,
        shite: 1,
        shited: 1,
        shitey: 1,
        shitfuck: 1,
        shitfull: 1,
        shithead: 1,
        shiting: 1,
        shitings: 1,
        shits: 1,
        shitted: 1,
        shitter: 1,
        shitters: 1,
        shitting: 1,
        shittings: 1,
        shitty: 1,
        skank: 1,
        slut: 1,
        sluts: 1,
        smegma: 1,
        smut: 1,
        snatch: 1,
        "son-of-a-bitch": 1,
        spac: 1,
        spunk: 1,
        s_h_i_t: 1,
        t1tt1e5: 1,
        t1tties: 1,
        teets: 1,
        teez: 1,
        testical: 1,
        testicle: 1,
        tit: 1,
        titfuck: 1,
        tits: 1,
        titt: 1,
        tittie5: 1,
        tittiefucker: 1,
        titties: 1,
        tittyfuck: 1,
        tittywank: 1,
        titwank: 1,
        tosser: 1,
        turd: 1,
        tw4t: 1,
        twat: 1,
        twathead: 1,
        twatty: 1,
        twunt: 1,
        twunter: 1,
        v14gra: 1,
        v1gra: 1,
        vagina: 1,
        viagra: 1,
        vulva: 1,
        w00se: 1,
        wang: 1,
        wank: 1,
        wanker: 1,
        wanky: 1,
        whoar: 1,
        whore: 1,
        willies: 1,
        willy: 1,
        xrated: 1,
        xxx: 1
    }
}
, function(e, t) {
    e.exports = ["4r5e", "5h1t", "5hit", "a55", "anal", "anus", "ar5e", "arrse", "arse", "ass", "ass-fucker", "asses", "assfucker", "assfukka", "asshole", "assholes", "asswhole", "a_s_s", "b!tch", "b00bs", "b17ch", "b1tch", "ballbag", "balls", "ballsack", "bastard", "beastial", "beastiality", "bellend", "bestial", "bestiality", "bi+ch", "biatch", "bitch", "bitcher", "bitchers", "bitches", "bitchin", "bitching", "bloody", "blow job", "blowjob", "blowjobs", "boiolas", "bollock", "bollok", "boner", "boob", "boobs", "booobs", "boooobs", "booooobs", "booooooobs", "breasts", "buceta", "bugger", "bum", "bunny fucker", "butt", "butthole", "buttmuch", "buttplug", "c0ck", "c0cksucker", "carpet muncher", "cawk", "chink", "cipa", "cl1t", "clit", "clitoris", "clits", "cnut", "cock", "cock-sucker", "cockface", "cockhead", "cockmunch", "cockmuncher", "cocks", "cocksuck", "cocksucked", "cocksucker", "cocksucking", "cocksucks", "cocksuka", "cocksukka", "cok", "cokmuncher", "coksucka", "coon", "cox", "crap", "cum", "cummer", "cumming", "cums", "cumshot", "cunilingus", "cunillingus", "cunnilingus", "cunt", "cuntlick", "cuntlicker", "cuntlicking", "cunts", "cyalis", "cyberfuc", "cyberfuck", "cyberfucked", "cyberfucker", "cyberfuckers", "cyberfucking", "d1ck", "damn", "dick", "dickhead", "dildo", "dildos", "dink", "dinks", "dirsa", "dlck", "dog-fucker", "doggin", "dogging", "donkeyribber", "doosh", "duche", "dyke", "ejaculate", "ejaculated", "ejaculates", "ejaculating", "ejaculatings", "ejaculation", "ejakulate", "f u c k", "f u c k e r", "f4nny", "fag", "fagging", "faggitt", "faggot", "faggs", "fagot", "fagots", "fags", "fanny", "fannyflaps", "fannyfucker", "fanyy", "fatass", "fcuk", "fcuker", "fcuking", "feck", "fecker", "felching", "fellate", "fellatio", "fingerfuck", "fingerfucked", "fingerfucker", "fingerfuckers", "fingerfucking", "fingerfucks", "fistfuck", "fistfucked", "fistfucker", "fistfuckers", "fistfucking", "fistfuckings", "fistfucks", "flange", "fook", "fooker", "fuck", "fucka", "fucked", "fucker", "fuckers", "fuckhead", "fuckheads", "fuckin", "fucking", "fuckings", "fuckingshitmotherfucker", "fuckme", "fucks", "fuckwhit", "fuckwit", "fudge packer", "fudgepacker", "fuk", "fuker", "fukker", "fukkin", "fuks", "fukwhit", "fukwit", "fux", "fux0r", "f_u_c_k", "gangbang", "gangbanged", "gangbangs", "gaylord", "gaysex", "goatse", "God", "god-dam", "god-damned", "goddamn", "goddamned", "hardcoresex", "hell", "heshe", "hoar", "hoare", "hoer", "homo", "hore", "horniest", "horny", "hotsex", "jack-off", "jackoff", "jap", "jerk-off", "jism", "jiz", "jizm", "jizz", "kawk", "knob", "knobead", "knobed", "knobend", "knobhead", "knobjocky", "knobjokey", "kock", "kondum", "kondums", "kum", "kummer", "kumming", "kums", "kunilingus", "l3i+ch", "l3itch", "labia", "lust", "lusting", "m0f0", "m0fo", "m45terbate", "ma5terb8", "ma5terbate", "masochist", "master-bate", "masterb8", "masterbat*", "masterbat3", "masterbate", "masterbation", "masterbations", "masturbate", "mo-fo", "mof0", "mofo", "mothafuck", "mothafucka", "mothafuckas", "mothafuckaz", "mothafucked", "mothafucker", "mothafuckers", "mothafuckin", "mothafucking", "mothafuckings", "mothafucks", "mother fucker", "motherfuck", "motherfucked", "motherfucker", "motherfuckers", "motherfuckin", "motherfucking", "motherfuckings", "motherfuckka", "motherfucks", "muff", "mutha", "muthafecker", "muthafuckker", "muther", "mutherfucker", "n1gga", "n1gger", "nazi", "nigg3r", "nigg4h", "nigga", "niggah", "niggas", "niggaz", "nigger", "niggers", "nob", "nob jokey", "nobhead", "nobjocky", "nobjokey", "numbnuts", "nutsack", "orgasim", "orgasims", "orgasm", "orgasms", "p0rn", "pawn", "pecker", "penis", "penisfucker", "phonesex", "phuck", "phuk", "phuked", "phuking", "phukked", "phukking", "phuks", "phuq", "pigfucker", "pimpis", "piss", "pissed", "pisser", "pissers", "pisses", "pissflaps", "pissin", "pissing", "pissoff", "poop", "porn", "porno", "pornography", "pornos", "prick", "pricks", "pron", "pube", "pusse", "pussi", "pussies", "pussy", "pussys", "rectum", "retard", "rimjaw", "rimming", "s hit", "s.o.b.", "sadist", "schlong", "screwing", "scroat", "scrote", "scrotum", "semen", "sex", "sh!+", "sh!t", "sh1t", "shag", "shagger", "shaggin", "shagging", "shemale", "shi+", "shit", "shitdick", "shite", "shited", "shitey", "shitfuck", "shitfull", "shithead", "shiting", "shitings", "shits", "shitted", "shitter", "shitters", "shitting", "shittings", "shitty", "skank", "slut", "sluts", "smegma", "smut", "snatch", "son-of-a-bitch", "spac", "spunk", "s_h_i_t", "t1tt1e5", "t1tties", "teets", "teez", "testical", "testicle", "tit", "titfuck", "tits", "titt", "tittie5", "tittiefucker", "titties", "tittyfuck", "tittywank", "titwank", "tosser", "turd", "tw4t", "twat", "twathead", "twatty", "twunt", "twunter", "v14gra", "v1gra", "vagina", "viagra", "vulva", "w00se", "wang", "wank", "wanker", "wanky", "whoar", "whore", "willies", "willy", "xrated", "xxx"]
}
, function(e, t) {
    e.exports = /\b(4r5e|5h1t|5hit|a55|anal|anus|ar5e|arrse|arse|ass|ass-fucker|asses|assfucker|assfukka|asshole|assholes|asswhole|a_s_s|b!tch|b00bs|b17ch|b1tch|ballbag|balls|ballsack|bastard|beastial|beastiality|bellend|bestial|bestiality|bi\+ch|biatch|bitch|bitcher|bitchers|bitches|bitchin|bitching|bloody|blow job|blowjob|blowjobs|boiolas|bollock|bollok|boner|boob|boobs|booobs|boooobs|booooobs|booooooobs|breasts|buceta|bugger|bum|bunny fucker|butt|butthole|buttmuch|buttplug|c0ck|c0cksucker|carpet muncher|cawk|chink|cipa|cl1t|clit|clitoris|clits|cnut|cock|cock-sucker|cockface|cockhead|cockmunch|cockmuncher|cocks|cocksuck|cocksucked|cocksucker|cocksucking|cocksucks|cocksuka|cocksukka|cok|cokmuncher|coksucka|coon|cox|crap|cum|cummer|cumming|cums|cumshot|cunilingus|cunillingus|cunnilingus|cunt|cuntlick|cuntlicker|cuntlicking|cunts|cyalis|cyberfuc|cyberfuck|cyberfucked|cyberfucker|cyberfuckers|cyberfucking|d1ck|damn|dick|dickhead|dildo|dildos|dink|dinks|dirsa|dlck|dog-fucker|doggin|dogging|donkeyribber|doosh|duche|dyke|ejaculate|ejaculated|ejaculates|ejaculating|ejaculatings|ejaculation|ejakulate|f u c k|f u c k e r|f4nny|fag|fagging|faggitt|faggot|faggs|fagot|fagots|fags|fanny|fannyflaps|fannyfucker|fanyy|fatass|fcuk|fcuker|fcuking|feck|fecker|felching|fellate|fellatio|fingerfuck|fingerfucked|fingerfucker|fingerfuckers|fingerfucking|fingerfucks|fistfuck|fistfucked|fistfucker|fistfuckers|fistfucking|fistfuckings|fistfucks|flange|fook|fooker|fuck|fucka|fucked|fucker|fuckers|fuckhead|fuckheads|fuckin|fucking|fuckings|fuckingshitmotherfucker|fuckme|fucks|fuckwhit|fuckwit|fudge packer|fudgepacker|fuk|fuker|fukker|fukkin|fuks|fukwhit|fukwit|fux|fux0r|f_u_c_k|gangbang|gangbanged|gangbangs|gaylord|gaysex|goatse|God|god-dam|god-damned|goddamn|goddamned|hardcoresex|hell|heshe|hoar|hoare|hoer|homo|hore|horniest|horny|hotsex|jack-off|jackoff|jap|jerk-off|jism|jiz|jizm|jizz|kawk|knob|knobead|knobed|knobend|knobhead|knobjocky|knobjokey|kock|kondum|kondums|kum|kummer|kumming|kums|kunilingus|l3i\+ch|l3itch|labia|lust|lusting|m0f0|m0fo|m45terbate|ma5terb8|ma5terbate|masochist|master-bate|masterb8|masterbat*|masterbat3|masterbate|masterbation|masterbations|masturbate|mo-fo|mof0|mofo|mothafuck|mothafucka|mothafuckas|mothafuckaz|mothafucked|mothafucker|mothafuckers|mothafuckin|mothafucking|mothafuckings|mothafucks|mother fucker|motherfuck|motherfucked|motherfucker|motherfuckers|motherfuckin|motherfucking|motherfuckings|motherfuckka|motherfucks|muff|mutha|muthafecker|muthafuckker|muther|mutherfucker|n1gga|n1gger|nazi|nigg3r|nigg4h|nigga|niggah|niggas|niggaz|nigger|niggers|nob|nob jokey|nobhead|nobjocky|nobjokey|numbnuts|nutsack|orgasim|orgasims|orgasm|orgasms|p0rn|pawn|pecker|penis|penisfucker|phonesex|phuck|phuk|phuked|phuking|phukked|phukking|phuks|phuq|pigfucker|pimpis|piss|pissed|pisser|pissers|pisses|pissflaps|pissin|pissing|pissoff|poop|porn|porno|pornography|pornos|prick|pricks|pron|pube|pusse|pussi|pussies|pussy|pussys|rectum|retard|rimjaw|rimming|s hit|s.o.b.|sadist|schlong|screwing|scroat|scrote|scrotum|semen|sex|sh!\+|sh!t|sh1t|shag|shagger|shaggin|shagging|shemale|shi\+|shit|shitdick|shite|shited|shitey|shitfuck|shitfull|shithead|shiting|shitings|shits|shitted|shitter|shitters|shitting|shittings|shitty|skank|slut|sluts|smegma|smut|snatch|son-of-a-bitch|spac|spunk|s_h_i_t|t1tt1e5|t1tties|teets|teez|testical|testicle|tit|titfuck|tits|titt|tittie5|tittiefucker|titties|tittyfuck|tittywank|titwank|tosser|turd|tw4t|twat|twathead|twatty|twunt|twunter|v14gra|v1gra|vagina|viagra|vulva|w00se|wang|wank|wanker|wanky|whoar|whore|willies|willy|xrated|xxx)\b/gi
}
, function(e, t) {
    e.exports.hats = [{
        id: 45,
        name: "Shame!",
        dontSell: !0,
        price: 0,
        scale: 120,
        desc: "hacks are for losers"
    }, {
        id: 51,
        name: "Moo Cap",
        price: 0,
        scale: 120,
        desc: "coolest mooer around"
    }, {
        id: 50,
        name: "Apple Cap",
        price: 0,
        scale: 120,
        desc: "apple farms remembers"
    }, {
        id: 28,
        name: "Moo Head",
        price: 0,
        scale: 120,
        desc: "no effect"
    }, {
        id: 29,
        name: "Pig Head",
        price: 0,
        scale: 120,
        desc: "no effect"
    }, {
        id: 30,
        name: "Fluff Head",
        price: 0,
        scale: 120,
        desc: "no effect"
    }, {
        id: 36,
        name: "Pandou Head",
        price: 0,
        scale: 120,
        desc: "no effect"
    }, {
        id: 37,
        name: "Bear Head",
        price: 0,
        scale: 120,
        desc: "no effect"
    }, {
        id: 38,
        name: "Monkey Head",
        price: 0,
        scale: 120,
        desc: "no effect"
    }, {
        id: 44,
        name: "Polar Head",
        price: 0,
        scale: 120,
        desc: "no effect"
    }, {
        id: 35,
        name: "Fez Hat",
        price: 0,
        scale: 120,
        desc: "no effect"
    }, {
        id: 42,
        name: "Enigma Hat",
        price: 0,
        scale: 120,
        desc: "join the enigma army"
    }, {
        id: 43,
        name: "Blitz Hat",
        price: 0,
        scale: 120,
        desc: "hey everybody i'm blitz"
    }, {
        id: 49,
        name: "Bob XIII Hat",
        price: 0,
        scale: 120,
        desc: "like and subscribe"
    }, {
        id: 57,
        name: "Pumpkin",
        price: 50,
        scale: 120,
        desc: "Spooooky"
    }, {
        id: 8,
        name: "Bummle Hat",
        price: 100,
        scale: 120,
        desc: "no effect"
    }, {
        id: 2,
        name: "Straw Hat",
        price: 500,
        scale: 120,
        desc: "no effect"
    }, {
        id: 15,
        name: "Winter Cap",
        price: 600,
        scale: 120,
        desc: "allows you to move at normal speed in snow",
        coldM: 1
    }, {
        id: 5,
        name: "Cowboy Hat",
        price: 1e3,
        scale: 120,
        desc: "no effect"
    }, {
        id: 4,
        name: "Ranger Hat",
        price: 2e3,
        scale: 120,
        desc: "no effect"
    }, {
        id: 18,
        name: "Explorer Hat",
        price: 2e3,
        scale: 120,
        desc: "no effect"
    }, {
        id: 31,
        name: "Flipper Hat",
        price: 2500,
        scale: 120,
        desc: "have more control while in water",
        watrImm: !0
    }, {
        id: 1,
        name: "Marksman Cap",
        price: 3e3,
        scale: 120,
        desc: "increases arrow speed and range",
        aMlt: 1.3
    }, {
        id: 10,
        name: "Bush Gear",
        price: 3e3,
        scale: 160,
        desc: "allows you to disguise yourself as a bush"
    }, {
        id: 48,
        name: "Halo",
        price: 3e3,
        scale: 120,
        desc: "no effect"
    }, {
        id: 6,
        name: "Soldier Helmet",
        price: 4e3,
        scale: 120,
        desc: "reduces damage taken but slows movement",
        spdMult: .94,
        dmgMult: .75
    }, {
        id: 23,
        name: "Anti Venom Gear",
        price: 4e3,
        scale: 120,
        desc: "makes you immune to poison",
        poisonRes: 1
    }, {
        id: 13,
        name: "Medic Gear",
        price: 5e3,
        scale: 110,
        desc: "slowly regenerates health over time",
        healthRegen: 3
    }, {
        id: 9,
        name: "Miners Helmet",
        price: 5e3,
        scale: 120,
        desc: "earn 1 extra gold per resource",
        extraGold: 1
    }, {
        id: 32,
        name: "Musketeer Hat",
        price: 5e3,
        scale: 120,
        desc: "reduces cost of projectiles",
        projCost: .5
    }, {
        id: 7,
        name: "Bull Helmet",
        price: 6e3,
        scale: 120,
        desc: "increases damage done but drains health",
        healthRegen: -5,
        dmgMultO: 1.5,
        spdMult: .96
    }, {
        id: 22,
        name: "Emp Helmet",
        price: 6e3,
        scale: 120,
        desc: "turrets won't attack but you move slower",
        antiTurret: 1,
        spdMult: .7
    }, {
        id: 12,
        name: "Booster Hat",
        price: 6e3,
        scale: 120,
        desc: "increases your movement speed",
        spdMult: 1.16
    }, {
        id: 26,
        name: "Barbarian Armor",
        price: 8e3,
        scale: 120,
        desc: "knocks back enemies that attack you",
        dmgK: .6
    }, {
        id: 21,
        name: "Plague Mask",
        price: 1e4,
        scale: 120,
        desc: "melee attacks deal poison damage",
        poisonDmg: 5,
        poisonTime: 6
    }, {
        id: 46,
        name: "Bull Mask",
        price: 1e4,
        scale: 120,
        desc: "bulls won't target you unless you attack them",
        bullRepel: 1
    }, {
        id: 14,
        name: "Windmill Hat",
        topSprite: !0,
        price: 1e4,
        scale: 120,
        desc: "generates points while worn",
        pps: 1.5
    }, {
        id: 11,
        name: "Spike Gear",
        topSprite: !0,
        price: 1e4,
        scale: 120,
        desc: "deal damage to players that damage you",
        dmg: .45
    }, {
        id: 53,
        name: "Turret Gear",
        topSprite: !0,
        price: 1e4,
        scale: 120,
        desc: "you become a walking turret",
        turret: {
            proj: 1,
            range: 700,
            rate: 2500
        },
        spdMult: .7
    }, {
        id: 20,
        name: "Samurai Armor",
        price: 12e3,
        scale: 120,
        desc: "increased attack speed and fire rate",
        atkSpd: .78
    }, {
        id: 58,
        name: "Dark Knight",
        price: 12e3,
        scale: 120,
        desc: "restores health when you deal damage",
        healD: .4
    }, {
        id: 27,
        name: "Scavenger Gear",
        price: 15e3,
        scale: 120,
        desc: "earn double points for each kill",
        kScrM: 2
    }, {
        id: 40,
        name: "Tank Gear",
        price: 15e3,
        scale: 120,
        desc: "increased damage to buildings but slower movement",
        spdMult: .3,
        bDmg: 3.3
    }, {
        id: 52,
        name: "Thief Gear",
        price: 15e3,
        scale: 120,
        desc: "steal half of a players gold when you kill them",
        goldSteal: .5
    }, {
        id: 55,
        name: "Bloodthirster",
        price: 2e4,
        scale: 120,
        desc: "Restore Health when dealing damage. And increased damage",
        healD: .25,
        dmgMultO: 1.2
    }, {
        id: 56,
        name: "Assassin Gear",
        price: 2e4,
        scale: 120,
        desc: "Go invisible when not moving. Can't eat. Increased speed",
        noEat: !0,
        spdMult: 1.1,
        invisTimer: 1e3
    }],
    e.exports.accessories = [{
        id: 12,
        name: "Snowball",
        price: 1e3,
        scale: 105,
        xOff: 18,
        desc: "no effect"
    }, {
        id: 9,
        name: "Tree Cape",
        price: 1e3,
        scale: 90,
        desc: "no effect"
    }, {
        id: 10,
        name: "Stone Cape",
        price: 1e3,
        scale: 90,
        desc: "no effect"
    }, {
        id: 3,
        name: "Cookie Cape",
        price: 1500,
        scale: 90,
        desc: "no effect"
    }, {
        id: 8,
        name: "Cow Cape",
        price: 2e3,
        scale: 90,
        desc: "no effect"
    }, {
        id: 11,
        name: "Monkey Tail",
        price: 2e3,
        scale: 97,
        xOff: 25,
        desc: "Super speed but reduced damage",
        spdMult: 1.35,
        dmgMultO: .2
    }, {
        id: 17,
        name: "Apple Basket",
        price: 3e3,
        scale: 80,
        xOff: 12,
        desc: "slowly regenerates health over time",
        healthRegen: 1
    }, {
        id: 6,
        name: "Winter Cape",
        price: 3e3,
        scale: 90,
        desc: "no effect"
    }, {
        id: 4,
        name: "Skull Cape",
        price: 4e3,
        scale: 90,
        desc: "no effect"
    }, {
        id: 5,
        name: "Dash Cape",
        price: 5e3,
        scale: 90,
        desc: "no effect"
    }, {
        id: 2,
        name: "Dragon Cape",
        price: 6e3,
        scale: 90,
        desc: "no effect"
    }, {
        id: 1,
        name: "Super Cape",
        price: 8e3,
        scale: 90,
        desc: "no effect"
    }, {
        id: 7,
        name: "Troll Cape",
        price: 8e3,
        scale: 90,
        desc: "no effect"
    }, {
        id: 14,
        name: "Thorns",
        price: 1e4,
        scale: 115,
        xOff: 20,
        desc: "no effect"
    }, {
        id: 15,
        name: "Blockades",
        price: 1e4,
        scale: 95,
        xOff: 15,
        desc: "no effect"
    }, {
        id: 20,
        name: "Devils Tail",
        price: 1e4,
        scale: 95,
        xOff: 20,
        desc: "no effect"
    }, {
        id: 16,
        name: "Sawblade",
        price: 12e3,
        scale: 90,
        spin: !0,
        xOff: 0,
        desc: "deal damage to players that damage you",
        dmg: .15
    }, {
        id: 13,
        name: "Angel Wings",
        price: 15e3,
        scale: 138,
        xOff: 22,
        desc: "slowly regenerates health over time",
        healthRegen: 3
    }, {
        id: 19,
        name: "Shadow Wings",
        price: 15e3,
        scale: 138,
        xOff: 22,
        desc: "increased movement speed",
        spdMult: 1.1
    }, {
        id: 18,
        name: "Blood Wings",
        price: 2e4,
        scale: 178,
        xOff: 26,
        desc: "restores health when you deal damage",
        healD: .2
    }, {
        id: 21,
        name: "Corrupt X Wings",
        price: 2e4,
        scale: 178,
        xOff: 26,
        desc: "deal damage to players that damage you",
        dmg: .25
    }]
}
, function(e, t) {
    e.exports = function(e, t, i, n, s, o, a) {
        this.init = function(e, t, i, n, s, o, r, c, l) {
            this.active = !0,
            this.indx = e,
            this.x = t,
            this.y = i,
            this.dir = n,
            this.skipMov = !0,
            this.speed = s,
            this.dmg = o,
            this.scale = c,
            this.range = r,
            this.owner = l,
            a && (this.sentTo = {})
        }
        ;
        var r, c = [];
        this.update = function(l) {
            if (this.active) {
                var h, u = this.speed * l;
                if (this.skipMov ? this.skipMov = !1 : (this.x += u * Math.cos(this.dir),
                this.y += u * Math.sin(this.dir),
                this.range -= u,
                this.range <= 0 && (this.x += this.range * Math.cos(this.dir),
                this.y += this.range * Math.sin(this.dir),
                u = 1,
                this.range = 0,
                this.active = !1)),
                a) {
                    for (var d = 0; d < e.length; ++d)
                        !this.sentTo[e[d].id] && e[d].canSee(this) && (this.sentTo[e[d].id] = 1,
                        a.send(e[d].id, "18", o.fixTo(this.x, 1), o.fixTo(this.y, 1), o.fixTo(this.dir, 2), o.fixTo(this.range, 1), this.speed, this.indx, this.layer, this.sid));
                    for (c.length = 0,
                    d = 0; d < e.length + t.length; ++d)
                        !(r = e[d] || t[d - e.length]).alive || r == this.owner || this.owner.team && r.team == this.owner.team || o.lineInRect(r.x - r.scale, r.y - r.scale, r.x + r.scale, r.y + r.scale, this.x, this.y, this.x + u * Math.cos(this.dir), this.y + u * Math.sin(this.dir)) && c.push(r);
                    for (var f = i.getGridArrays(this.x, this.y, this.scale), p = 0; p < f.length; ++p)
                        for (var g = 0; g < f[p].length; ++g)
                            h = (r = f[p][g]).getScale(),
                            r.active && this.ignoreObj != r.sid && this.layer <= r.layer && c.indexOf(r) < 0 && !r.ignoreCollision && o.lineInRect(r.x - h, r.y - h, r.x + h, r.y + h, this.x, this.y, this.x + u * Math.cos(this.dir), this.y + u * Math.sin(this.dir)) && c.push(r);
                    if (c.length > 0) {
                        var m = null
                          , y = null
                          , k = null;
                        for (d = 0; d < c.length; ++d)
                            k = o.getDistance(this.x, this.y, c[d].x, c[d].y),
                            (null == y || k < y) && (y = k,
                            m = c[d]);
                        if (m.isPlayer || m.isAI) {
                            var w = .3 * (m.weightM || 1);
                            m.xVel += w * Math.cos(this.dir),
                            m.yVel += w * Math.sin(this.dir),
                            null != m.weaponIndex && n.weapons[m.weaponIndex].shield && o.getAngleDist(this.dir + Math.PI, m.dir) <= s.shieldAngle || m.changeHealth(-this.dmg, this.owner, this.owner)
                        } else
                            for (m.projDmg && m.health && m.changeHealth(-this.dmg) && i.disableObj(m),
                            d = 0; d < e.length; ++d)
                                e[d].active && (m.sentTo[e[d].id] && (m.active ? e[d].canSee(m) && a.send(e[d].id, "8", o.fixTo(this.dir, 2), m.sid) : a.send(e[d].id, "12", m.sid)),
                                m.active || m.owner != e[d] || e[d].changeItemCount(m.group.id, -1));
                        for (this.active = !1,
                        d = 0; d < e.length; ++d)
                            this.sentTo[e[d].id] && a.send(e[d].id, "19", this.sid, o.fixTo(y, 1))
                    }
                }
            }
        }
    }
}
, function(e, t) {
    e.exports = function(e, t, i, n, s, o, a, r, c) {
        this.addProjectile = function(l, h, u, d, f, p, g, m, y) {
            for (var k, w = o.projectiles[p], v = 0; v < t.length; ++v)
                if (!t[v].active) {
                    k = t[v];
                    break
                }
            return k || ((k = new e(i,n,s,o,a,r,c)).sid = t.length,
            t.push(k)),
            k.init(p, l, h, u, f, w.dmg, d, w.scale, g),
            k.ignoreObj = m,
            k.layer = y || w.layer,
            k.src = w.src,
            k
        }
    }
}
, function(e, t) {
    e.exports.obj = function(e, t) {
        var i;
        this.sounds = [],
        this.active = !0,
        this.play = function(t, n, s) {
            n && this.active && ((i = this.sounds[t]) || (i = new Howl({
                src: ".././sound/" + t + ".mp3"
            }),
            this.sounds[t] = i),
            s && i.isPlaying || (i.isPlaying = !0,
            i.play(),
            i.volume((n || 1) * e.volumeMult),
            i.loop(s)))
        }
        ,
        this.toggleMute = function(e, t) {
            (i = this.sounds[e]) && i.mute(t)
        }
        ,
        this.stop = function(e) {
            (i = this.sounds[e]) && (i.stop(),
            i.isPlaying = !1)
        }
    }
}
, function(e, t, i) {
    var n = i(24)
      , s = i(32);
    function o(e, t, i, n, s) {
        "localhost" == location.hostname && (window.location.hostname = "127.0.0.1"),
        this.debugLog = !1,
        this.baseUrl = e,
        this.lobbySize = i,
        this.devPort = t,
        this.lobbySpread = n,
        this.rawIPs = !!s,
        this.server = void 0,
        this.gameIndex = void 0,
        this.callback = void 0,
        this.errorCallback = void 0,
        this.processServers(vultr.servers)
    }
    o.prototype.regionInfo = {
        0: {
            name: "Local",
            latitude: 0,
            longitude: 0
        },
        "vultr:1": {
            name: "New Jersey",
            latitude: 40.1393329,
            longitude: -75.8521818
        },
        "vultr:2": {
            name: "Chicago",
            latitude: 41.8339037,
            longitude: -87.872238
        },
        "vultr:3": {
            name: "Dallas",
            latitude: 32.8208751,
            longitude: -96.8714229
        },
        "vultr:4": {
            name: "Seattle",
            latitude: 47.6149942,
            longitude: -122.4759879
        },
        "vultr:5": {
            name: "Los Angeles",
            latitude: 34.0207504,
            longitude: -118.691914
        },
        "vultr:6": {
            name: "Atlanta",
            latitude: 33.7676334,
            longitude: -84.5610332
        },
        "vultr:7": {
            name: "Amsterdam",
            latitude: 52.3745287,
            longitude: 4.7581878
        },
        "vultr:8": {
            name: "London",
            latitude: 51.5283063,
            longitude: -.382486
        },
        "vultr:9": {
            name: "Frankfurt",
            latitude: 50.1211273,
            longitude: 8.496137
        },
        "vultr:12": {
            name: "Silicon Valley",
            latitude: 37.4024714,
            longitude: -122.3219752
        },
        "vultr:19": {
            name: "Sydney",
            latitude: -33.8479715,
            longitude: 150.651084
        },
        "vultr:24": {
            name: "Paris",
            latitude: 48.8588376,
            longitude: 2.2773454
        },
        "vultr:25": {
            name: "Tokyo",
            latitude: 35.6732615,
            longitude: 139.569959
        },
        "vultr:39": {
            name: "Miami",
            latitude: 25.7823071,
            longitude: -80.3012156
        },
        "vultr:40": {
            name: "Singapore",
            latitude: 1.3147268,
            longitude: 103.7065876
        }
    },
    o.prototype.start = function(e, t) {
        this.callback = e,
        this.errorCallback = t;
        var i = this.parseServerQuery();
        i ? (this.log("Found server in query."),
        this.password = i[3],
        this.connect(i[0], i[1], i[2])) : (this.log("Pinging servers..."),
        this.pingServers())
    }
    ,
    o.prototype.parseServerQuery = function() {
        var e = n.parse(location.href, !0)
          , t = e.query.server;
        if ("string" == typeof t) {
            var i = t.split(":");
            if (3 == i.length) {
                var s = i[0]
                  , o = parseInt(i[1])
                  , a = parseInt(i[2]);
                return "0" == s || s.startsWith("vultr:") || (s = "vultr:" + s),
                [s, o, a, e.query.password]
            }
            this.errorCallback("Invalid number of server parameters in " + t)
        }
    }
    ,
    o.prototype.findServer = function(e, t) {
        var i = this.servers[e];
        if (Array.isArray(i)) {
            for (var n = 0; n < i.length; n++) {
                var s = i[n];
                if (s.index == t)
                    return s
            }
            console.warn("Could not find server in region " + e + " with index " + t + ".")
        } else
            this.errorCallback("No server list for region " + e)
    }
    ,
    o.prototype.pingServers = function() {
        var e = this
          , t = [];
        for (var i in this.servers)
            if (this.servers.hasOwnProperty(i)) {
                var n = this.servers[i]
                  , s = n[Math.floor(Math.random() * n.length)];
                null != s ? function(n, s) {
                    var o = new XMLHttpRequest;
                    o.onreadystatechange = function(n) {
                        var o = n.target;
                        if (4 == o.readyState)
                            if (200 == o.status) {
                                for (var a = 0; a < t.length; a++)
                                    t[a].abort();
                                e.log("Connecting to region", s.region);
                                var r = e.seekServer(s.region);
                                e.connect(r[0], r[1], r[2])
                            } else
                                console.warn("Error pinging " + s.ip + " in region " + i)
                    }
                    ;
                    var a = "//" + e.serverAddress(s.ip, !0) + ":" + e.serverPort(s) + "/ping";
                    o.open("GET", a, !0),
                    o.send(null),
                    e.log("Pinging", a),
                    t.push(o)
                }(0, s) : console.log("No target server for region " + i)
            }
    }
    ,
    o.prototype.seekServer = function(e, t, i) {
        null == i && (i = "random"),
        null == t && (t = !1);
        const n = ["random"];
        var s = this.lobbySize
          , o = this.lobbySpread
          , a = this.servers[e].flatMap((function(e) {
            var t = 0;
            return e.games.map((function(i) {
                var n = t++;
                return {
                    region: e.region,
                    index: e.index * e.games.length + n,
                    gameIndex: n,
                    gameCount: e.games.length,
                    playerCount: i.playerCount,
                    isPrivate: i.isPrivate
                }
            }
            ))
        }
        )).filter((function(e) {
            return !e.isPrivate
        }
        )).filter((function(e) {
            return !t || 0 == e.playerCount && e.gameIndex >= e.gameCount / 2
        }
        )).filter((function(e) {
            return "random" == i || n[e.index % n.length].key == i
        }
        )).sort((function(e, t) {
            return t.playerCount - e.playerCount
        }
        )).filter((function(e) {
            return e.playerCount < s
        }
        ));
        if (t && a.reverse(),
        0 != a.length) {
            var r = Math.min(o, a.length)
              , c = Math.floor(Math.random() * r)
              , l = a[c = Math.min(c, a.length - 1)]
              , h = l.region
              , u = (c = Math.floor(l.index / l.gameCount),
            l.index % l.gameCount);
            return this.log("Found server."),
            [h, c, u]
        }
        this.errorCallback("No open servers.")
    }
    ,
    o.prototype.connect = function(e, t, i) {
        if (!this.connected) {
            var n = this.findServer(e, t);
            null != n ? (this.log("Connecting to server", n, "with game index", i),
            n.games[i].playerCount >= this.lobbySize ? this.errorCallback("Server is already full.") : (window.history.replaceState(document.title, document.title, this.generateHref(e, t, i, this.password)),
            this.server = n,
            this.gameIndex = i,
            this.log("Calling callback with address", this.serverAddress(n.ip), "on port", this.serverPort(n), "with game index", i),
            this.callback(this.serverAddress(n.ip), this.serverPort(n), i))) : this.errorCallback("Failed to find server for region " + e + " and index " + t)
        }
    }
    ,
    o.prototype.switchServer = function(e, t, i, n) {
        this.switchingServers = !0,
        window.location.href = this.generateHref(e, t, i, n)
    }
    ,
    o.prototype.generateHref = function(e, t, i, n) {
        var s = "/?server=" + (e = this.stripRegion(e)) + ":" + t + ":" + i;
        return n && (s += "&password=" + encodeURIComponent(n)),
        s
    }
    ,
    o.prototype.serverAddress = function(e, t) {
        return "127.0.0.1" == e || "7f000001" == e || "903d62ef5d1c2fecdcaeb5e7dd485eff" == e ? window.location.hostname : this.rawIPs ? t ? "ip_" + this.hashIP(e) + "." + this.baseUrl : e : "ip_" + e + "." + this.baseUrl
    }
    ,
    o.prototype.serverPort = function(e) {
        return 0 == e.region ? this.devPort : location.protocol.startsWith("https") ? 443 : 80
    }
    ,
    o.prototype.processServers = function(e) {
        for (var t = {}, i = 0; i < e.length; i++) {
            var n = e[i]
              , s = t[n.region];
            null == s && (s = [],
            t[n.region] = s),
            s.push(n)
        }
        for (var o in t)
            t[o] = t[o].sort((function(e, t) {
                return e.index - t.index
            }
            ));
        this.servers = t
    }
    ,
    o.prototype.ipToHex = function(e) {
        return e.split(".").map(e=>("00" + parseInt(e).toString(16)).substr(-2)).join("").toLowerCase()
    }
    ,
    o.prototype.hashIP = function(e) {
        return s(this.ipToHex(e))
    }
    ,
    o.prototype.log = function() {
        return this.debugLog ? console.log.apply(void 0, arguments) : console.verbose ? console.verbose.apply(void 0, arguments) : void 0
    }
    ,
    o.prototype.stripRegion = function(e) {
        return e.startsWith("vultr:") ? e = e.slice(6) : e.startsWith("do:") && (e = e.slice(3)),
        e
    }
    ,
    window.testVultrClient = function() {
        var e = 1;
        function t(t, i) {
            (t = "" + t) == (i = "" + i) ? console.log(`Assert ${e} passed.`) : console.warn(`Assert ${e} failed. Expected ${i}, got ${t}.`),
            e++
        }
        var i = new o("test.io",-1,5,1,!1);
        i.errorCallback = function(e) {}
        ,
        i.processServers(function(e) {
            var t = [];
            for (var i in e)
                for (var n = e[i], s = 0; s < n.length; s++)
                    t.push({
                        ip: i + ":" + s,
                        scheme: "testing",
                        region: i,
                        index: s,
                        games: n[s].map(e=>({
                            playerCount: e,
                            isPrivate: !1
                        }))
                    });
            return t
        }({
            1: [[0, 0, 0, 0], [0, 0, 0, 0]],
            2: [[5, 1, 0, 0], [0, 0, 0, 0]],
            3: [[5, 0, 1, 5], [0, 0, 0, 0]],
            4: [[5, 1, 1, 5], [1, 0, 0, 0]],
            5: [[5, 1, 1, 5], [1, 0, 4, 0]],
            6: [[5, 5, 5, 5], [2, 3, 1, 4]],
            7: [[5, 5, 5, 5], [5, 5, 5, 5]]
        })),
        t(i.seekServer(1, !1), [1, 0, 0]),
        t(i.seekServer(1, !0), [1, 1, 3]),
        t(i.seekServer(2, !1), [2, 0, 1]),
        t(i.seekServer(2, !0), [2, 1, 3]),
        t(i.seekServer(3, !1), [3, 0, 2]),
        t(i.seekServer(3, !0), [3, 1, 3]),
        t(i.seekServer(4, !1), [4, 0, 1]),
        t(i.seekServer(4, !0), [4, 1, 3]),
        t(i.seekServer(5, !1), [5, 1, 2]),
        t(i.seekServer(5, !0), [5, 1, 3]),
        t(i.seekServer(6, !1), [6, 1, 3]),
        t(i.seekServer(6, !0), void 0),
        t(i.seekServer(7, !1), void 0),
        t(i.seekServer(7, !0), void 0),
        console.log("Tests passed.")
    }
    ;
    var a = function(e, t) {
        return e.concat(t)
    };
    Array.prototype.flatMap = function(e) {
        return function(e, t) {
            return t.map(e).reduce(a, [])
        }(e, this)
    }
    ,
    e.exports = o
}
, function(e, t, i) {
    "use strict";
    var n = i(25)
      , s = i(28);
    function o() {
        this.protocol = null,
        this.slashes = null,
        this.auth = null,
        this.host = null,
        this.port = null,
        this.hostname = null,
        this.hash = null,
        this.search = null,
        this.query = null,
        this.pathname = null,
        this.path = null,
        this.href = null
    }
    t.parse = w,
    t.resolve = function(e, t) {
        return w(e, !1, !0).resolve(t)
    }
    ,
    t.resolveObject = function(e, t) {
        return e ? w(e, !1, !0).resolveObject(t) : t
    }
    ,
    t.format = function(e) {
        return s.isString(e) && (e = w(e)),
        e instanceof o ? e.format() : o.prototype.format.call(e)
    }
    ,
    t.Url = o;
    var a = /^([a-z0-9.+-]+:)/i
      , r = /:[0-9]*$/
      , c = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/
      , l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"])
      , h = ["'"].concat(l)
      , u = ["%", "/", "?", ";", "#"].concat(h)
      , d = ["/", "?", "#"]
      , f = /^[+a-z0-9A-Z_-]{0,63}$/
      , p = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
      , g = {
        javascript: !0,
        "javascript:": !0
    }
      , m = {
        javascript: !0,
        "javascript:": !0
    }
      , y = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0
    }
      , k = i(29);
    function w(e, t, i) {
        if (e && s.isObject(e) && e instanceof o)
            return e;
        var n = new o;
        return n.parse(e, t, i),
        n
    }
    o.prototype.parse = function(e, t, i) {
        if (!s.isString(e))
            throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
        var o = e.indexOf("?")
          , r = -1 !== o && o < e.indexOf("#") ? "?" : "#"
          , l = e.split(r);
        l[0] = l[0].replace(/\\/g, "/");
        var w = e = l.join(r);
        if (w = w.trim(),
        !i && 1 === e.split("#").length) {
            var v = c.exec(w);
            if (v)
                return this.path = w,
                this.href = w,
                this.pathname = v[1],
                v[2] ? (this.search = v[2],
                this.query = t ? k.parse(this.search.substr(1)) : this.search.substr(1)) : t && (this.search = "",
                this.query = {}),
                this
        }
        var b = a.exec(w);
        if (b) {
            var x = (b = b[0]).toLowerCase();
            this.protocol = x,
            w = w.substr(b.length)
        }
        if (i || b || w.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var S = "//" === w.substr(0, 2);
            !S || b && m[b] || (w = w.substr(2),
            this.slashes = !0)
        }
        if (!m[b] && (S || b && !y[b])) {
            for (var I, T, M = -1, C = 0; C < d.length; C++)
                -1 !== (P = w.indexOf(d[C])) && (-1 === M || P < M) && (M = P);
            for (-1 !== (T = -1 === M ? w.lastIndexOf("@") : w.lastIndexOf("@", M)) && (I = w.slice(0, T),
            w = w.slice(T + 1),
            this.auth = decodeURIComponent(I)),
            M = -1,
            C = 0; C < u.length; C++) {
                var P;
                -1 !== (P = w.indexOf(u[C])) && (-1 === M || P < M) && (M = P)
            }
            -1 === M && (M = w.length),
            this.host = w.slice(0, M),
            w = w.slice(M),
            this.parseHost(),
            this.hostname = this.hostname || "";
            var E = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
            if (!E)
                for (var O = this.hostname.split(/\./), B = (C = 0,
                O.length); C < B; C++) {
                    var j = O[C];
                    if (j && !j.match(f)) {
                        for (var A = "", D = 0, U = j.length; D < U; D++)
                            j.charCodeAt(D) > 127 ? A += "x" : A += j[D];
                        if (!A.match(f)) {
                            var R = O.slice(0, C)
                              , L = O.slice(C + 1)
                              , z = j.match(p);
                            z && (R.push(z[1]),
                            L.unshift(z[2])),
                            L.length && (w = "/" + L.join(".") + w),
                            this.hostname = R.join(".");
                            break
                        }
                    }
                }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
            E || (this.hostname = n.toASCII(this.hostname));
            var _ = this.port ? ":" + this.port : ""
              , F = this.hostname || "";
            this.host = F + _,
            this.href += this.host,
            E && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
            "/" !== w[0] && (w = "/" + w))
        }
        if (!g[x])
            for (C = 0,
            B = h.length; C < B; C++) {
                var H = h[C];
                if (-1 !== w.indexOf(H)) {
                    var V = encodeURIComponent(H);
                    V === H && (V = escape(H)),
                    w = w.split(H).join(V)
                }
            }
        var q = w.indexOf("#");
        -1 !== q && (this.hash = w.substr(q),
        w = w.slice(0, q));
        var W = w.indexOf("?");
        if (-1 !== W ? (this.search = w.substr(W),
        this.query = w.substr(W + 1),
        t && (this.query = k.parse(this.query)),
        w = w.slice(0, W)) : t && (this.search = "",
        this.query = {}),
        w && (this.pathname = w),
        y[x] && this.hostname && !this.pathname && (this.pathname = "/"),
        this.pathname || this.search) {
            _ = this.pathname || "";
            var X = this.search || "";
            this.path = _ + X
        }
        return this.href = this.format(),
        this
    }
    ,
    o.prototype.format = function() {
        var e = this.auth || "";
        e && (e = (e = encodeURIComponent(e)).replace(/%3A/i, ":"),
        e += "@");
        var t = this.protocol || ""
          , i = this.pathname || ""
          , n = this.hash || ""
          , o = !1
          , a = "";
        this.host ? o = e + this.host : this.hostname && (o = e + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"),
        this.port && (o += ":" + this.port)),
        this.query && s.isObject(this.query) && Object.keys(this.query).length && (a = k.stringify(this.query));
        var r = this.search || a && "?" + a || "";
        return t && ":" !== t.substr(-1) && (t += ":"),
        this.slashes || (!t || y[t]) && !1 !== o ? (o = "//" + (o || ""),
        i && "/" !== i.charAt(0) && (i = "/" + i)) : o || (o = ""),
        n && "#" !== n.charAt(0) && (n = "#" + n),
        r && "?" !== r.charAt(0) && (r = "?" + r),
        t + o + (i = i.replace(/[?#]/g, (function(e) {
            return encodeURIComponent(e)
        }
        ))) + (r = r.replace("#", "%23")) + n
    }
    ,
    o.prototype.resolve = function(e) {
        return this.resolveObject(w(e, !1, !0)).format()
    }
    ,
    o.prototype.resolveObject = function(e) {
        if (s.isString(e)) {
            var t = new o;
            t.parse(e, !1, !0),
            e = t
        }
        for (var i = new o, n = Object.keys(this), a = 0; a < n.length; a++) {
            var r = n[a];
            i[r] = this[r]
        }
        if (i.hash = e.hash,
        "" === e.href)
            return i.href = i.format(),
            i;
        if (e.slashes && !e.protocol) {
            for (var c = Object.keys(e), l = 0; l < c.length; l++) {
                var h = c[l];
                "protocol" !== h && (i[h] = e[h])
            }
            return y[i.protocol] && i.hostname && !i.pathname && (i.path = i.pathname = "/"),
            i.href = i.format(),
            i
        }
        if (e.protocol && e.protocol !== i.protocol) {
            if (!y[e.protocol]) {
                for (var u = Object.keys(e), d = 0; d < u.length; d++) {
                    var f = u[d];
                    i[f] = e[f]
                }
                return i.href = i.format(),
                i
            }
            if (i.protocol = e.protocol,
            e.host || m[e.protocol])
                i.pathname = e.pathname;
            else {
                for (var p = (e.pathname || "").split("/"); p.length && !(e.host = p.shift()); )
                    ;
                e.host || (e.host = ""),
                e.hostname || (e.hostname = ""),
                "" !== p[0] && p.unshift(""),
                p.length < 2 && p.unshift(""),
                i.pathname = p.join("/")
            }
            if (i.search = e.search,
            i.query = e.query,
            i.host = e.host || "",
            i.auth = e.auth,
            i.hostname = e.hostname || e.host,
            i.port = e.port,
            i.pathname || i.search) {
                var g = i.pathname || ""
                  , k = i.search || "";
                i.path = g + k
            }
            return i.slashes = i.slashes || e.slashes,
            i.href = i.format(),
            i
        }
        var w = i.pathname && "/" === i.pathname.charAt(0)
          , v = e.host || e.pathname && "/" === e.pathname.charAt(0)
          , b = v || w || i.host && e.pathname
          , x = b
          , S = i.pathname && i.pathname.split("/") || []
          , I = (p = e.pathname && e.pathname.split("/") || [],
        i.protocol && !y[i.protocol]);
        if (I && (i.hostname = "",
        i.port = null,
        i.host && ("" === S[0] ? S[0] = i.host : S.unshift(i.host)),
        i.host = "",
        e.protocol && (e.hostname = null,
        e.port = null,
        e.host && ("" === p[0] ? p[0] = e.host : p.unshift(e.host)),
        e.host = null),
        b = b && ("" === p[0] || "" === S[0])),
        v)
            i.host = e.host || "" === e.host ? e.host : i.host,
            i.hostname = e.hostname || "" === e.hostname ? e.hostname : i.hostname,
            i.search = e.search,
            i.query = e.query,
            S = p;
        else if (p.length)
            S || (S = []),
            S.pop(),
            S = S.concat(p),
            i.search = e.search,
            i.query = e.query;
        else if (!s.isNullOrUndefined(e.search))
            return I && (i.hostname = i.host = S.shift(),
            (E = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = E.shift(),
            i.host = i.hostname = E.shift())),
            i.search = e.search,
            i.query = e.query,
            s.isNull(i.pathname) && s.isNull(i.search) || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")),
            i.href = i.format(),
            i;
        if (!S.length)
            return i.pathname = null,
            i.search ? i.path = "/" + i.search : i.path = null,
            i.href = i.format(),
            i;
        for (var T = S.slice(-1)[0], M = (i.host || e.host || S.length > 1) && ("." === T || ".." === T) || "" === T, C = 0, P = S.length; P >= 0; P--)
            "." === (T = S[P]) ? S.splice(P, 1) : ".." === T ? (S.splice(P, 1),
            C++) : C && (S.splice(P, 1),
            C--);
        if (!b && !x)
            for (; C--; C)
                S.unshift("..");
        !b || "" === S[0] || S[0] && "/" === S[0].charAt(0) || S.unshift(""),
        M && "/" !== S.join("/").substr(-1) && S.push("");
        var E, O = "" === S[0] || S[0] && "/" === S[0].charAt(0);
        return I && (i.hostname = i.host = O ? "" : S.length ? S.shift() : "",
        (E = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = E.shift(),
        i.host = i.hostname = E.shift())),
        (b = b || i.host && S.length) && !O && S.unshift(""),
        S.length ? i.pathname = S.join("/") : (i.pathname = null,
        i.path = null),
        s.isNull(i.pathname) && s.isNull(i.search) || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")),
        i.auth = e.auth || i.auth,
        i.slashes = i.slashes || e.slashes,
        i.href = i.format(),
        i
    }
    ,
    o.prototype.parseHost = function() {
        var e = this.host
          , t = r.exec(e);
        t && (":" !== (t = t[0]) && (this.port = t.substr(1)),
        e = e.substr(0, e.length - t.length)),
        e && (this.hostname = e)
    }
}
, function(e, t, i) {
    (function(e, n) {
        var s;
        /*! https://mths.be/punycode v1.4.1 by @mathias */
        !function(o) {
            t && t.nodeType,
            e && e.nodeType;
            var a = "object" == typeof n && n;
            a.global !== a && a.window !== a && a.self;
            var r, c = 2147483647, l = 36, h = /^xn--/, u = /[^\x20-\x7E]/, d = /[\x2E\u3002\uFF0E\uFF61]/g, f = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, p = Math.floor, g = String.fromCharCode;
            function m(e) {
                throw new RangeError(f[e])
            }
            function y(e, t) {
                for (var i = e.length, n = []; i--; )
                    n[i] = t(e[i]);
                return n
            }
            function k(e, t) {
                var i = e.split("@")
                  , n = "";
                return i.length > 1 && (n = i[0] + "@",
                e = i[1]),
                n + y((e = e.replace(d, ".")).split("."), t).join(".")
            }
            function w(e) {
                for (var t, i, n = [], s = 0, o = e.length; s < o; )
                    (t = e.charCodeAt(s++)) >= 55296 && t <= 56319 && s < o ? 56320 == (64512 & (i = e.charCodeAt(s++))) ? n.push(((1023 & t) << 10) + (1023 & i) + 65536) : (n.push(t),
                    s--) : n.push(t);
                return n
            }
            function v(e) {
                return y(e, (function(e) {
                    var t = "";
                    return e > 65535 && (t += g((e -= 65536) >>> 10 & 1023 | 55296),
                    e = 56320 | 1023 & e),
                    t + g(e)
                }
                )).join("")
            }
            function b(e) {
                return e - 48 < 10 ? e - 22 : e - 65 < 26 ? e - 65 : e - 97 < 26 ? e - 97 : l
            }
            function x(e, t) {
                return e + 22 + 75 * (e < 26) - ((0 != t) << 5)
            }
            function S(e, t, i) {
                var n = 0;
                for (e = i ? p(e / 700) : e >> 1,
                e += p(e / t); e > 455; n += l)
                    e = p(e / 35);
                return p(n + 36 * e / (e + 38))
            }
            function I(e) {
                var t, i, n, s, o, a, r, h, u, d, f = [], g = e.length, y = 0, k = 128, w = 72;
                for ((i = e.lastIndexOf("-")) < 0 && (i = 0),
                n = 0; n < i; ++n)
                    e.charCodeAt(n) >= 128 && m("not-basic"),
                    f.push(e.charCodeAt(n));
                for (s = i > 0 ? i + 1 : 0; s < g; ) {
                    for (o = y,
                    a = 1,
                    r = l; s >= g && m("invalid-input"),
                    ((h = b(e.charCodeAt(s++))) >= l || h > p((c - y) / a)) && m("overflow"),
                    y += h * a,
                    !(h < (u = r <= w ? 1 : r >= w + 26 ? 26 : r - w)); r += l)
                        a > p(c / (d = l - u)) && m("overflow"),
                        a *= d;
                    w = S(y - o, t = f.length + 1, 0 == o),
                    p(y / t) > c - k && m("overflow"),
                    k += p(y / t),
                    y %= t,
                    f.splice(y++, 0, k)
                }
                return v(f)
            }
            function T(e) {
                var t, i, n, s, o, a, r, h, u, d, f, y, k, v, b, I = [];
                for (y = (e = w(e)).length,
                t = 128,
                i = 0,
                o = 72,
                a = 0; a < y; ++a)
                    (f = e[a]) < 128 && I.push(g(f));
                for (n = s = I.length,
                s && I.push("-"); n < y; ) {
                    for (r = c,
                    a = 0; a < y; ++a)
                        (f = e[a]) >= t && f < r && (r = f);
                    for (r - t > p((c - i) / (k = n + 1)) && m("overflow"),
                    i += (r - t) * k,
                    t = r,
                    a = 0; a < y; ++a)
                        if ((f = e[a]) < t && ++i > c && m("overflow"),
                        f == t) {
                            for (h = i,
                            u = l; !(h < (d = u <= o ? 1 : u >= o + 26 ? 26 : u - o)); u += l)
                                b = h - d,
                                v = l - d,
                                I.push(g(x(d + b % v, 0))),
                                h = p(b / v);
                            I.push(g(x(h, 0))),
                            o = S(i, k, n == s),
                            i = 0,
                            ++n
                        }
                    ++i,
                    ++t
                }
                return I.join("")
            }
            r = {
                version: "1.4.1",
                ucs2: {
                    decode: w,
                    encode: v
                },
                decode: I,
                encode: T,
                toASCII: function(e) {
                    return k(e, (function(e) {
                        return u.test(e) ? "xn--" + T(e) : e
                    }
                    ))
                },
                toUnicode: function(e) {
                    return k(e, (function(e) {
                        return h.test(e) ? I(e.slice(4).toLowerCase()) : e
                    }
                    ))
                }
            },
            void 0 === (s = function() {
                return r
            }
            .call(t, i, t, e)) || (e.exports = s)
        }()
    }
    ).call(this, i(26)(e), i(27))
}
, function(e, t) {
    e.exports = function(e) {
        return e.webpackPolyfill || (e.deprecate = function() {}
        ,
        e.paths = [],
        e.children || (e.children = []),
        Object.defineProperty(e, "loaded", {
            enumerable: !0,
            get: function() {
                return e.l
            }
        }),
        Object.defineProperty(e, "id", {
            enumerable: !0,
            get: function() {
                return e.i
            }
        }),
        e.webpackPolyfill = 1),
        e
    }
}
, function(e, t) {
    var i;
    i = function() {
        return this
    }();
    try {
        i = i || new Function("return this")()
    } catch (e) {
        "object" == typeof window && (i = window)
    }
    e.exports = i
}
, function(e, t, i) {
    "use strict";
    e.exports = {
        isString: function(e) {
            return "string" == typeof e
        },
        isObject: function(e) {
            return "object" == typeof e && null !== e
        },
        isNull: function(e) {
            return null === e
        },
        isNullOrUndefined: function(e) {
            return null == e
        }
    }
}
, function(e, t, i) {
    "use strict";
    t.decode = t.parse = i(30),
    t.encode = t.stringify = i(31)
}
, function(e, t, i) {
    "use strict";
    function n(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    e.exports = function(e, t, i, o) {
        t = t || "&",
        i = i || "=";
        var a = {};
        if ("string" != typeof e || 0 === e.length)
            return a;
        var r = /\+/g;
        e = e.split(t);
        var c = 1e3;
        o && "number" == typeof o.maxKeys && (c = o.maxKeys);
        var l = e.length;
        c > 0 && l > c && (l = c);
        for (var h = 0; h < l; ++h) {
            var u, d, f, p, g = e[h].replace(r, "%20"), m = g.indexOf(i);
            m >= 0 ? (u = g.substr(0, m),
            d = g.substr(m + 1)) : (u = g,
            d = ""),
            f = decodeURIComponent(u),
            p = decodeURIComponent(d),
            n(a, f) ? s(a[f]) ? a[f].push(p) : a[f] = [a[f], p] : a[f] = p
        }
        return a
    }
    ;
    var s = Array.isArray || function(e) {
        return "[object Array]" === Object.prototype.toString.call(e)
    }
}
, function(e, t, i) {
    "use strict";
    var n = function(e) {
        switch (typeof e) {
        case "string":
            return e;
        case "boolean":
            return e ? "true" : "false";
        case "number":
            return isFinite(e) ? e : "";
        default:
            return ""
        }
    };
    e.exports = function(e, t, i, r) {
        return t = t || "&",
        i = i || "=",
        null === e && (e = void 0),
        "object" == typeof e ? o(a(e), (function(a) {
            var r = encodeURIComponent(n(a)) + i;
            return s(e[a]) ? o(e[a], (function(e) {
                return r + encodeURIComponent(n(e))
            }
            )).join(t) : r + encodeURIComponent(n(e[a]))
        }
        )).join(t) : r ? encodeURIComponent(n(r)) + i + encodeURIComponent(n(e)) : ""
    }
    ;
    var s = Array.isArray || function(e) {
        return "[object Array]" === Object.prototype.toString.call(e)
    }
    ;
    function o(e, t) {
        if (e.map)
            return e.map(t);
        for (var i = [], n = 0; n < e.length; n++)
            i.push(t(e[n], n));
        return i
    }
    var a = Object.keys || function(e) {
        var t = [];
        for (var i in e)
            Object.prototype.hasOwnProperty.call(e, i) && t.push(i);
        return t
    }
}
, function(e, t, i) {
    !function() {
        var t = i(33)
          , n = i(1).utf8
          , s = i(34)
          , o = i(1).bin
          , a = function(e, i) {
            e.constructor == String ? e = i && "binary" === i.encoding ? o.stringToBytes(e) : n.stringToBytes(e) : s(e) ? e = Array.prototype.slice.call(e, 0) : Array.isArray(e) || (e = e.toString());
            for (var r = t.bytesToWords(e), c = 8 * e.length, l = 1732584193, h = -271733879, u = -1732584194, d = 271733878, f = 0; f < r.length; f++)
                r[f] = 16711935 & (r[f] << 8 | r[f] >>> 24) | 4278255360 & (r[f] << 24 | r[f] >>> 8);
            r[c >>> 5] |= 128 << c % 32,
            r[14 + (c + 64 >>> 9 << 4)] = c;
            var p = a._ff
              , g = a._gg
              , m = a._hh
              , y = a._ii;
            for (f = 0; f < r.length; f += 16) {
                var k = l
                  , w = h
                  , v = u
                  , b = d;
                h = y(h = y(h = y(h = y(h = m(h = m(h = m(h = m(h = g(h = g(h = g(h = g(h = p(h = p(h = p(h = p(h, u = p(u, d = p(d, l = p(l, h, u, d, r[f + 0], 7, -680876936), h, u, r[f + 1], 12, -389564586), l, h, r[f + 2], 17, 606105819), d, l, r[f + 3], 22, -1044525330), u = p(u, d = p(d, l = p(l, h, u, d, r[f + 4], 7, -176418897), h, u, r[f + 5], 12, 1200080426), l, h, r[f + 6], 17, -1473231341), d, l, r[f + 7], 22, -45705983), u = p(u, d = p(d, l = p(l, h, u, d, r[f + 8], 7, 1770035416), h, u, r[f + 9], 12, -1958414417), l, h, r[f + 10], 17, -42063), d, l, r[f + 11], 22, -1990404162), u = p(u, d = p(d, l = p(l, h, u, d, r[f + 12], 7, 1804603682), h, u, r[f + 13], 12, -40341101), l, h, r[f + 14], 17, -1502002290), d, l, r[f + 15], 22, 1236535329), u = g(u, d = g(d, l = g(l, h, u, d, r[f + 1], 5, -165796510), h, u, r[f + 6], 9, -1069501632), l, h, r[f + 11], 14, 643717713), d, l, r[f + 0], 20, -373897302), u = g(u, d = g(d, l = g(l, h, u, d, r[f + 5], 5, -701558691), h, u, r[f + 10], 9, 38016083), l, h, r[f + 15], 14, -660478335), d, l, r[f + 4], 20, -405537848), u = g(u, d = g(d, l = g(l, h, u, d, r[f + 9], 5, 568446438), h, u, r[f + 14], 9, -1019803690), l, h, r[f + 3], 14, -187363961), d, l, r[f + 8], 20, 1163531501), u = g(u, d = g(d, l = g(l, h, u, d, r[f + 13], 5, -1444681467), h, u, r[f + 2], 9, -51403784), l, h, r[f + 7], 14, 1735328473), d, l, r[f + 12], 20, -1926607734), u = m(u, d = m(d, l = m(l, h, u, d, r[f + 5], 4, -378558), h, u, r[f + 8], 11, -2022574463), l, h, r[f + 11], 16, 1839030562), d, l, r[f + 14], 23, -35309556), u = m(u, d = m(d, l = m(l, h, u, d, r[f + 1], 4, -1530992060), h, u, r[f + 4], 11, 1272893353), l, h, r[f + 7], 16, -155497632), d, l, r[f + 10], 23, -1094730640), u = m(u, d = m(d, l = m(l, h, u, d, r[f + 13], 4, 681279174), h, u, r[f + 0], 11, -358537222), l, h, r[f + 3], 16, -722521979), d, l, r[f + 6], 23, 76029189), u = m(u, d = m(d, l = m(l, h, u, d, r[f + 9], 4, -640364487), h, u, r[f + 12], 11, -421815835), l, h, r[f + 15], 16, 530742520), d, l, r[f + 2], 23, -995338651), u = y(u, d = y(d, l = y(l, h, u, d, r[f + 0], 6, -198630844), h, u, r[f + 7], 10, 1126891415), l, h, r[f + 14], 15, -1416354905), d, l, r[f + 5], 21, -57434055), u = y(u, d = y(d, l = y(l, h, u, d, r[f + 12], 6, 1700485571), h, u, r[f + 3], 10, -1894986606), l, h, r[f + 10], 15, -1051523), d, l, r[f + 1], 21, -2054922799), u = y(u, d = y(d, l = y(l, h, u, d, r[f + 8], 6, 1873313359), h, u, r[f + 15], 10, -30611744), l, h, r[f + 6], 15, -1560198380), d, l, r[f + 13], 21, 1309151649), u = y(u, d = y(d, l = y(l, h, u, d, r[f + 4], 6, -145523070), h, u, r[f + 11], 10, -1120210379), l, h, r[f + 2], 15, 718787259), d, l, r[f + 9], 21, -343485551),
                l = l + k >>> 0,
                h = h + w >>> 0,
                u = u + v >>> 0,
                d = d + b >>> 0
            }
            return t.endian([l, h, u, d])
        };
        a._ff = function(e, t, i, n, s, o, a) {
            var r = e + (t & i | ~t & n) + (s >>> 0) + a;
            return (r << o | r >>> 32 - o) + t
        }
        ,
        a._gg = function(e, t, i, n, s, o, a) {
            var r = e + (t & n | i & ~n) + (s >>> 0) + a;
            return (r << o | r >>> 32 - o) + t
        }
        ,
        a._hh = function(e, t, i, n, s, o, a) {
            var r = e + (t ^ i ^ n) + (s >>> 0) + a;
            return (r << o | r >>> 32 - o) + t
        }
        ,
        a._ii = function(e, t, i, n, s, o, a) {
            var r = e + (i ^ (t | ~n)) + (s >>> 0) + a;
            return (r << o | r >>> 32 - o) + t
        }
        ,
        a._blocksize = 16,
        a._digestsize = 16,
        e.exports = function(e, i) {
            if (null == e)
                throw new Error("Illegal argument " + e);
            var n = t.wordsToBytes(a(e, i));
            return i && i.asBytes ? n : i && i.asString ? o.bytesToString(n) : t.bytesToHex(n)
        }
    }()
}
, function(e, t) {
    !function() {
        var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
          , i = {
            rotl: function(e, t) {
                return e << t | e >>> 32 - t
            },
            rotr: function(e, t) {
                return e << 32 - t | e >>> t
            },
            endian: function(e) {
                if (e.constructor == Number)
                    return 16711935 & i.rotl(e, 8) | 4278255360 & i.rotl(e, 24);
                for (var t = 0; t < e.length; t++)
                    e[t] = i.endian(e[t]);
                return e
            },
            randomBytes: function(e) {
                for (var t = []; e > 0; e--)
                    t.push(Math.floor(256 * Math.random()));
                return t
            },
            bytesToWords: function(e) {
                for (var t = [], i = 0, n = 0; i < e.length; i++,
                n += 8)
                    t[n >>> 5] |= e[i] << 24 - n % 32;
                return t
            },
            wordsToBytes: function(e) {
                for (var t = [], i = 0; i < 32 * e.length; i += 8)
                    t.push(e[i >>> 5] >>> 24 - i % 32 & 255);
                return t
            },
            bytesToHex: function(e) {
                for (var t = [], i = 0; i < e.length; i++)
                    t.push((e[i] >>> 4).toString(16)),
                    t.push((15 & e[i]).toString(16));
                return t.join("")
            },
            hexToBytes: function(e) {
                for (var t = [], i = 0; i < e.length; i += 2)
                    t.push(parseInt(e.substr(i, 2), 16));
                return t
            },
            bytesToBase64: function(e) {
                for (var i = [], n = 0; n < e.length; n += 3)
                    for (var s = e[n] << 16 | e[n + 1] << 8 | e[n + 2], o = 0; o < 4; o++)
                        8 * n + 6 * o <= 8 * e.length ? i.push(t.charAt(s >>> 6 * (3 - o) & 63)) : i.push("=");
                return i.join("")
            },
            base64ToBytes: function(e) {
                e = e.replace(/[^A-Z0-9+\/]/gi, "");
                for (var i = [], n = 0, s = 0; n < e.length; s = ++n % 4)
                    0 != s && i.push((t.indexOf(e.charAt(n - 1)) & Math.pow(2, -2 * s + 8) - 1) << 2 * s | t.indexOf(e.charAt(n)) >>> 6 - 2 * s);
                return i
            }
        };
        e.exports = i
    }()
}
, function(e, t) {
    function i(e) {
        return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
    }
    /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
    e.exports = function(e) {
        return null != e && (i(e) || function(e) {
            return "function" == typeof e.readFloatLE && "function" == typeof e.slice && i(e.slice(0, 0))
        }(e) || !!e._isBuffer)
    }
}
, function(e, t) {
    e.exports = function(e, t, i, n, s, o, a, r, c) {
        this.aiTypes = [{
            id: 0,
            src: "cow_1",
            killScore: 150,
            health: 500,
            weightM: .8,
            speed: 95e-5,
            turnSpeed: .001,
            scale: 72,
            drop: ["food", 50]
        }, {
            id: 1,
            src: "pig_1",
            killScore: 200,
            health: 800,
            weightM: .6,
            speed: 85e-5,
            turnSpeed: .001,
            scale: 72,
            drop: ["food", 80]
        }, {
            id: 2,
            name: "Bull",
            src: "bull_2",
            hostile: !0,
            dmg: 20,
            killScore: 1e3,
            health: 1800,
            weightM: .5,
            speed: 94e-5,
            turnSpeed: 74e-5,
            scale: 78,
            viewRange: 800,
            chargePlayer: !0,
            drop: ["food", 100]
        }, {
            id: 3,
            name: "Bully",
            src: "bull_1",
            hostile: !0,
            dmg: 20,
            killScore: 2e3,
            health: 2800,
            weightM: .45,
            speed: .001,
            turnSpeed: 8e-4,
            scale: 90,
            viewRange: 900,
            chargePlayer: !0,
            drop: ["food", 400]
        }, {
            id: 4,
            name: "Wolf",
            src: "wolf_1",
            hostile: !0,
            dmg: 8,
            killScore: 500,
            health: 300,
            weightM: .45,
            speed: .001,
            turnSpeed: .002,
            scale: 84,
            viewRange: 800,
            chargePlayer: !0,
            drop: ["food", 200]
        }, {
            id: 5,
            name: "Quack",
            src: "chicken_1",
            dmg: 8,
            killScore: 2e3,
            noTrap: !0,
            health: 300,
            weightM: .2,
            speed: .0018,
            turnSpeed: .006,
            scale: 70,
            drop: ["food", 100]
        }, {
            id: 6,
            name: "MOOSTAFA",
            nameScale: 50,
            src: "enemy",
            hostile: !0,
            dontRun: !0,
            fixedSpawn: !0,
            spawnDelay: 6e4,
            noTrap: !0,
            colDmg: 100,
            dmg: 40,
            killScore: 8e3,
            health: 18e3,
            weightM: .4,
            speed: 7e-4,
            turnSpeed: .01,
            scale: 80,
            spriteMlt: 1.8,
            leapForce: .9,
            viewRange: 1e3,
            hitRange: 210,
            hitDelay: 1e3,
            chargePlayer: !0,
            drop: ["food", 100]
        }, {
            id: 7,
            name: "Treasure",
            hostile: !0,
            nameScale: 35,
            src: "crate_1",
            fixedSpawn: !0,
            spawnDelay: 12e4,
            colDmg: 200,
            killScore: 5e3,
            health: 2e4,
            weightM: .1,
            speed: 0,
            turnSpeed: 0,
            scale: 70,
            spriteMlt: 1
        }, {
            id: 8,
            name: "MOOFIE",
            src: "wolf_2",
            hostile: !0,
            fixedSpawn: !0,
            dontRun: !0,
            hitScare: 4,
            spawnDelay: 3e4,
            noTrap: !0,
            nameScale: 35,
            dmg: 10,
            colDmg: 100,
            killScore: 3e3,
            health: 7e3,
            weightM: .45,
            speed: .0015,
            turnSpeed: .002,
            scale: 90,
            viewRange: 800,
            chargePlayer: !0,
            drop: ["food", 1e3]
        }],
        this.spawn = function(l, h, u, d) {
            for (var f, p = 0; p < e.length; ++p)
                if (!e[p].active) {
                    f = e[p];
                    break
                }
            return f || (f = new t(e.length,s,i,n,a,o,r,c),
            e.push(f)),
            f.init(l, h, u, d, this.aiTypes[d]),
            f
        }
    }
}
, function(e, t) {
    var i = 2 * Math.PI;
    e.exports = function(e, t, n, s, o, a, r, c) {
        this.sid = e,
        this.isAI = !0,
        this.nameIndex = o.randInt(0, a.cowNames.length - 1),
        this.init = function(e, t, i, n, s) {
            this.x = e,
            this.y = t,
            this.startX = s.fixedSpawn ? e : null,
            this.startY = s.fixedSpawn ? t : null,
            this.xVel = 0,
            this.yVel = 0,
            this.zIndex = 0,
            this.dir = i,
            this.dirPlus = 0,
            this.index = n,
            this.src = s.src,
            s.name && (this.name = s.name),
            this.weightM = s.weightM,
            this.speed = s.speed,
            this.killScore = s.killScore,
            this.turnSpeed = s.turnSpeed,
            this.scale = s.scale,
            this.maxHealth = s.health,
            this.leapForce = s.leapForce,
            this.health = this.maxHealth,
            this.chargePlayer = s.chargePlayer,
            this.viewRange = s.viewRange,
            this.drop = s.drop,
            this.dmg = s.dmg,
            this.hostile = s.hostile,
            this.dontRun = s.dontRun,
            this.hitRange = s.hitRange,
            this.hitDelay = s.hitDelay,
            this.hitScare = s.hitScare,
            this.spriteMlt = s.spriteMlt,
            this.nameScale = s.nameScale,
            this.colDmg = s.colDmg,
            this.noTrap = s.noTrap,
            this.spawnDelay = s.spawnDelay,
            this.hitWait = 0,
            this.waitCount = 1e3,
            this.moveCount = 0,
            this.targetDir = 0,
            this.active = !0,
            this.alive = !0,
            this.runFrom = null,
            this.chargeTarget = null,
            this.dmgOverTime = {}
        }
        ;
        var l = 0;
        this.update = function(e) {
            if (this.active) {
                if (this.spawnCounter)
                    return this.spawnCounter -= e,
                    void (this.spawnCounter <= 0 && (this.spawnCounter = 0,
                    this.x = this.startX || o.randInt(0, a.mapScale),
                    this.y = this.startY || o.randInt(0, a.mapScale)));
                (l -= e) <= 0 && (this.dmgOverTime.dmg && (this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer),
                this.dmgOverTime.time -= 1,
                this.dmgOverTime.time <= 0 && (this.dmgOverTime.dmg = 0)),
                l = 1e3);
                var s = !1
                  , r = 1;
                if (!this.zIndex && !this.lockMove && this.y >= a.mapScale / 2 - a.riverWidth / 2 && this.y <= a.mapScale / 2 + a.riverWidth / 2 && (r = .33,
                this.xVel += a.waterCurrent * e),
                this.lockMove)
                    this.xVel = 0,
                    this.yVel = 0;
                else if (this.waitCount > 0) {
                    if (this.waitCount -= e,
                    this.waitCount <= 0)
                        if (this.chargePlayer) {
                            for (var h, u, d, f = 0; f < n.length; ++f)
                                !n[f].alive || n[f].skin && n[f].skin.bullRepel || (d = o.getDistance(this.x, this.y, n[f].x, n[f].y)) <= this.viewRange && (!h || d < u) && (u = d,
                                h = n[f]);
                            h ? (this.chargeTarget = h,
                            this.moveCount = o.randInt(8e3, 12e3)) : (this.moveCount = o.randInt(1e3, 2e3),
                            this.targetDir = o.randFloat(-Math.PI, Math.PI))
                        } else
                            this.moveCount = o.randInt(4e3, 1e4),
                            this.targetDir = o.randFloat(-Math.PI, Math.PI)
                } else if (this.moveCount > 0) {
                    var p = this.speed * r;
                    if (this.runFrom && this.runFrom.active && (!this.runFrom.isPlayer || this.runFrom.alive) ? (this.targetDir = o.getDirection(this.x, this.y, this.runFrom.x, this.runFrom.y),
                    p *= 1.42) : this.chargeTarget && this.chargeTarget.alive && (this.targetDir = o.getDirection(this.chargeTarget.x, this.chargeTarget.y, this.x, this.y),
                    p *= 1.75,
                    s = !0),
                    this.hitWait && (p *= .3),
                    this.dir != this.targetDir) {
                        this.dir %= i;
                        var g = (this.dir - this.targetDir + i) % i
                          , m = Math.min(Math.abs(g - i), g, this.turnSpeed * e)
                          , y = g - Math.PI >= 0 ? 1 : -1;
                        this.dir += y * m + i
                    }
                    this.dir %= i,
                    this.xVel += p * e * Math.cos(this.dir),
                    this.yVel += p * e * Math.sin(this.dir),
                    this.moveCount -= e,
                    this.moveCount <= 0 && (this.runFrom = null,
                    this.chargeTarget = null,
                    this.waitCount = this.hostile ? 1500 : o.randInt(1500, 6e3))
                }
                this.zIndex = 0,
                this.lockMove = !1;
                var k = o.getDistance(0, 0, this.xVel * e, this.yVel * e)
                  , w = Math.min(4, Math.max(1, Math.round(k / 40)))
                  , v = 1 / w;
                for (f = 0; f < w; ++f) {
                    this.xVel && (this.x += this.xVel * e * v),
                    this.yVel && (this.y += this.yVel * e * v),
                    C = t.getGridArrays(this.x, this.y, this.scale);
                    for (var b = 0; b < C.length; ++b)
                        for (var x = 0; x < C[b].length; ++x)
                            C[b][x].active && t.checkCollision(this, C[b][x], v)
                }
                var S, I, T, M = !1;
                if (this.hitWait > 0 && (this.hitWait -= e,
                this.hitWait <= 0)) {
                    M = !0,
                    this.hitWait = 0,
                    this.leapForce && !o.randInt(0, 2) && (this.xVel += this.leapForce * Math.cos(this.dir),
                    this.yVel += this.leapForce * Math.sin(this.dir));
                    for (var C = t.getGridArrays(this.x, this.y, this.hitRange), P = 0; P < C.length; ++P)
                        for (b = 0; b < C[P].length; ++b)
                            (S = C[P][b]).health && (I = o.getDistance(this.x, this.y, S.x, S.y)) < S.scale + this.hitRange && (S.changeHealth(5 * -this.dmg) && t.disableObj(S),
                            t.hitObj(S, o.getDirection(this.x, this.y, S.x, S.y)));
                    for (b = 0; b < n.length; ++b)
                        n[b].canSee(this) && c.send(n[b].id, "aa", this.sid)
                }
                if (s || M)
                    for (f = 0; f < n.length; ++f)
                        (S = n[f]) && S.alive && (I = o.getDistance(this.x, this.y, S.x, S.y),
                        this.hitRange ? !this.hitWait && I <= this.hitRange + S.scale && (M ? (T = o.getDirection(S.x, S.y, this.x, this.y),
                        S.changeHealth(-this.dmg),
                        S.xVel += .6 * Math.cos(T),
                        S.yVel += .6 * Math.sin(T),
                        this.runFrom = null,
                        this.chargeTarget = null,
                        this.waitCount = 3e3,
                        this.hitWait = o.randInt(0, 2) ? 0 : 600) : this.hitWait = this.hitDelay) : I <= this.scale + S.scale && (T = o.getDirection(S.x, S.y, this.x, this.y),
                        S.changeHealth(-this.dmg),
                        S.xVel += .55 * Math.cos(T),
                        S.yVel += .55 * Math.sin(T)));
                this.xVel && (this.xVel *= Math.pow(a.playerDecel, e)),
                this.yVel && (this.yVel *= Math.pow(a.playerDecel, e));
                var E = this.scale;
                this.x - E < 0 ? (this.x = E,
                this.xVel = 0) : this.x + E > a.mapScale && (this.x = a.mapScale - E,
                this.xVel = 0),
                this.y - E < 0 ? (this.y = E,
                this.yVel = 0) : this.y + E > a.mapScale && (this.y = a.mapScale - E,
                this.yVel = 0)
            }
        }
        ,
        this.canSee = function(e) {
            if (!e)
                return !1;
            if (e.skin && e.skin.invisTimer && e.noMovTimer >= e.skin.invisTimer)
                return !1;
            var t = Math.abs(e.x - this.x) - e.scale
              , i = Math.abs(e.y - this.y) - e.scale;
            return t <= a.maxScreenWidth / 2 * 1.3 && i <= a.maxScreenHeight / 2 * 1.3
        }
        ;
        var h = 0
          , u = 0;
        this.animate = function(e) {
            this.animTime > 0 && (this.animTime -= e,
            this.animTime <= 0 ? (this.animTime = 0,
            this.dirPlus = 0,
            h = 0,
            u = 0) : 0 == u ? (h += e / (this.animSpeed * a.hitReturnRatio),
            this.dirPlus = o.lerp(0, this.targetAngle, Math.min(1, h)),
            h >= 1 && (h = 1,
            u = 1)) : (h -= e / (this.animSpeed * (1 - a.hitReturnRatio)),
            this.dirPlus = o.lerp(0, this.targetAngle, Math.max(0, h))))
        }
        ,
        this.startAnim = function() {
            this.animTime = this.animSpeed = 600,
            this.targetAngle = .8 * Math.PI,
            h = 0,
            u = 0
        }
        ,
        this.changeHealth = function(e, t, i) {
            if (this.active && (this.health += e,
            i && (this.hitScare && !o.randInt(0, this.hitScare) ? (this.runFrom = i,
            this.waitCount = 0,
            this.moveCount = 2e3) : this.hostile && this.chargePlayer && i.isPlayer ? (this.chargeTarget = i,
            this.waitCount = 0,
            this.moveCount = 8e3) : this.dontRun || (this.runFrom = i,
            this.waitCount = 0,
            this.moveCount = 2e3)),
            e < 0 && this.hitRange && o.randInt(0, 1) && (this.hitWait = 500),
            t && t.canSee(this) && e < 0 && c.send(t.id, "t", Math.round(this.x), Math.round(this.y), Math.round(-e), 1),
            this.health <= 0 && (this.spawnDelay ? (this.spawnCounter = this.spawnDelay,
            this.x = -1e6,
            this.y = -1e6) : (this.x = this.startX || o.randInt(0, a.mapScale),
            this.y = this.startY || o.randInt(0, a.mapScale)),
            this.health = this.maxHealth,
            this.runFrom = null,
            t && (r(t, this.killScore),
            this.drop))))
                for (var n = 0; n < this.drop.length; )
                    t.addResource(a.resourceTypes.indexOf(this.drop[n]), this.drop[n + 1]),
                    n += 2
        }
    }
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n, s, o, a = 4294967295;
    function r(e, t, i) {
        var n = Math.floor(i / 4294967296)
          , s = i;
        e.setUint32(t, n),
        e.setUint32(t + 4, s)
    }
    function c(e, t) {
        return 4294967296 * e.getInt32(t) + e.getUint32(t + 4)
    }
    var l = ("undefined" == typeof process || "never" !== (null === (n = null === process || void 0 === process ? void 0 : process.env) || void 0 === n ? void 0 : n.TEXT_ENCODING)) && "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder;
    function h(e) {
        for (var t = e.length, i = 0, n = 0; n < t; ) {
            var s = e.charCodeAt(n++);
            if (0 != (4294967168 & s))
                if (0 == (4294965248 & s))
                    i += 2;
                else {
                    if (s >= 55296 && s <= 56319 && n < t) {
                        var o = e.charCodeAt(n);
                        56320 == (64512 & o) && (++n,
                        s = ((1023 & s) << 10) + (1023 & o) + 65536)
                    }
                    i += 0 == (4294901760 & s) ? 3 : 4
                }
            else
                i++
        }
        return i
    }
    var u = l ? new TextEncoder : void 0
      , d = l ? "undefined" != typeof process && "force" !== (null === (s = null === process || void 0 === process ? void 0 : process.env) || void 0 === s ? void 0 : s.TEXT_ENCODING) ? 200 : 0 : a
      , f = (null == u ? void 0 : u.encodeInto) ? function(e, t, i) {
        u.encodeInto(e, t.subarray(i))
    }
    : function(e, t, i) {
        t.set(u.encode(e), i)
    }
    ;
    function p(e, t, i) {
        for (var n = t, s = n + i, o = [], a = ""; n < s; ) {
            var r = e[n++];
            if (0 == (128 & r))
                o.push(r);
            else if (192 == (224 & r)) {
                var c = 63 & e[n++];
                o.push((31 & r) << 6 | c)
            } else if (224 == (240 & r)) {
                c = 63 & e[n++];
                var l = 63 & e[n++];
                o.push((31 & r) << 12 | c << 6 | l)
            } else if (240 == (248 & r)) {
                var h = (7 & r) << 18 | (c = 63 & e[n++]) << 12 | (l = 63 & e[n++]) << 6 | 63 & e[n++];
                h > 65535 && (h -= 65536,
                o.push(h >>> 10 & 1023 | 55296),
                h = 56320 | 1023 & h),
                o.push(h)
            } else
                o.push(r);
            o.length >= 4096 && (a += String.fromCharCode.apply(String, o),
            o.length = 0)
        }
        return o.length > 0 && (a += String.fromCharCode.apply(String, o)),
        a
    }
    var g = l ? new TextDecoder : null
      , m = l ? "undefined" != typeof process && "force" !== (null === (o = null === process || void 0 === process ? void 0 : process.env) || void 0 === o ? void 0 : o.TEXT_DECODER) ? 200 : 0 : a
      , y = function(e, t) {
        this.type = e,
        this.data = t
    }
      , k = function() {
        var e = function(t, i) {
            return (e = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(e, t) {
                e.__proto__ = t
            }
            || function(e, t) {
                for (var i in t)
                    Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
            }
            )(t, i)
        };
        return function(t, i) {
            if ("function" != typeof i && null !== i)
                throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
            function n() {
                this.constructor = t
            }
            e(t, i),
            t.prototype = null === i ? Object.create(i) : (n.prototype = i.prototype,
            new n)
        }
    }()
      , w = function(e) {
        function t(i) {
            var n = e.call(this, i) || this
              , s = Object.create(t.prototype);
            return Object.setPrototypeOf(n, s),
            Object.defineProperty(n, "name", {
                configurable: !0,
                enumerable: !1,
                value: t.name
            }),
            n
        }
        return k(t, e),
        t
    }(Error);
    function v(e) {
        var t, i = e.sec, n = e.nsec;
        if (i >= 0 && n >= 0 && i <= 17179869183) {
            if (0 === n && i <= 4294967295) {
                var s = new Uint8Array(4);
                return (t = new DataView(s.buffer)).setUint32(0, i),
                s
            }
            var o = i / 4294967296
              , a = 4294967295 & i;
            return s = new Uint8Array(8),
            (t = new DataView(s.buffer)).setUint32(0, n << 2 | 3 & o),
            t.setUint32(4, a),
            s
        }
        return s = new Uint8Array(12),
        (t = new DataView(s.buffer)).setUint32(0, n),
        r(t, 4, i),
        s
    }
    function b(e) {
        var t = e.getTime()
          , i = Math.floor(t / 1e3)
          , n = 1e6 * (t - 1e3 * i)
          , s = Math.floor(n / 1e9);
        return {
            sec: i + s,
            nsec: n - 1e9 * s
        }
    }
    function x(e) {
        return e instanceof Date ? v(b(e)) : null
    }
    function S(e) {
        var t = new DataView(e.buffer,e.byteOffset,e.byteLength);
        switch (e.byteLength) {
        case 4:
            return {
                sec: t.getUint32(0),
                nsec: 0
            };
        case 8:
            var i = t.getUint32(0);
            return {
                sec: 4294967296 * (3 & i) + t.getUint32(4),
                nsec: i >>> 2
            };
        case 12:
            return {
                sec: c(t, 4),
                nsec: t.getUint32(0)
            };
        default:
            throw new w("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(e.length))
        }
    }
    function I(e) {
        var t = S(e);
        return new Date(1e3 * t.sec + t.nsec / 1e6)
    }
    var T = {
        type: -1,
        encode: x,
        decode: I
    }
      , M = function() {
        function e() {
            this.builtInEncoders = [],
            this.builtInDecoders = [],
            this.encoders = [],
            this.decoders = [],
            this.register(T)
        }
        return e.prototype.register = function(e) {
            var t = e.type
              , i = e.encode
              , n = e.decode;
            if (t >= 0)
                this.encoders[t] = i,
                this.decoders[t] = n;
            else {
                var s = 1 + t;
                this.builtInEncoders[s] = i,
                this.builtInDecoders[s] = n
            }
        }
        ,
        e.prototype.tryToEncode = function(e, t) {
            for (var i = 0; i < this.builtInEncoders.length; i++)
                if (null != (n = this.builtInEncoders[i]) && null != (s = n(e, t)))
                    return new y(-1 - i,s);
            for (i = 0; i < this.encoders.length; i++) {
                var n, s;
                if (null != (n = this.encoders[i]) && null != (s = n(e, t)))
                    return new y(i,s)
            }
            return e instanceof y ? e : null
        }
        ,
        e.prototype.decode = function(e, t, i) {
            var n = t < 0 ? this.builtInDecoders[-1 - t] : this.decoders[t];
            return n ? n(e, t, i) : new y(t,e)
        }
        ,
        e.defaultCodec = new e,
        e
    }();
    function C(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : e instanceof ArrayBuffer ? new Uint8Array(e) : Uint8Array.from(e)
    }
    var P = function() {
        function e(e, t, i, n, s, o, a, r) {
            void 0 === e && (e = M.defaultCodec),
            void 0 === t && (t = void 0),
            void 0 === i && (i = 100),
            void 0 === n && (n = 2048),
            void 0 === s && (s = !1),
            void 0 === o && (o = !1),
            void 0 === a && (a = !1),
            void 0 === r && (r = !1),
            this.extensionCodec = e,
            this.context = t,
            this.maxDepth = i,
            this.initialBufferSize = n,
            this.sortKeys = s,
            this.forceFloat32 = o,
            this.ignoreUndefined = a,
            this.forceIntegerToFloat = r,
            this.pos = 0,
            this.view = new DataView(new ArrayBuffer(this.initialBufferSize)),
            this.bytes = new Uint8Array(this.view.buffer)
        }
        return e.prototype.reinitializeState = function() {
            this.pos = 0
        }
        ,
        e.prototype.encodeSharedRef = function(e) {
            return this.reinitializeState(),
            this.doEncode(e, 1),
            this.bytes.subarray(0, this.pos)
        }
        ,
        e.prototype.encode = function(e) {
            return this.reinitializeState(),
            this.doEncode(e, 1),
            this.bytes.slice(0, this.pos)
        }
        ,
        e.prototype.doEncode = function(e, t) {
            if (t > this.maxDepth)
                throw new Error("Too deep objects in depth ".concat(t));
            null == e ? this.encodeNil() : "boolean" == typeof e ? this.encodeBoolean(e) : "number" == typeof e ? this.encodeNumber(e) : "string" == typeof e ? this.encodeString(e) : this.encodeObject(e, t)
        }
        ,
        e.prototype.ensureBufferSizeToWrite = function(e) {
            var t = this.pos + e;
            this.view.byteLength < t && this.resizeBuffer(2 * t)
        }
        ,
        e.prototype.resizeBuffer = function(e) {
            var t = new ArrayBuffer(e)
              , i = new Uint8Array(t)
              , n = new DataView(t);
            i.set(this.bytes),
            this.view = n,
            this.bytes = i
        }
        ,
        e.prototype.encodeNil = function() {
            this.writeU8(192)
        }
        ,
        e.prototype.encodeBoolean = function(e) {
            !1 === e ? this.writeU8(194) : this.writeU8(195)
        }
        ,
        e.prototype.encodeNumber = function(e) {
            Number.isSafeInteger(e) && !this.forceIntegerToFloat ? e >= 0 ? e < 128 ? this.writeU8(e) : e < 256 ? (this.writeU8(204),
            this.writeU8(e)) : e < 65536 ? (this.writeU8(205),
            this.writeU16(e)) : e < 4294967296 ? (this.writeU8(206),
            this.writeU32(e)) : (this.writeU8(207),
            this.writeU64(e)) : e >= -32 ? this.writeU8(224 | e + 32) : e >= -128 ? (this.writeU8(208),
            this.writeI8(e)) : e >= -32768 ? (this.writeU8(209),
            this.writeI16(e)) : e >= -2147483648 ? (this.writeU8(210),
            this.writeI32(e)) : (this.writeU8(211),
            this.writeI64(e)) : this.forceFloat32 ? (this.writeU8(202),
            this.writeF32(e)) : (this.writeU8(203),
            this.writeF64(e))
        }
        ,
        e.prototype.writeStringHeader = function(e) {
            if (e < 32)
                this.writeU8(160 + e);
            else if (e < 256)
                this.writeU8(217),
                this.writeU8(e);
            else if (e < 65536)
                this.writeU8(218),
                this.writeU16(e);
            else {
                if (!(e < 4294967296))
                    throw new Error("Too long string: ".concat(e, " bytes in UTF-8"));
                this.writeU8(219),
                this.writeU32(e)
            }
        }
        ,
        e.prototype.encodeString = function(e) {
            if (e.length > d) {
                var t = h(e);
                this.ensureBufferSizeToWrite(5 + t),
                this.writeStringHeader(t),
                f(e, this.bytes, this.pos),
                this.pos += t
            } else
                t = h(e),
                this.ensureBufferSizeToWrite(5 + t),
                this.writeStringHeader(t),
                function(e, t, i) {
                    for (var n = e.length, s = i, o = 0; o < n; ) {
                        var a = e.charCodeAt(o++);
                        if (0 != (4294967168 & a)) {
                            if (0 == (4294965248 & a))
                                t[s++] = a >> 6 & 31 | 192;
                            else {
                                if (a >= 55296 && a <= 56319 && o < n) {
                                    var r = e.charCodeAt(o);
                                    56320 == (64512 & r) && (++o,
                                    a = ((1023 & a) << 10) + (1023 & r) + 65536)
                                }
                                0 == (4294901760 & a) ? (t[s++] = a >> 12 & 15 | 224,
                                t[s++] = a >> 6 & 63 | 128) : (t[s++] = a >> 18 & 7 | 240,
                                t[s++] = a >> 12 & 63 | 128,
                                t[s++] = a >> 6 & 63 | 128)
                            }
                            t[s++] = 63 & a | 128
                        } else
                            t[s++] = a
                    }
                }(e, this.bytes, this.pos),
                this.pos += t
        }
        ,
        e.prototype.encodeObject = function(e, t) {
            var i = this.extensionCodec.tryToEncode(e, this.context);
            if (null != i)
                this.encodeExtension(i);
            else if (Array.isArray(e))
                this.encodeArray(e, t);
            else if (ArrayBuffer.isView(e))
                this.encodeBinary(e);
            else {
                if ("object" != typeof e)
                    throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(e)));
                this.encodeMap(e, t)
            }
        }
        ,
        e.prototype.encodeBinary = function(e) {
            var t = e.byteLength;
            if (t < 256)
                this.writeU8(196),
                this.writeU8(t);
            else if (t < 65536)
                this.writeU8(197),
                this.writeU16(t);
            else {
                if (!(t < 4294967296))
                    throw new Error("Too large binary: ".concat(t));
                this.writeU8(198),
                this.writeU32(t)
            }
            var i = C(e);
            this.writeU8a(i)
        }
        ,
        e.prototype.encodeArray = function(e, t) {
            var i = e.length;
            if (i < 16)
                this.writeU8(144 + i);
            else if (i < 65536)
                this.writeU8(220),
                this.writeU16(i);
            else {
                if (!(i < 4294967296))
                    throw new Error("Too large array: ".concat(i));
                this.writeU8(221),
                this.writeU32(i)
            }
            for (var n = 0, s = e; n < s.length; n++) {
                var o = s[n];
                this.doEncode(o, t + 1)
            }
        }
        ,
        e.prototype.countWithoutUndefined = function(e, t) {
            for (var i = 0, n = 0, s = t; n < s.length; n++)
                void 0 !== e[s[n]] && i++;
            return i
        }
        ,
        e.prototype.encodeMap = function(e, t) {
            var i = Object.keys(e);
            this.sortKeys && i.sort();
            var n = this.ignoreUndefined ? this.countWithoutUndefined(e, i) : i.length;
            if (n < 16)
                this.writeU8(128 + n);
            else if (n < 65536)
                this.writeU8(222),
                this.writeU16(n);
            else {
                if (!(n < 4294967296))
                    throw new Error("Too large map object: ".concat(n));
                this.writeU8(223),
                this.writeU32(n)
            }
            for (var s = 0, o = i; s < o.length; s++) {
                var a = o[s]
                  , r = e[a];
                this.ignoreUndefined && void 0 === r || (this.encodeString(a),
                this.doEncode(r, t + 1))
            }
        }
        ,
        e.prototype.encodeExtension = function(e) {
            var t = e.data.length;
            if (1 === t)
                this.writeU8(212);
            else if (2 === t)
                this.writeU8(213);
            else if (4 === t)
                this.writeU8(214);
            else if (8 === t)
                this.writeU8(215);
            else if (16 === t)
                this.writeU8(216);
            else if (t < 256)
                this.writeU8(199),
                this.writeU8(t);
            else if (t < 65536)
                this.writeU8(200),
                this.writeU16(t);
            else {
                if (!(t < 4294967296))
                    throw new Error("Too large extension object: ".concat(t));
                this.writeU8(201),
                this.writeU32(t)
            }
            this.writeI8(e.type),
            this.writeU8a(e.data)
        }
        ,
        e.prototype.writeU8 = function(e) {
            this.ensureBufferSizeToWrite(1),
            this.view.setUint8(this.pos, e),
            this.pos++
        }
        ,
        e.prototype.writeU8a = function(e) {
            var t = e.length;
            this.ensureBufferSizeToWrite(t),
            this.bytes.set(e, this.pos),
            this.pos += t
        }
        ,
        e.prototype.writeI8 = function(e) {
            this.ensureBufferSizeToWrite(1),
            this.view.setInt8(this.pos, e),
            this.pos++
        }
        ,
        e.prototype.writeU16 = function(e) {
            this.ensureBufferSizeToWrite(2),
            this.view.setUint16(this.pos, e),
            this.pos += 2
        }
        ,
        e.prototype.writeI16 = function(e) {
            this.ensureBufferSizeToWrite(2),
            this.view.setInt16(this.pos, e),
            this.pos += 2
        }
        ,
        e.prototype.writeU32 = function(e) {
            this.ensureBufferSizeToWrite(4),
            this.view.setUint32(this.pos, e),
            this.pos += 4
        }
        ,
        e.prototype.writeI32 = function(e) {
            this.ensureBufferSizeToWrite(4),
            this.view.setInt32(this.pos, e),
            this.pos += 4
        }
        ,
        e.prototype.writeF32 = function(e) {
            this.ensureBufferSizeToWrite(4),
            this.view.setFloat32(this.pos, e),
            this.pos += 4
        }
        ,
        e.prototype.writeF64 = function(e) {
            this.ensureBufferSizeToWrite(8),
            this.view.setFloat64(this.pos, e),
            this.pos += 8
        }
        ,
        e.prototype.writeU64 = function(e) {
            this.ensureBufferSizeToWrite(8),
            function(e, t, i) {
                var n = i / 4294967296
                  , s = i;
                e.setUint32(t, n),
                e.setUint32(t + 4, s)
            }(this.view, this.pos, e),
            this.pos += 8
        }
        ,
        e.prototype.writeI64 = function(e) {
            this.ensureBufferSizeToWrite(8),
            r(this.view, this.pos, e),
            this.pos += 8
        }
        ,
        e
    }()
      , E = {};
    function O(e, t) {
        return void 0 === t && (t = E),
        new P(t.extensionCodec,t.context,t.maxDepth,t.initialBufferSize,t.sortKeys,t.forceFloat32,t.ignoreUndefined,t.forceIntegerToFloat).encodeSharedRef(e)
    }
    function B(e) {
        return "".concat(e < 0 ? "-" : "", "0x").concat(Math.abs(e).toString(16).padStart(2, "0"))
    }
    var j = function() {
        function e(e, t) {
            void 0 === e && (e = 16),
            void 0 === t && (t = 16),
            this.maxKeyLength = e,
            this.maxLengthPerKey = t,
            this.hit = 0,
            this.miss = 0,
            this.caches = [];
            for (var i = 0; i < this.maxKeyLength; i++)
                this.caches.push([])
        }
        return e.prototype.canBeCached = function(e) {
            return e > 0 && e <= this.maxKeyLength
        }
        ,
        e.prototype.find = function(e, t, i) {
            e: for (var n = 0, s = this.caches[i - 1]; n < s.length; n++) {
                for (var o = s[n], a = o.bytes, r = 0; r < i; r++)
                    if (a[r] !== e[t + r])
                        continue e;
                return o.str
            }
            return null
        }
        ,
        e.prototype.store = function(e, t) {
            var i = this.caches[e.length - 1]
              , n = {
                bytes: e,
                str: t
            };
            i.length >= this.maxLengthPerKey ? i[Math.random() * i.length | 0] = n : i.push(n)
        }
        ,
        e.prototype.decode = function(e, t, i) {
            var n = this.find(e, t, i);
            if (null != n)
                return this.hit++,
                n;
            this.miss++;
            var s = p(e, t, i)
              , o = Uint8Array.prototype.slice.call(e, t, t + i);
            return this.store(o, s),
            s
        }
        ,
        e
    }()
      , A = function(e, t) {
        var i, n, s, o, a = {
            label: 0,
            sent: function() {
                if (1 & s[0])
                    throw s[1];
                return s[1]
            },
            trys: [],
            ops: []
        };
        return o = {
            next: r(0),
            throw: r(1),
            return: r(2)
        },
        "function" == typeof Symbol && (o[Symbol.iterator] = function() {
            return this
        }
        ),
        o;
        function r(o) {
            return function(r) {
                return function(o) {
                    if (i)
                        throw new TypeError("Generator is already executing.");
                    for (; a; )
                        try {
                            if (i = 1,
                            n && (s = 2 & o[0] ? n.return : o[0] ? n.throw || ((s = n.return) && s.call(n),
                            0) : n.next) && !(s = s.call(n, o[1])).done)
                                return s;
                            switch (n = 0,
                            s && (o = [2 & o[0], s.value]),
                            o[0]) {
                            case 0:
                            case 1:
                                s = o;
                                break;
                            case 4:
                                return a.label++,
                                {
                                    value: o[1],
                                    done: !1
                                };
                            case 5:
                                a.label++,
                                n = o[1],
                                o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(),
                                a.trys.pop();
                                continue;
                            default:
                                if (!(s = (s = a.trys).length > 0 && s[s.length - 1]) && (6 === o[0] || 2 === o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!s || o[1] > s[0] && o[1] < s[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < s[1]) {
                                    a.label = s[1],
                                    s = o;
                                    break
                                }
                                if (s && a.label < s[2]) {
                                    a.label = s[2],
                                    a.ops.push(o);
                                    break
                                }
                                s[2] && a.ops.pop(),
                                a.trys.pop();
                                continue
                            }
                            o = t.call(e, a)
                        } catch (e) {
                            o = [6, e],
                            n = 0
                        } finally {
                            i = s = 0
                        }
                    if (5 & o[0])
                        throw o[1];
                    return {
                        value: o[0] ? o[1] : void 0,
                        done: !0
                    }
                }([o, r])
            }
        }
    }
      , D = function(e) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var t, i = e[Symbol.asyncIterator];
        return i ? i.call(e) : (e = "function" == typeof __values ? __values(e) : e[Symbol.iterator](),
        t = {},
        n("next"),
        n("throw"),
        n("return"),
        t[Symbol.asyncIterator] = function() {
            return this
        }
        ,
        t);
        function n(i) {
            t[i] = e[i] && function(t) {
                return new Promise((function(n, s) {
                    !function(e, t, i, n) {
                        Promise.resolve(n).then((function(t) {
                            e({
                                value: t,
                                done: i
                            })
                        }
                        ), t)
                    }(n, s, (t = e[i](t)).done, t.value)
                }
                ))
            }
        }
    }
      , U = function(e) {
        return this instanceof U ? (this.v = e,
        this) : new U(e)
    }
      , R = function(e, t, i) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var n, s = i.apply(e, t || []), o = [];
        return n = {},
        a("next"),
        a("throw"),
        a("return"),
        n[Symbol.asyncIterator] = function() {
            return this
        }
        ,
        n;
        function a(e) {
            s[e] && (n[e] = function(t) {
                return new Promise((function(i, n) {
                    o.push([e, t, i, n]) > 1 || r(e, t)
                }
                ))
            }
            )
        }
        function r(e, t) {
            try {
                !function(e) {
                    e.value instanceof U ? Promise.resolve(e.value.v).then(c, l) : h(o[0][2], e)
                }(s[e](t))
            } catch (e) {
                h(o[0][3], e)
            }
        }
        function c(e) {
            r("next", e)
        }
        function l(e) {
            r("throw", e)
        }
        function h(e, t) {
            e(t),
            o.shift(),
            o.length && r(o[0][0], o[0][1])
        }
    }
      , L = function(e) {
        var t = typeof e;
        return "string" === t || "number" === t
    }
      , z = new DataView(new ArrayBuffer(0))
      , _ = new Uint8Array(z.buffer)
      , F = function() {
        try {
            z.getInt8(0)
        } catch (e) {
            return e.constructor
        }
        throw new Error("never reached")
    }()
      , H = new F("Insufficient data")
      , V = new j
      , q = function() {
        function e(e, t, i, n, s, o, r, c) {
            void 0 === e && (e = M.defaultCodec),
            void 0 === t && (t = void 0),
            void 0 === i && (i = a),
            void 0 === n && (n = a),
            void 0 === s && (s = a),
            void 0 === o && (o = a),
            void 0 === r && (r = a),
            void 0 === c && (c = V),
            this.extensionCodec = e,
            this.context = t,
            this.maxStrLength = i,
            this.maxBinLength = n,
            this.maxArrayLength = s,
            this.maxMapLength = o,
            this.maxExtLength = r,
            this.keyDecoder = c,
            this.totalPos = 0,
            this.pos = 0,
            this.view = z,
            this.bytes = _,
            this.headByte = -1,
            this.stack = []
        }
        return e.prototype.reinitializeState = function() {
            this.totalPos = 0,
            this.headByte = -1,
            this.stack.length = 0
        }
        ,
        e.prototype.setBuffer = function(e) {
            this.bytes = C(e),
            this.view = function(e) {
                if (e instanceof ArrayBuffer)
                    return new DataView(e);
                var t = C(e);
                return new DataView(t.buffer,t.byteOffset,t.byteLength)
            }(this.bytes),
            this.pos = 0
        }
        ,
        e.prototype.appendBuffer = function(e) {
            if (-1 !== this.headByte || this.hasRemaining(1)) {
                var t = this.bytes.subarray(this.pos)
                  , i = C(e)
                  , n = new Uint8Array(t.length + i.length);
                n.set(t),
                n.set(i, t.length),
                this.setBuffer(n)
            } else
                this.setBuffer(e)
        }
        ,
        e.prototype.hasRemaining = function(e) {
            return this.view.byteLength - this.pos >= e
        }
        ,
        e.prototype.createExtraByteError = function(e) {
            var t = this.view
              , i = this.pos;
            return new RangeError("Extra ".concat(t.byteLength - i, " of ").concat(t.byteLength, " byte(s) found at buffer[").concat(e, "]"))
        }
        ,
        e.prototype.decode = function(e) {
            this.reinitializeState(),
            this.setBuffer(e);
            var t = this.doDecodeSync();
            if (this.hasRemaining(1))
                throw this.createExtraByteError(this.pos);
            return t
        }
        ,
        e.prototype.decodeMulti = function(e) {
            return A(this, (function(t) {
                switch (t.label) {
                case 0:
                    this.reinitializeState(),
                    this.setBuffer(e),
                    t.label = 1;
                case 1:
                    return this.hasRemaining(1) ? [4, this.doDecodeSync()] : [3, 3];
                case 2:
                    return t.sent(),
                    [3, 1];
                case 3:
                    return [2]
                }
            }
            ))
        }
        ,
        e.prototype.decodeAsync = function(e) {
            var t, i, n, s;
            return function(e, t, i, n) {
                return new (i || (i = Promise))((function(s, o) {
                    function a(e) {
                        try {
                            c(n.next(e))
                        } catch (e) {
                            o(e)
                        }
                    }
                    function r(e) {
                        try {
                            c(n.throw(e))
                        } catch (e) {
                            o(e)
                        }
                    }
                    function c(e) {
                        e.done ? s(e.value) : function(e) {
                            return e instanceof i ? e : new i((function(t) {
                                t(e)
                            }
                            ))
                        }(e.value).then(a, r)
                    }
                    c((n = n.apply(e, t || [])).next())
                }
                ))
            }(this, void 0, void 0, (function() {
                var o, a, r, c, l, h, u, d;
                return A(this, (function(f) {
                    switch (f.label) {
                    case 0:
                        o = !1,
                        f.label = 1;
                    case 1:
                        f.trys.push([1, 6, 7, 12]),
                        t = D(e),
                        f.label = 2;
                    case 2:
                        return [4, t.next()];
                    case 3:
                        if ((i = f.sent()).done)
                            return [3, 5];
                        if (r = i.value,
                        o)
                            throw this.createExtraByteError(this.totalPos);
                        this.appendBuffer(r);
                        try {
                            a = this.doDecodeSync(),
                            o = !0
                        } catch (e) {
                            if (!(e instanceof F))
                                throw e
                        }
                        this.totalPos += this.pos,
                        f.label = 4;
                    case 4:
                        return [3, 2];
                    case 5:
                        return [3, 12];
                    case 6:
                        return c = f.sent(),
                        n = {
                            error: c
                        },
                        [3, 12];
                    case 7:
                        return f.trys.push([7, , 10, 11]),
                        i && !i.done && (s = t.return) ? [4, s.call(t)] : [3, 9];
                    case 8:
                        f.sent(),
                        f.label = 9;
                    case 9:
                        return [3, 11];
                    case 10:
                        if (n)
                            throw n.error;
                        return [7];
                    case 11:
                        return [7];
                    case 12:
                        if (o) {
                            if (this.hasRemaining(1))
                                throw this.createExtraByteError(this.totalPos);
                            return [2, a]
                        }
                        throw h = (l = this).headByte,
                        u = l.pos,
                        d = l.totalPos,
                        new RangeError("Insufficient data in parsing ".concat(B(h), " at ").concat(d, " (").concat(u, " in the current buffer)"))
                    }
                }
                ))
            }
            ))
        }
        ,
        e.prototype.decodeArrayStream = function(e) {
            return this.decodeMultiAsync(e, !0)
        }
        ,
        e.prototype.decodeStream = function(e) {
            return this.decodeMultiAsync(e, !1)
        }
        ,
        e.prototype.decodeMultiAsync = function(e, t) {
            return R(this, arguments, (function() {
                var i, n, s, o, a, r, c, l, h;
                return A(this, (function(u) {
                    switch (u.label) {
                    case 0:
                        i = t,
                        n = -1,
                        u.label = 1;
                    case 1:
                        u.trys.push([1, 13, 14, 19]),
                        s = D(e),
                        u.label = 2;
                    case 2:
                        return [4, U(s.next())];
                    case 3:
                        if ((o = u.sent()).done)
                            return [3, 12];
                        if (a = o.value,
                        t && 0 === n)
                            throw this.createExtraByteError(this.totalPos);
                        this.appendBuffer(a),
                        i && (n = this.readArraySize(),
                        i = !1,
                        this.complete()),
                        u.label = 4;
                    case 4:
                        u.trys.push([4, 9, , 10]),
                        u.label = 5;
                    case 5:
                        return [4, U(this.doDecodeSync())];
                    case 6:
                        return [4, u.sent()];
                    case 7:
                        return u.sent(),
                        0 == --n ? [3, 8] : [3, 5];
                    case 8:
                        return [3, 10];
                    case 9:
                        if (!((r = u.sent())instanceof F))
                            throw r;
                        return [3, 10];
                    case 10:
                        this.totalPos += this.pos,
                        u.label = 11;
                    case 11:
                        return [3, 2];
                    case 12:
                        return [3, 19];
                    case 13:
                        return c = u.sent(),
                        l = {
                            error: c
                        },
                        [3, 19];
                    case 14:
                        return u.trys.push([14, , 17, 18]),
                        o && !o.done && (h = s.return) ? [4, U(h.call(s))] : [3, 16];
                    case 15:
                        u.sent(),
                        u.label = 16;
                    case 16:
                        return [3, 18];
                    case 17:
                        if (l)
                            throw l.error;
                        return [7];
                    case 18:
                        return [7];
                    case 19:
                        return [2]
                    }
                }
                ))
            }
            ))
        }
        ,
        e.prototype.doDecodeSync = function() {
            e: for (; ; ) {
                var e = this.readHeadByte()
                  , t = void 0;
                if (e >= 224)
                    t = e - 256;
                else if (e < 192)
                    if (e < 128)
                        t = e;
                    else if (e < 144) {
                        if (0 != (n = e - 128)) {
                            this.pushMapState(n),
                            this.complete();
                            continue e
                        }
                        t = {}
                    } else if (e < 160) {
                        if (0 != (n = e - 144)) {
                            this.pushArrayState(n),
                            this.complete();
                            continue e
                        }
                        t = []
                    } else {
                        var i = e - 160;
                        t = this.decodeUtf8String(i, 0)
                    }
                else if (192 === e)
                    t = null;
                else if (194 === e)
                    t = !1;
                else if (195 === e)
                    t = !0;
                else if (202 === e)
                    t = this.readF32();
                else if (203 === e)
                    t = this.readF64();
                else if (204 === e)
                    t = this.readU8();
                else if (205 === e)
                    t = this.readU16();
                else if (206 === e)
                    t = this.readU32();
                else if (207 === e)
                    t = this.readU64();
                else if (208 === e)
                    t = this.readI8();
                else if (209 === e)
                    t = this.readI16();
                else if (210 === e)
                    t = this.readI32();
                else if (211 === e)
                    t = this.readI64();
                else if (217 === e)
                    i = this.lookU8(),
                    t = this.decodeUtf8String(i, 1);
                else if (218 === e)
                    i = this.lookU16(),
                    t = this.decodeUtf8String(i, 2);
                else if (219 === e)
                    i = this.lookU32(),
                    t = this.decodeUtf8String(i, 4);
                else if (220 === e) {
                    if (0 !== (n = this.readU16())) {
                        this.pushArrayState(n),
                        this.complete();
                        continue e
                    }
                    t = []
                } else if (221 === e) {
                    if (0 !== (n = this.readU32())) {
                        this.pushArrayState(n),
                        this.complete();
                        continue e
                    }
                    t = []
                } else if (222 === e) {
                    if (0 !== (n = this.readU16())) {
                        this.pushMapState(n),
                        this.complete();
                        continue e
                    }
                    t = {}
                } else if (223 === e) {
                    if (0 !== (n = this.readU32())) {
                        this.pushMapState(n),
                        this.complete();
                        continue e
                    }
                    t = {}
                } else if (196 === e) {
                    var n = this.lookU8();
                    t = this.decodeBinary(n, 1)
                } else if (197 === e)
                    n = this.lookU16(),
                    t = this.decodeBinary(n, 2);
                else if (198 === e)
                    n = this.lookU32(),
                    t = this.decodeBinary(n, 4);
                else if (212 === e)
                    t = this.decodeExtension(1, 0);
                else if (213 === e)
                    t = this.decodeExtension(2, 0);
                else if (214 === e)
                    t = this.decodeExtension(4, 0);
                else if (215 === e)
                    t = this.decodeExtension(8, 0);
                else if (216 === e)
                    t = this.decodeExtension(16, 0);
                else if (199 === e)
                    n = this.lookU8(),
                    t = this.decodeExtension(n, 1);
                else if (200 === e)
                    n = this.lookU16(),
                    t = this.decodeExtension(n, 2);
                else {
                    if (201 !== e)
                        throw new w("Unrecognized type byte: ".concat(B(e)));
                    n = this.lookU32(),
                    t = this.decodeExtension(n, 4)
                }
                this.complete();
                for (var s = this.stack; s.length > 0; ) {
                    var o = s[s.length - 1];
                    if (0 === o.type) {
                        if (o.array[o.position] = t,
                        o.position++,
                        o.position !== o.size)
                            continue e;
                        s.pop(),
                        t = o.array
                    } else {
                        if (1 === o.type) {
                            if (!L(t))
                                throw new w("The type of key must be string or number but " + typeof t);
                            if ("__proto__" === t)
                                throw new w("The key __proto__ is not allowed");
                            o.key = t,
                            o.type = 2;
                            continue e
                        }
                        if (o.map[o.key] = t,
                        o.readCount++,
                        o.readCount !== o.size) {
                            o.key = null,
                            o.type = 1;
                            continue e
                        }
                        s.pop(),
                        t = o.map
                    }
                }
                return t
            }
        }
        ,
        e.prototype.readHeadByte = function() {
            return -1 === this.headByte && (this.headByte = this.readU8()),
            this.headByte
        }
        ,
        e.prototype.complete = function() {
            this.headByte = -1
        }
        ,
        e.prototype.readArraySize = function() {
            var e = this.readHeadByte();
            switch (e) {
            case 220:
                return this.readU16();
            case 221:
                return this.readU32();
            default:
                if (e < 160)
                    return e - 144;
                throw new w("Unrecognized array type byte: ".concat(B(e)))
            }
        }
        ,
        e.prototype.pushMapState = function(e) {
            if (e > this.maxMapLength)
                throw new w("Max length exceeded: map length (".concat(e, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
            this.stack.push({
                type: 1,
                size: e,
                key: null,
                readCount: 0,
                map: {}
            })
        }
        ,
        e.prototype.pushArrayState = function(e) {
            if (e > this.maxArrayLength)
                throw new w("Max length exceeded: array length (".concat(e, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
            this.stack.push({
                type: 0,
                size: e,
                array: new Array(e),
                position: 0
            })
        }
        ,
        e.prototype.decodeUtf8String = function(e, t) {
            var i;
            if (e > this.maxStrLength)
                throw new w("Max length exceeded: UTF-8 byte length (".concat(e, ") > maxStrLength (").concat(this.maxStrLength, ")"));
            if (this.bytes.byteLength < this.pos + t + e)
                throw H;
            var n, s = this.pos + t;
            return n = this.stateIsMapKey() && (null === (i = this.keyDecoder) || void 0 === i ? void 0 : i.canBeCached(e)) ? this.keyDecoder.decode(this.bytes, s, e) : e > m ? function(e, t, i) {
                var n = e.subarray(t, t + i);
                return g.decode(n)
            }(this.bytes, s, e) : p(this.bytes, s, e),
            this.pos += t + e,
            n
        }
        ,
        e.prototype.stateIsMapKey = function() {
            return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type
        }
        ,
        e.prototype.decodeBinary = function(e, t) {
            if (e > this.maxBinLength)
                throw new w("Max length exceeded: bin length (".concat(e, ") > maxBinLength (").concat(this.maxBinLength, ")"));
            if (!this.hasRemaining(e + t))
                throw H;
            var i = this.pos + t
              , n = this.bytes.subarray(i, i + e);
            return this.pos += t + e,
            n
        }
        ,
        e.prototype.decodeExtension = function(e, t) {
            if (e > this.maxExtLength)
                throw new w("Max length exceeded: ext length (".concat(e, ") > maxExtLength (").concat(this.maxExtLength, ")"));
            var i = this.view.getInt8(this.pos + t)
              , n = this.decodeBinary(e, t + 1);
            return this.extensionCodec.decode(n, i, this.context)
        }
        ,
        e.prototype.lookU8 = function() {
            return this.view.getUint8(this.pos)
        }
        ,
        e.prototype.lookU16 = function() {
            return this.view.getUint16(this.pos)
        }
        ,
        e.prototype.lookU32 = function() {
            return this.view.getUint32(this.pos)
        }
        ,
        e.prototype.readU8 = function() {
            var e = this.view.getUint8(this.pos);
            return this.pos++,
            e
        }
        ,
        e.prototype.readI8 = function() {
            var e = this.view.getInt8(this.pos);
            return this.pos++,
            e
        }
        ,
        e.prototype.readU16 = function() {
            var e = this.view.getUint16(this.pos);
            return this.pos += 2,
            e
        }
        ,
        e.prototype.readI16 = function() {
            var e = this.view.getInt16(this.pos);
            return this.pos += 2,
            e
        }
        ,
        e.prototype.readU32 = function() {
            var e = this.view.getUint32(this.pos);
            return this.pos += 4,
            e
        }
        ,
        e.prototype.readI32 = function() {
            var e = this.view.getInt32(this.pos);
            return this.pos += 4,
            e
        }
        ,
        e.prototype.readU64 = function() {
            var e = function(e, t) {
                return 4294967296 * e.getUint32(t) + e.getUint32(t + 4)
            }(this.view, this.pos);
            return this.pos += 8,
            e
        }
        ,
        e.prototype.readI64 = function() {
            var e = c(this.view, this.pos);
            return this.pos += 8,
            e
        }
        ,
        e.prototype.readF32 = function() {
            var e = this.view.getFloat32(this.pos);
            return this.pos += 4,
            e
        }
        ,
        e.prototype.readF64 = function() {
            var e = this.view.getFloat64(this.pos);
            return this.pos += 8,
            e
        }
        ,
        e
    }()
      , W = {};
    function X(e, t) {
        return void 0 === t && (t = W),
        new q(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decode(e)
    }
    function G(e, t) {
        return void 0 === t && (t = W),
        new q(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeMulti(e)
    }
    var N = function(e, t) {
        var i, n, s, o, a = {
            label: 0,
            sent: function() {
                if (1 & s[0])
                    throw s[1];
                return s[1]
            },
            trys: [],
            ops: []
        };
        return o = {
            next: r(0),
            throw: r(1),
            return: r(2)
        },
        "function" == typeof Symbol && (o[Symbol.iterator] = function() {
            return this
        }
        ),
        o;
        function r(o) {
            return function(r) {
                return function(o) {
                    if (i)
                        throw new TypeError("Generator is already executing.");
                    for (; a; )
                        try {
                            if (i = 1,
                            n && (s = 2 & o[0] ? n.return : o[0] ? n.throw || ((s = n.return) && s.call(n),
                            0) : n.next) && !(s = s.call(n, o[1])).done)
                                return s;
                            switch (n = 0,
                            s && (o = [2 & o[0], s.value]),
                            o[0]) {
                            case 0:
                            case 1:
                                s = o;
                                break;
                            case 4:
                                return a.label++,
                                {
                                    value: o[1],
                                    done: !1
                                };
                            case 5:
                                a.label++,
                                n = o[1],
                                o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(),
                                a.trys.pop();
                                continue;
                            default:
                                if (!(s = (s = a.trys).length > 0 && s[s.length - 1]) && (6 === o[0] || 2 === o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!s || o[1] > s[0] && o[1] < s[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < s[1]) {
                                    a.label = s[1],
                                    s = o;
                                    break
                                }
                                if (s && a.label < s[2]) {
                                    a.label = s[2],
                                    a.ops.push(o);
                                    break
                                }
                                s[2] && a.ops.pop(),
                                a.trys.pop();
                                continue
                            }
                            o = t.call(e, a)
                        } catch (e) {
                            o = [6, e],
                            n = 0
                        } finally {
                            i = s = 0
                        }
                    if (5 & o[0])
                        throw o[1];
                    return {
                        value: o[0] ? o[1] : void 0,
                        done: !0
                    }
                }([o, r])
            }
        }
    }
      , Y = function(e) {
        return this instanceof Y ? (this.v = e,
        this) : new Y(e)
    }
      , K = function(e, t, i) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var n, s = i.apply(e, t || []), o = [];
        return n = {},
        a("next"),
        a("throw"),
        a("return"),
        n[Symbol.asyncIterator] = function() {
            return this
        }
        ,
        n;
        function a(e) {
            s[e] && (n[e] = function(t) {
                return new Promise((function(i, n) {
                    o.push([e, t, i, n]) > 1 || r(e, t)
                }
                ))
            }
            )
        }
        function r(e, t) {
            try {
                !function(e) {
                    e.value instanceof Y ? Promise.resolve(e.value.v).then(c, l) : h(o[0][2], e)
                }(s[e](t))
            } catch (e) {
                h(o[0][3], e)
            }
        }
        function c(e) {
            r("next", e)
        }
        function l(e) {
            r("throw", e)
        }
        function h(e, t) {
            e(t),
            o.shift(),
            o.length && r(o[0][0], o[0][1])
        }
    };
    function J(e) {
        return function(e) {
            return null != e[Symbol.asyncIterator]
        }(e) ? e : function(e) {
            return K(this, arguments, (function() {
                var t, i, n, s;
                return N(this, (function(o) {
                    switch (o.label) {
                    case 0:
                        t = e.getReader(),
                        o.label = 1;
                    case 1:
                        o.trys.push([1, , 9, 10]),
                        o.label = 2;
                    case 2:
                        return [4, Y(t.read())];
                    case 3:
                        return i = o.sent(),
                        n = i.done,
                        s = i.value,
                        n ? [4, Y(void 0)] : [3, 5];
                    case 4:
                        return [2, o.sent()];
                    case 5:
                        return function(e) {
                            if (null == e)
                                throw new Error("Assertion Failure: value must not be null nor undefined")
                        }(s),
                        [4, Y(s)];
                    case 6:
                        return [4, o.sent()];
                    case 7:
                        return o.sent(),
                        [3, 2];
                    case 8:
                        return [3, 10];
                    case 9:
                        return t.releaseLock(),
                        [7];
                    case 10:
                        return [2]
                    }
                }
                ))
            }
            ))
        }(e)
    }
    function Q(e, t) {
        return void 0 === t && (t = W),
        function(e, t, i, n) {
            return new (i || (i = Promise))((function(s, o) {
                function a(e) {
                    try {
                        c(n.next(e))
                    } catch (e) {
                        o(e)
                    }
                }
                function r(e) {
                    try {
                        c(n.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }
                function c(e) {
                    e.done ? s(e.value) : function(e) {
                        return e instanceof i ? e : new i((function(t) {
                            t(e)
                        }
                        ))
                    }(e.value).then(a, r)
                }
                c((n = n.apply(e, t || [])).next())
            }
            ))
        }(this, void 0, void 0, (function() {
            var i;
            return function(e, t) {
                var i, n, s, o, a = {
                    label: 0,
                    sent: function() {
                        if (1 & s[0])
                            throw s[1];
                        return s[1]
                    },
                    trys: [],
                    ops: []
                };
                return o = {
                    next: r(0),
                    throw: r(1),
                    return: r(2)
                },
                "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                    return this
                }
                ),
                o;
                function r(o) {
                    return function(r) {
                        return function(o) {
                            if (i)
                                throw new TypeError("Generator is already executing.");
                            for (; a; )
                                try {
                                    if (i = 1,
                                    n && (s = 2 & o[0] ? n.return : o[0] ? n.throw || ((s = n.return) && s.call(n),
                                    0) : n.next) && !(s = s.call(n, o[1])).done)
                                        return s;
                                    switch (n = 0,
                                    s && (o = [2 & o[0], s.value]),
                                    o[0]) {
                                    case 0:
                                    case 1:
                                        s = o;
                                        break;
                                    case 4:
                                        return a.label++,
                                        {
                                            value: o[1],
                                            done: !1
                                        };
                                    case 5:
                                        a.label++,
                                        n = o[1],
                                        o = [0];
                                        continue;
                                    case 7:
                                        o = a.ops.pop(),
                                        a.trys.pop();
                                        continue;
                                    default:
                                        if (!(s = (s = a.trys).length > 0 && s[s.length - 1]) && (6 === o[0] || 2 === o[0])) {
                                            a = 0;
                                            continue
                                        }
                                        if (3 === o[0] && (!s || o[1] > s[0] && o[1] < s[3])) {
                                            a.label = o[1];
                                            break
                                        }
                                        if (6 === o[0] && a.label < s[1]) {
                                            a.label = s[1],
                                            s = o;
                                            break
                                        }
                                        if (s && a.label < s[2]) {
                                            a.label = s[2],
                                            a.ops.push(o);
                                            break
                                        }
                                        s[2] && a.ops.pop(),
                                        a.trys.pop();
                                        continue
                                    }
                                    o = t.call(e, a)
                                } catch (e) {
                                    o = [6, e],
                                    n = 0
                                } finally {
                                    i = s = 0
                                }
                            if (5 & o[0])
                                throw o[1];
                            return {
                                value: o[0] ? o[1] : void 0,
                                done: !0
                            }
                        }([o, r])
                    }
                }
            }(this, (function(n) {
                return i = J(e),
                [2, new q(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeAsync(i)]
            }
            ))
        }
        ))
    }
    function $(e, t) {
        void 0 === t && (t = W);
        var i = J(e);
        return new q(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeArrayStream(i)
    }
    function Z(e, t) {
        void 0 === t && (t = W);
        var i = J(e);
        return new q(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeStream(i)
    }
    function ee(e, t) {
        return void 0 === t && (t = W),
        Z(e, t)
    }
    i.d(t, "encode", (function() {
        return O
    }
    )),
    i.d(t, "decode", (function() {
        return X
    }
    )),
    i.d(t, "decodeMulti", (function() {
        return G
    }
    )),
    i.d(t, "decodeAsync", (function() {
        return Q
    }
    )),
    i.d(t, "decodeArrayStream", (function() {
        return $
    }
    )),
    i.d(t, "decodeMultiStream", (function() {
        return Z
    }
    )),
    i.d(t, "decodeStream", (function() {
        return ee
    }
    )),
    i.d(t, "Decoder", (function() {
        return q
    }
    )),
    i.d(t, "DecodeError", (function() {
        return w
    }
    )),
    i.d(t, "DataViewIndexOutOfBoundsError", (function() {
        return F
    }
    )),
    i.d(t, "Encoder", (function() {
        return P
    }
    )),
    i.d(t, "ExtensionCodec", (function() {
        return M
    }
    )),
    i.d(t, "ExtData", (function() {
        return y
    }
    )),
    i.d(t, "EXT_TIMESTAMP", (function() {
        return -1
    }
    )),
    i.d(t, "encodeDateToTimeSpec", (function() {
        return b
    }
    )),
    i.d(t, "encodeTimeSpecToTimestamp", (function() {
        return v
    }
    )),
    i.d(t, "decodeTimestampToTimeSpec", (function() {
        return S
    }
    )),
    i.d(t, "encodeTimestampExtension", (function() {
        return x
    }
    )),
    i.d(t, "decodeTimestampExtension", (function() {
        return I
    }
    ))
}
]);
//# sourceMappingURL=bundle.js.map


// new mod



/* unreleased moomoo servers
vultr:1: New Jersey
vultr:2: "Chicago"
vultr:3: Dallas
vultr:4: Seattle
vultr:5: Los Angeles
vultr:6: Atlanta
vultr:7: Amsterdam
vultr 24: Paris
vultr 25: Tokyo
*/

let DevelopmentScripterMode = false; /* Connect Useless Server */

let connectBotts = true;
let proeMan = true;

// love florr.io
Math.florr = Math.floor;

function setLoop(action, loop) {
    for (let i = 0; i < loop; i++) {
        action();
    }
}

// im joking
// song links
const song1 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1055142773948428348/Zack_Merci_X_CRVN_-_Nobody_NCS_Release.mp3");
const song2 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1055516288249757797/ae86.mp3");
const song3 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1069192210932826182/dontstandsoclose.mp3");
const song4 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1083793134162546799/Jonth_Tom_Wilson_Facading_MAGNUS_Jagsy_Vosai_RudeLies__Domastic_-_Heartless_NCS10_Release_-_from_YouTube.mp3");
const song5 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1086876186887594076/boobmoo.mp3");
const song6 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1110020974180573264/ooooaadhahaha.mp3");
// sound links
const pvzvic = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1101430764530323547/Plants_Vs_Zombies_Victory_Jingle_-_from_YouTube.mp3");
const ahhhhhh = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1053978907717685288/ahh.mp3");
const ohioMenu = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1101435244311216169/penis_music_-_from_YouTube.mp3");
ohioMenu.volume = "0.2";

function getEl(id) {
    return document.getElementById(id);
}
let firstConfig = [];
let streamerMode = false;
const HTML = {
    newLine: function(amount) {
        let text = ``;
        for (let i = 0; i < amount; i++) {
            text += `<br>`;
        }
        return text;
    },
    line: function() {
        return `<hr>`;
    },
    text: function(id, value, size, length) {
        return `<input type = "text" id = ${id} size = ${size} value = ${value} maxlength = ${length}>`;
    },
    checkBox: function(id, name, checked, rl) {
        return `${rl ? name + ` ` : ``}<input type = "checkbox" ${checked ? `checked` : ``} id = ${id}>${rl ? `` : ` ` + name}`;
    },
    button: function(id, name, onclick, classs) {
        return `<button class = ${classs} id = ${id} onclick = ${onclick}>${name}</button>`;
    },
    select: function(id, selects) {
        let text = `<select id = ${id}>`;
        selects.forEach((e,i)=>{
            text += `<option value = ${e.value} ${e.selected ? ` selected` : ``}>${e.name}</option>`;
            if (i == selects.length - 1) {
                text += `</select>`;
            }
        }
        );
        return text;
    },
    modChange: function(id, selects) {
        console.log("test");
    },
    mod: function(id, selects) {
        let text = `<select id = ${id}>`;
        selects.forEach((e,i)=>{
            text += `<option value = ${e.value + "C"}>${e.name}</option>`;
            if (i == selects.length - 1) {
                text += `</select> `;
            }
            if (i == 0) {
                firstConfig.push(e.value + "C");
            }
        }
        );
        selects.forEach((e,i)=>{
            text += `<input type = "checkbox"  ${e.checked ? `checked` : ``} id = ${e.value} style = "${i == 0 ? "display: inline-block;" : "display: none;"}">`;
        }
        );
        return text;
    },
    hotkey: function(id, value, size, length) {
        return `<input type = "text" id = ${id} size = ${size} value = ${value} maxlength = ${length}><input type = "checkbox" checked id = ${id + "k"}>`;
    },
};

function getTabId(el) {
    return el.id == "tHome" ? "homeTab" : el.id == "t1" ? "miscTab" : el.id == "t2" ? "configTab" : el.id == "t3" ? "combatTab" : "homeTab";
}

function changeEtcfrrrrrrrrrrr0917237891x828xjiwaskdaslmfaofmalfaiosf() {
    getEl("homeTab").style.display = "none";
    getEl("miscTab").style.display = "none";
    getEl("configTab").style.display = "none";
    getEl("combatTab").style.display = "none";
    getEl("tHome").style.border = "2px solid transparent";
    getEl("tHome").style.color = "#fff";
    getEl("tHome").style.backgroundColor = "#000";
    for (let i = 1; i <= 3; i++) {
        getEl("t" + i).style.border = "2px solid transparent";
        getEl("t" + i).style.color = "#fff";
        getEl("t" + i).style.backgroundColor = "#000";
    }
}

function changeDisp(el) {
    changeEtcfrrrrrrrrrrr0917237891x828xjiwaskdaslmfaofmalfaiosf();
    getEl(el.id).style.color = "#000";
    getEl(el.id).style.backgroundColor = "#fff";
    getEl(el.id).style.border = "2px solid #000";
    getEl(getTabId(el)).style.display = "block";
}
let updateLogs = `
Toggle:${HTML.newLine(1)}
${HTML.checkBox("ranName", "randomName", false)}${HTML.newLine(1)}
${HTML.checkBox("ohio", "ohioMode", false)}${HTML.newLine(2)}
Updates:
${HTML.line()}
v1.0: Advanced Heal, AntiBull ${HTML.newLine(1)}
v1.1: Added Module - Ueheua, Spyder, L._.re ${HTML.newLine(1)}
v1.2: Fixed Lag Issue, Deleted Useless Thing ${HTML.newLine(1)}
v1.3: Added Module - Celestial ${HTML.newLine(1)}
v1.4: Improved Menu HTML ${HTML.newLine(1)}
v1.5: Added Module - Zephyr, Fixed Reload System ${HTML.newLine(1)}
v1.6: Fixed Anti Insta, Added SpikeTick ${HTML.newLine(1)}
v1.7: Improved Bundle Codes, Added Item Counter ${HTML.newLine(1)}
v1.8: Better AntiBull, Added AutoQ ${HTML.newLine(1)}
v1.9: Now Can Anti Reverse 3Tick Insta ${HTML.newLine(1)}
${HTML.line()}
v2.0: Fix Anti Healing ${HTML.newLine(1)}
v2.1: Added Perfect Damage Based Insta ${HTML.newLine(1)}
v2.2: Advanced Full Damage Counter Insta ${HTML.newLine(1)}
v2.3: Added Module - FlareZ(Radar By Nekosan)${HTML.newLine(1)}
v2.4: Updated Heal System, Better Tick Base ${HTML.newLine(1)}
v2.5: Added Reverse Insta For Youtube Kids ${HTML.newLine(1)}
v2.6: Added Module - King Hans, Fixed Issues ${HTML.newLine(1)}
v2.7: Added AntiSpikeTick(Testing), Fixed Some ${HTML.newLine(1)}
v2.8: Improved Many Codes ${HTML.newLine(1)}
v2.9: Fixing Bugs(What)${HTML.newLine(1)}
${HTML.line()}
v3.0: Big Updated Script. Heal, Insta, etc...${HTML.newLine(1)}
v3.1: Moved Editor: TamperMonkey => VSCode ${HTML.newLine(1)}
v3.2: Changed To New Anti Healing(Beta Shit)${HTML.newLine(1)}
v3.3: See My Video <button onclick = "document.gototouchgrass()">Click Here!</button> ${HTML.newLine(1)}
v3.4: Advanced 20 Combat Features ${HTML.newLine(1)}
v3.5: me get rest ${HTML.newLine(1)}
`;
/*
 */
let Wut = "Select";
// menu html
let modMenus = document.createElement("div");
modMenus.id = "modMenus";
document.body.append(modMenus);
modMenus.style = `
display: block;
padding: 10px;
background-color: rgba(0, 0, 0, 0.25);
border-radius: 4px;
position: absolute;
left: 20px;
top: 20px;
width: 300px;
height: 700;
transition: 1s;
`;
let canmove = true;

function updateInnerHTML() {
    modMenus.innerHTML = `
    <style>
    .tabchange {
    color: #fff;
    background-color: #000;
    border: 2px solid transparent;
    border-radius: 4px;
    text-align: center;
    height: 25px;
    }
    .menuTabs {
    padding-left: 5px;
    padding-top: 5px;
    padding-bottom: 5px;
    }
    .holder {
    padding-left: 1em;
    }
    .nothing {
    }
    </style>
    <script>
    function test() {
    console.log("call");
    }
    </script>
    <div id = "headline" style = "font-size: 30px; color: rgb(255, 255, 255);">
    <div class = "menuTabs">
    ${HTML.button("tHome", "Home", "", "tabchange")}
    ${HTML.button("t1", "1", "", "tabchange")}
    ${HTML.button("t2", "2", "", "tabchange")}
    ${HTML.button("t3", "3", "", "tabchange")}
    </div>
    <div style = "font-size: 12px; overflow-y: scroll; max-height: 150px;" max-width: 150px;>
    <div id = "homeTab" style = "display: block">
    <div id = "priXP">Primary XP: 0 / not found</div>
    <div id = "secXP">Seconadry XP: 0 / not found</div>
    <div id = "healer">Healer: High Ping</div>
    </div>
    <div id = "miscTab" style = "display: none">
    Create clan: ${HTML.text("ccv", "clan", "20", "7")}${HTML.newLine(1)}
    ${HTML.button("ccf", "Create clan", `document.createAlliance(document.getElementById("ccv").value)`, "nothing")}${HTML.newLine(1)}
    ${HTML.select("autoupgrade", [{
        name: "Autoupgrade to DH",
        value: "dh",
    }, {
        name: "Autoupgrade to KH",
        value: "kh",
    }, {
        name: "Autoupgrade to SM",
        value: "sm",
    }, ])}${HTML.newLine(1)}
    7-Slot: ${HTML.select("7slot", [{
        name: "Teleporter",
        value: "38",
    }, {
        name: "Turret",
        value: "33",
    }, ])}${HTML.newLine(1)}
    </div>
    <div id = "configTab" style = "display: none">
    ${HTML.mod("configs", [{
        name: "AddAdditionalRangeOnLag",
        value: "addictdist",
        checked: true,
    }, {
        name: "doAntiKickAtPacketLimit",
        value: "ak",
        checked: true,
    }, {
        name: "doRenderKMTexture",
        value: "kmtexture",
        checked: true,
    }, {
        name: "doAutoBullTick",
        value: "bulltick",
        checked: true,
    }, {
        name: "doAutoQOnSync",
        value: "antisync",
        checked: true,
    }, {
        name: "doAutoQOnHighPing",
        value: "autoq",
    }, {
        name: "doSimpleAntiInsta",
        value: "simpleheal",
    }, {
        name: "doTickBasedHealing",
        value: "tickheal",
    }, {
        name: "doAutoSpikeTickOnReplaced",
        value: "spiketick",
        checked: true,
    }, {
        name: "doUseTurretOnCounter",
        value: "countertur",
        checked: true,
    }, {
        name: "doUseSecondaryOnCounter",
        value: "countersec",
    }, {
        name: "doClickCombat",
        value: "clicktype",
    }, {
        name: "doAutoSpinning",
        value: "spin",
    }, {
        name: "doBuildingHealth",
        value: "bh",
    }, {
        name: "doRenderDark",
        value: "darkmode",
    }, {
        name: "doShowStackedAnimtext",
        value: "stacktext",
    }, {
        name: "doDisableAnimtext",
        value: "hidetext",
    }, {
        name: "doUpperCaseChatting",
        value: "chatc",
    }, {
        name: "doTryHardMode",
        value: "tryhard",
    }, {
        name: "doAlwaysRevInsta",
        value: "alwaysrev",
    }, {
        name: "doBotMovementToNear",
        value: "botmove",
    }, ])}${HTML.newLine(1)}
    <div id = "freeCam">Freecam: none</div>
    Freecam hotkey: ${HTML.hotkey("freecumLOL", "/", "2", "1")}${HTML.newLine(1)}
    Debug hotkey: ${HTML.hotkey("debugkey", "Z", "2", "1")}${HTML.newLine(1)}
    Spike hotkey: ${HTML.hotkey("spikekey", "v", "2", "1")}${HTML.newLine(1)}
    Trap/Boost hotkey: ${HTML.hotkey("trapkey", "f", "2", "1")}${HTML.newLine(1)}
    Turret/Teleport hotkey: ${HTML.hotkey("turretkey", "h", "2", "1")}${HTML.newLine(1)}
    Automill hotkey: ${HTML.hotkey("millkey", "z", "2", "1")}${HTML.newLine(1)}
    Connectbot hotkey: ${HTML.hotkey("botkey", "G", "2", "1")}${HTML.newLine(1)}
    Zoom hotkey: ${HTML.hotkey("zoomkey", "-", "2", "1")}${HTML.newLine(1)}
    Zoom reset key: ${HTML.hotkey("zoomresetkey", "=", "2", "1")}${HTML.newLine(1)}
    Song hotkey: ${HTML.hotkey("songkey", "C", "2", "1")}${HTML.newLine(1)}
    Song: ${HTML.select("songs", [{
        name: "CRVN - Nobody",
        value: "1",
    }, {
        name: "Dave Rodgers - Ae86",
        value: "2",
    }, {
        name: "Dr Love - Don't Stand So Close",
        value: "3",
    }, {
        name: "Domastic - Heartless",
        value: "4",
    }, {
        name: "PVRIS - Burn It All Down",
        value: "5",
    }, {
        name: "Crypt x Joey Nato - Invincible",
        value: "6",
        selected: true,
    }, ])}${HTML.newLine(1)}
      ${HTML.checkBox("showch", "sendChatPacket", true, true)}${HTML.newLine(1)}
    Ratio hotkey: ${HTML.hotkey("ezkey", "@", "2", "1")}${HTML.newLine(1)}
    Vision: ${HTML.select("vision", [{
        name: "1",
        value: "1",
        selected: true,
    }, {
        name: "1.1",
        value: "1.1",
    }, {
        name: "1.2",
        value: "1.2",
    }, {
        name: "1.3",
        value: "1.3",
    }, {
        name: "1.4",
        value: "1.4",
    }, {
        name: "1.5",
        value: "1.5",
    }, ])}${HTML.newLine(1)}
    ExtraCombat(Beta): ${HTML.select("combat", [{
        name: "Default",
        value: "0",
    }, {
        name: "Spyder",
        value: "spyder",
    }, {
        name: "L._.re",
        value: "lore",
    }, {
        name: "Celestial",
        value: "cele",
    }, {
        name: "Zephyr",
        value: "zeph",
    }, {
        name: "Ae86",
        value: "ae",
    }, {
        name: "FlareZ",
        value: "fz",
        selected: true,
    }, {
        name: "Zyenith",
        value: "zyenith",
    }, {
        name: "King Hans",
        value: "hans",
    }, {
        name: "Ueheua",
        value: "me",
    }, ])} - <div id = "crp" style = "display: inline-block;">lol ur bad</div>${HTML.newLine(1)}
    ExtraVisual: ${HTML.select("visual", [{
        name: "Default",
        value: "0",
    }, {
        name: "Spyder",
        value: "spyder",
    }, {
        name: "L._.re",
        value: "lore",
    }, {
        name: "Celestial",
        value: "cele",
    }, {
        name: "Zephyr",
        value: "zeph",
    }, {
        name: "Ae86",
        value: "ae",
    }, {
        name: "FlareZ",
        value: "fz",
    }, {
        name: "Zyenith",
        value: "zyenith",
    }, {
        name: "King Hans",
        value: "hans",
    }, {
        name: "Ueheua",
        value: "me",
        selected: true,
    }, ])} - <div id = "vrp" style = "display: inline-block;">lol ur b a d</div>${HTML.newLine(1)}
    </div>
    <div id = "combatTab" style = "display: none">
    (region locked)${HTML.button("serverwarper", "Warp to Active Server", `document.warpServer()`, "nothing")}${HTML.newLine(2)}
    Object for the placer: ${HTML.select("placeconfig", [{
        name: "Walls",
        value: "1",
    }, {
        name: "Spikes",
        value: "2",
    }, {
        name: "Windmills",
        value: "3",
        selected: true,
    }, {
        name: "Trap/Boosts",
        value: "4",
    }, {
        name: "Teleport/Turrets",
        value: "5",
    }, ])}${HTML.newLine(2)}
    One-way: ${HTML.button("streamer", "Streamer Mode", "", "nothing")}${HTML.newLine(2)}
    farm
    <div class = "holder">
    ${HTML.checkBox("grind", "autoRuby", false)}${HTML.newLine(1)}
    ${HTML.checkBox("grindsec", "autoRubySec", true)}${HTML.newLine(1)}
    </div>
    anti
    <div class = "holder">
    ${HTML.checkBox("soldieranti", "soldierAntiInsta", true)}${HTML.newLine(1)}
    ${HTML.checkBox("soldierempanti", "soldierEmpAntiInsta", true)}${HTML.newLine(1)}
    ${HTML.checkBox("antitick", "anti0Tick", true)}${HTML.newLine(1)}
    ${HTML.checkBox("antirange", "antiRangedInsta", true)}${HTML.newLine(1)}
    </div>
    autoBreak
    <div class = "holder">
    ${HTML.checkBox("earlyab", "early", true)}${HTML.newLine(1)}
    earlyWaitTime ${HTML.newLine(1)}
    ${HTML.text("earlytime", "10", "6", "5")}${HTML.newLine(1)}
    ${HTML.checkBox("abactive", "activate", true)}${HTML.newLine(1)}
    ${HTML.checkBox("ab360hit", "breakitems(Patched)", false)}${HTML.newLine(1)}
    ${HTML.checkBox("abplace", "tryPlacementEveryTick", false)}${HTML.newLine(1)}
    </div>
    music
    <div class = "holder">
    ${HTML.checkBox("msync", "sync", true)}${HTML.newLine(1)}
    </div>
    autoTrigger
    <div class = "holder">
    ${HTML.checkBox("sync", "syncShots", false)}${HTML.newLine(1)}
    syncThrottle ${HTML.newLine(1)}
    ${HTML.text("synccount", "1", "6", "2")}${HTML.newLine(1)}
    </div>
    mouse
    <div class = "holder">
    ${HTML.checkBox("clicksync", "mclickSync", false)}${HTML.newLine(1)}
    </div>
    autoQ
    <div class = "holder">
    ${HTML.checkBox("evautoq", "alwaysOn", false)}${HTML.newLine(1)}
    </div>
    placement
    <div class = "holder">
    ${HTML.checkBox("replc", "autoreplace", true)}${HTML.newLine(1)}
    ${HTML.checkBox("autoplc", "placeEveryTick", true)}${HTML.newLine(1)}
    </div>
    autoUpgrade
    <div class = "holder">
    ${HTML.checkBox("aaauaua", "activate", false)}${HTML.newLine(1)}
    </div>
    </div>
    </div>
    `;
}
updateInnerHTML();
changeDisp(getEl("tHome"));
getEl("tHome").onclick = function() {
    changeDisp(this);
}
;
getEl("t1").onclick = function() {
    changeDisp(this);
}
;
getEl("t2").onclick = function() {
    changeDisp(this);
}
;
getEl("t3").onclick = function() {
    changeDisp(this);
}
;
getEl("streamer").onclick = function() {
    streamerMode = !streamerMode;
}
;
getEl("ccv").onfocus = function() {
    canmove = false;
}
;
getEl("ccv").onblur = function() {
    canmove = true;
}
;
let oldSelect = firstConfig[0];
let newSelect = firstConfig[0];
getEl("configs").onchange = function() {
    let value = getEl("configs").value;
    let sliced = function(val) {
        return val.slice(0, val.length - 1);
    };
    oldSelect = newSelect;
    newSelect = value;
    getEl(sliced(oldSelect)).style.display = "none";
    getEl(sliced(newSelect)).style.display = "inline-block";
}
;
function checkCheckChickenModV69(a) {
    let aw = a == "0" ? "Legit" : a == "spyder" ? "Quasar Beta v0.83" : a == "lore" ? "L._.re FZ Lover" : a == "zeph" ? "J Mod" : a == "cele" ? "Goofy Ahh Mod" : a == "ae" ? "Alpine A110" : a == "fz" ? "RV2" : a == "zyenith" ? "RV3" : a == "me" ? "Pre Client V69420" : a == "hans" ? "Sofia Client" : "U r bad";
    return aw;
}

getEl("crp").innerHTML = checkCheckChickenModV69(getEl("combat").value);
getEl("vrp").innerHTML = checkCheckChickenModV69(getEl("visual").value);

document.gototouchgrass = function() {
    window.onbeforeunload = undefined;
    window.location.href = "https://www.youtube.com/watch?v=dQw4w9WgXcQ";
}

let urGameRegion = "";
let botSockets = [];
let firstMan = true;
let manClan = undefined;
let healLag = 100;
var secPacket = 0;
var minPacket = 0;
var secMax = 110;
var minMax = 5100;
var secTime = 1000;
var minTime = 60000;
var firstSend = {
    sec: false,
    min: false,
};
let tmpAddress;
let wsconnected = 0;
let doMouseMove = false;
let myConfig = {
    x: 0,
    y: 0,
    sync: false,
};
let myNearAim = undefined;
let doEnemyMove = false;

function bConnect(token) {
    let o = token && new WebSocket(tmpAddress + "&token=" + encodeURIComponent(token));
    o.binaryType = "arraybuffer";
    o.id = null;
    o.firstMan = firstMan ? true : false;
    firstMan = false;
    o.sTime = 0;
    o.sCount = 0;
    o.health = 100;
    o.enemy = [];
    o.near = [];
    o.weapons = [0];
    o.items = [0, 3, 6, 10];
    o.skins = [];
    o.tails = [];
    o.score = 100;
    o.upgraded = 0;
    o.millCount = 0;
    o.moveDir = undefined;
    let snowBiomeTop = 2400;
    let riverWidth = 724;
    let mapScale = 14400;
    if (o.firstMan) {
        o.allianceNotifications = [];
        o.tickC = 0;
    }

    function wsSend(ms) {
        o.send(new Uint8Array(Array.from(window.msgpack.encode(ms))));
    }

    function botSpawn() {
        o.weapons = [0];
        o.items = [0, 3, 6, 10];
        o.score = 100;
        o.upgraded = 0;
        let aaaaahahahah = [4, 6];
        let boom = aaaaahahahah[Math.floor(Math.random() * aaaaahahahah.length)];
        let racist = boom === 4 ? "whi l te" : "bla l ck";
        wsSend(["sp", [{
            name: "racist-" + racist,
            moofoll: 1,
            skin: boom,
        }, ], ]);
        //"propertyIsEnumerable"
        wsSend(["7", [true]]);
        setTimeout(()=>{
            plc();
        }
        , 1000);
    }

    function plc() {
        wsSend(["5", [o.items[0]]]);
        wsSend(["c", [1]]);
        wsSend(["5", [o.weapon, true]]);
    }

    function plct(ang) {
        wsSend(["5", [o.items[4]]]);
        wsSend(["c", [1, ang]]);
        wsSend(["5", [o.weapon, true]]);
    }

    function plc1(ang) {
        wsSend(["5", [o.items[3]]]);
        wsSend(["c", [1, ang]]);
        wsSend(["5", [o.weapon, true]]);
    }

    function plca(id, ang) {
        wsSend(["5", [o.items[id]]]);
        wsSend(["c", [1, ang]]);
        wsSend(["5", [o.weapon, true]]);
    }

    function storeEquip(id, index) {
        wsSend(["13c", [0, id, index]]);
    }

    function storeBuy(id, index) {
        wsSend(["13c", [1, id, index]]);
    }

    function buyEquip(id, index) {
        if (index == 0) {
            if (o.skins[id]) {
                if (o.hat != id) {
                    storeEquip(id, 0);
                }
            } else {
                if (id == 6 && o.score >= 4000) {
                    storeBuy(id, 0);
                } else if (id == 12 && o.score >= 6000) {
                    storeBuy(id, 0);
                } else if (id == 53 && o.score >= 10000) {
                    storeBuy(id, 0);
                }
            }
        } else if (index == 1) {
            if (o.tails[id]) {
                if (o.accessory != id) {
                    storeEquip(id, 1);
                }
            } else {
                if (id == 21 && o.score >= 15000) {
                    storeBuy(id, 1);
                } else if (id == 11 && o.score >= 2000) {
                    storeBuy(id, 1);
                }
            }
        }
    }
    function autoBuyhats() {

    }
    function autoBuyAccs() {

    }

    function rad(ang) {
        return ang * (Math.PI / 180);
    }

    function sendUpgrade(index) {
        wsSend(["6", [index]]);
    }
    o.mill = {
        x: 0,
        y: 0,
    };
    o.old = {
        x: 0,
        y: 0,
    };
    o.sync = false;
    o.movedir = undefined;
    o.onmessage = function(ms) {
        let tmpData = window.msgpack.decode(new Uint8Array(ms.data));
        let data;
        if (tmpData.length > 1) {
            data = [tmpData[0], ...tmpData[1]];
            if (data[1]instanceof Array) {
                data = data;
            }
        } else {
            data = tmpData;
        }
        let item = data[0];
        if (!data)
            return;
        if (data[0] == "1" && o.id == null) {
            o.id = data[1];
        }
        if (data[0] == "11") {
            botSpawn();
        }
        if (data[0] == "33") {
            o.enemy = [];
            o.near = [];
            if (o.firstMan) {
                o.tickC += 1;
            }
            for (let i = 0; i < data[1].length / 13; i++) {
                let players = data[1].slice(13 * i, 13 * i + 13);
                if (players[0] == o.id) {
                    o.id = players[0];
                    o.x = players[1];
                    o.y = players[2];
                    o.weapon = players[5];
                    o.clan = players[7];
                    o.hat = players[9];
                    o.accessory = players[10];
                    if (o.firstMan) {
                        manClan = o.clan;
                    }
                }
                if (!(players[0] == o.id || (players[7] && players[7] == o.clan))) {
                    o.enemy.push(players);
                }
            }
            if (o.enemy.length) {
                o.near = o.enemy.sort(function(a, b) {
                    return (Math.hypot(a[2] - o.y, a[1] - o.x) - Math.hypot(b[2] - o.y, b[1] - o.x));
                })[0];
            }
            if (getEl("botmove").checked || o.enemy.length) {
                if (getEl("botmove").checked) {
                    o.movedir = myNearAim(o);
                    wsSend(["33", [myNearAim(o)]]);
                    if (Math.hypot(o.near[2] - o.y, o.near[1] - o.x) <= 300) {
                        plct(Math.atan2(o.near[2] - o.y, o.near[1] - o.x));
                    } else {
                        wsSend(["2", [Math.atan2(o.near[2] - o.y, o.near[1] - o.x)]]);
                    }
                } else {
                    o.movedir = Math.atan2(o.near[2] - o.y, o.near[1] - o.x);
                    wsSend(["33", [Math.atan2(o.near[2] - o.y, o.near[1] - o.x)]]);
                    if (Math.hypot(o.near[2] - o.y, o.near[1] - o.x) <= 300) {
                        plct(Math.atan2(o.near[2] - o.y, o.near[1] - o.x));
                    } else {
                        wsSend(["2", [Math.atan2(o.near[2] - o.y, o.near[1] - o.x)]]);
                    }
                }
            } else {
                if (o.movedir != undefined) {
                    o.movedir = undefined;
                    wsSend(["33", [undefined]]);
                }
            }
            if (Math.hypot(o.near[2] - o.y, o.near[1] - o.x) <= 300) {
                if (o.weapon != (o.weapons[1] ? o.weapons[1] : o.weapons[0])) {
                    wsSend(["5", [o.weapons[1] ? o.weapons[1] : o.weapons[0], true]]);
                }
            } else {
                if (o.weapon != o.weapons[0]) {
                    wsSend(["5", [o.weapons[0], true]]);
                }
            }
            if (myConfig.sync) {
                buyEquip(53, 0);
            } else {
                buyEquip(6, 0);
            }
            buyEquip(21, 1);
            if (o.firstMan) {
                if (!o.clan) {
                    let text = "clan";
                    let possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    for (let i = 0; i < 3; i++) {
                        text += possible.charAt(Math.floor(Math.random() * possible.length));
                    }
                    wsSend(["8", [text]]);
                } else {
                    if (o.tickC % 9 === 0) {
                        if (o.allianceNotifications.length) {
                            wsSend(["11", [o.allianceNotifications[0].sid, true]]);
                            o.allianceNotifications.splice(0, 1);
                        }
                    }
                }
            } else {
                if (o.clan && o.clan != manClan) {
                    wsSend(["9", [undefined]]);
                } else {
                    if (o.clan != manClan) {
                        wsSend(["10", [manClan]]);
                    }
                }
            }
            if (o.millCount <= 96 && !(o.y >= mapScale / 2 - riverWidth / 2 && o.y <= mapScale / 2 + riverWidth / 2) && window.location.hostname == "sandbox.moomoo.io") {
                if (o.oldy != o.y || o.oldx != o.x) {
                    if (Math.hypot(o.mill.y - o.y, o.mill.x - o.x) > 94) {
                        let ang = Math.atan2(o.old.y - o.y, o.old.x - o.x);
                        plc1(ang + rad(94 / 1.25));
                        plc1(ang - rad(94 / 1.25));
                        plc1(ang);
                        o.mill.x = o.x;
                        o.mill.y = o.y;
                    }
                    o.old.x = o.x;
                    o.old.y = o.y;
                }
            }
        }
        if (data[0] == "14") {
            if (data[1] == 3) {
                o.millCount = data[2];
            }
        }
        if (data[0] == "16") {
            if (data[1] > 0) {
                if (o.upgraded == 0) {
                    sendUpgrade(3);
                } else if (o.upgraded == 1) {
                    sendUpgrade(17);
                } else if (o.upgraded == 2) {
                    sendUpgrade(31);
                } else if (o.upgraded == 3) {
                    sendUpgrade(27);
                } else if (o.upgraded == 4) {
                    sendUpgrade(11);
                } else if (o.upgraded == 5) {
                    sendUpgrade(38);
                } else if (o.upgraded == 6) {
                    sendUpgrade(4);
                } else if (o.upgraded == 7) {
                    sendUpgrade(25);
                }
                o.upgraded++;
            }
        }
        if (data[0] == "17") {
            if (data[1]) {
                if (data[2]) {
                    o.weapons = data[1];
                } else {
                    o.items = data[1];
                }
            }
        }
        if (data[0] == "h" && data[1] == o.id) {
            let dmg = o.health - data[2];
            if (o.health - data[2] < 0) {
                if (o.sTime) {
                    let timeHit = Date.now() - o.sTime;
                    o.sTime = 0;
                    if (timeHit <= 120) {
                        o.sCount++;
                    } else {
                        o.sCount = Math.max(0, o.sCount - 2);
                    }
                }
            } else {
                o.sTime = Date.now();
            }
            if (dmg >= 10 && o.sCount < 4) {
                plc();
            } else {
                setTimeout(()=>{
                    plc();
                }
                , 75);
            }
            o.health = data[2];
        }
        if (o.firstMan) {
            if (data[0] == "an") {
                o.allianceNotifications.push({
                    sid: data[1],
                    name: data[2],
                });
            }
        }
        if (data[0] == "us") {
            if (data[3]) {
                if (!data[1])
                    o.tails[data[2]] = 1;
                else
                    o.accessory = data[2];
            } else {
                if (!data[1])
                    o.skins[data[2]] = 1;
                else
                    o.hat = data[2];
            }
        }
        if (data[0] == "9") {
            if (data[1] == "points") {
                o.score = data[2];
            } else if (data[1] == "kills") {
                wsSend(["ch", ["gg - SexWare autoGG"]]);
            }
        }
    }
    ;
    o.onopen = function() {
        wsconnected++;
        botSpawn();
        botSockets.push(o);
    }
    ;
    o.onclose = function() {
        if (o.firstMan) {
            firstMan = true;
            manClan = undefined;
        }
    }
    ;
}
/******/
(function(modules) {
    // webpackBootstrap
    /******/
    // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/
    // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/
        // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/
        // Create a new module (and put it into the cache)
        /******/
        var module = (installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {},
            /******/
        });
        /******/
        /******/
        // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/
        // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/
        // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/
    // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/
    // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/
    // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter,
            });
            /******/
        }
        /******/
    }
    ;
    /******/
    /******/
    // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module",
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        /******/
    }
    ;
    /******/
    /******/
    // create a fake namespace object
    /******/
    // mode & 1: value is a module id, require it
    /******/
    // mode & 2: merge all properties of value into the ns
    /******/
    // mode & 4: return value when already ns object
    /******/
    // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1)
            value = __webpack_require__(value);
        /******/
        if (mode & 8)
            return value;
        /******/
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, "default", {
            enumerable: true,
            value: value,
        });
        /******/
        if (mode & 2 && typeof value != "string")
            for (var key in value)
                __webpack_require__.d(ns, key, function(key) {
                    return value[key];
                }
                .bind(null, key));
        /******/
        return ns;
        /******/
    }
    ;
    /******/
    /******/
    // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ? /******/
        function getDefault() {
            return module["default"];
        }
        : /******/
        function getModuleExports() {
            return module;
        }
        ;
        /******/
        __webpack_require__.d(getter, "a", getter);
        /******/
        return getter;
        /******/
    }
    ;
    /******/
    /******/
    // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }
    ;
    /******/
    /******/
    // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/
    // Load entry module and return exports
    /******/
    return __webpack_require__((__webpack_require__.s = "./src/js/app.js"));
    /******/
}
)(/************************************************************************/
/******/
{
    /***/
    "./node_modules/bad-words/lib/badwords.js": /*!************************************************!*\
  !*** ./node_modules/bad-words/lib/badwords.js ***!
  \************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        const localList = __webpack_require__(/*! ./lang.json */
        "./node_modules/bad-words/lib/lang.json").words;
        const baseList = __webpack_require__(/*! badwords-list */
        "./node_modules/badwords-list/lib/index.js").array;
        class Filter {
            /**
                     * Filter constructor.
                     * @constructor
                     * @param {object} options - Filter instance options
                     * @param {boolean} options.emptyList - Instantiate filter with no blacklist
                     * @param {array} options.list - Instantiate filter with custom list
                     * @param {string} options.placeHolder - Character used to replace profane words.
                     * @param {string} options.regex - Regular expression used to sanitize words before comparing them to blacklist.
                     * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.
                     */
            constructor(options={}) {
                Object.assign(this, {
                    list: (options.emptyList && []) || Array.prototype.concat.apply(localList, [baseList, options.list || [], ]),
                    exclude: options.exclude || [],
                    placeHolder: options.placeHolder || "*",
                    regex: options.regex || /[^a-zA-Z0-9|\$|\@]|\^/g,
                    replaceRegex: options.replaceRegex || /\w/g,
                });
            }
            /**
                     * Determine if a string contains profane language.
                     * @param {string} string - String to evaluate for profanity.
                     */
            isProfane(string) {
                return (this.list.filter((word)=>{
                    const wordExp = new RegExp(`\\b ${word.replace(/(\W)/g, "\\$1")}\\b`,"gi");
                    return (!this.exclude.includes(word.toLowerCase()) && wordExp.test(string));
                }
                ).length > 0 || false);
            }
            /**
                     * Replace a word with placeHolder characters;
                     * @param {string} string - String to replace.
                     */
            replaceWord(string) {
                return string.replace(this.regex, "").replace(this.replaceRegex, this.placeHolder);
            }
            /**
                     * Evaluate a string for profanity and return an edited version.
                     * @param {string} string - Sentence to filter.
                     */
            clean(string) {
                return string.split(/\b/).map((word)=>{
                    return this.isProfane(word) ? this.replaceWord(word) : word;
                }
                ).join("");
            }
            /**
                     * Add word(s) to blacklist filter / remove words from whitelist filter
                     * @param {...string} word - Word(s) to add to blacklist
                     */
            addWords() {
                let words = Array.from(arguments);
                this.list.push(...words);
                words.map((word)=>word.toLowerCase()).forEach((word)=>{
                    if (this.exclude.includes(word)) {
                        this.exclude.splice(this.exclude.indexOf(word), 1);
                    }
                }
                );
            }
            /**
                     * Add words to whitelist filter
                     * @param {...string} word - Word(s) to add to whitelist.
                     */
            removeWords() {
                this.exclude.push(...Array.from(arguments).map((word)=>word.toLowerCase()));
            }
        }
        module.exports = Filter;
        /***/
    },
    /***/
    "./node_modules/bad-words/lib/lang.json": /*!**********************************************!*\
  !*** ./node_modules/bad-words/lib/lang.json ***!
  \**********************************************/
    /*! exports provided: words, default */
    /***/
    function(module) {
        module.exports = {
            words: ["ahole", "anus", "ash0le", "ash0les", "asholes", "ass", "Ass Monkey", "Assface", "assh0le", "assh0lez", "asshole", "assholes", "assholz", "asswipe", "azzhole", "bassterds", "bastard", "bastards", "bastardz", "basterds", "basterdz", "Biatch", "bitch", "bitches", "Blow Job", "boffing", "butthole", "buttwipe", "c0ck", "c0cks", "c0k", "Carpet Muncher", "cawk", "cawks", "Clit", "cnts", "cntz", "cock", "cockhead", "cock-head", "cocks", "CockSucker", "cock-sucker", "crap", "cum", "cunt", "cunts", "cuntz", "dick", "dild0", "dild0s", "dildo", "dildos", "dilld0", "dilld0s", "dominatricks", "dominatrics", "dominatrix", "dyke", "enema", "f u c k", "f u c k e r", "fag", "fag1t", "faget", "fagg1t", "faggit", "faggot", "fagg0t", "fagit", "fags", "fagz", "faig", "faigs", "fart", "flipping the bird", "fuck", "fucker", "fuckin", "fucking", "fucks", "Fudge Packer", "fuk", "Fukah", "Fuken", "fuker", "Fukin", "Fukk", "Fukkah", "Fukken", "Fukker", "Fukkin", "g00k", "God-damned", "h00r", "h0ar", "h0re", "hells", "hoar", "hoor", "hoore", "jackoff", "jap", "japs", "jerk-off", "jisim", "jiss", "jizm", "jizz", "knob", "knobs", "knobz", "kunt", "kunts", "kuntz", "Lezzian", "Lipshits", "Lipshitz", "masochist", "masokist", "massterbait", "masstrbait", "masstrbate", "masterbaiter", "masterbate", "masterbates", "Motha Fucker", "Motha Fuker", "Motha Fukkah", "Motha Fukker", "Mother Fucker", "Mother Fukah", "Mother Fuker", "Mother Fukkah", "Mother Fukker", "mother-fucker", "Mutha Fucker", "Mutha Fukah", "Mutha Fuker", "Mutha Fukkah", "Mutha Fukker", "n1gr", "nastt", "nigger;", "nigur;", "niiger;", "niigr;", "orafis", "orgasim;", "orgasm", "orgasum", "oriface", "orifice", "orifiss", "packi", "packie", "packy", "paki", "pakie", "paky", "pecker", "peeenus", "peeenusss", "peenus", "peinus", "pen1s", "penas", "penis", "penis-breath", "penus", "penuus", "Phuc", "Phuck", "Phuk", "Phuker", "Phukker", "polac", "polack", "polak", "Poonani", "pr1c", "pr1ck", "pr1k", "pusse", "pussee", "pussy", "puuke", "puuker", "queer", "queers", "queerz", "qweers", "qweerz", "qweir", "recktum", "rectum", "retard", "sadist", "scank", "schlong", "screwing", "semen", "sex", "sexy", "Sh!t", "sh1t", "sh1ter", "sh1ts", "sh1tter", "sh1tz", "shit", "shits", "shitter", "Shitty", "Shity", "shitz", "Shyt", "Shyte", "Shytty", "Shyty", "skanck", "skank", "skankee", "skankey", "skanks", "Skanky", "slag", "slut", "sluts", "Slutty", "slutz", "son-of-a-bitch", "tit", "turd", "va1jina", "vag1na", "vagiina", "vagina", "vaj1na", "vajina", "vullva", "vulva", "w0p", "wh00r", "wh0re", "whore", "xrated", "xxx", "b!+ch", "bitch", "blowjob", "clit", "arschloch", "fuck", "shit", "ass", "asshole", "b!tch", "b17ch", "b1tch", "bastard", "bi+ch", "boiolas", "buceta", "c0ck", "cawk", "chink", "cipa", "clits", "cock", "cum", "cunt", "dildo", "dirsa", "ejakulate", "fatass", "fcuk", "fuk", "fux0r", "hoer", "hore", "jism", "kawk", "l3itch", "l3i+ch", "lesbian", "masturbate", "masterbat*", "masterbat3", "motherfucker", "s.o.b.", "mofo", "nazi", "nigga", "nigger", "nutsack", "phuck", "pimpis", "pusse", "pussy", "scrotum", "sh!t", "shemale", "shi+", "sh!+", "slut", "smut", "teets", "tits", "boobs", "b00bs", "teez", "testical", "testicle", "titt", "w00se", "jackoff", "wank", "whoar", "whore", "*damn", "*dyke", "*fuck*", "*shit*", "@$$", "amcik", "andskota", "arse*", "assrammer", "ayir", "bi7ch", "bitch*", "bollock*", "breasts", "butt-pirate", "cabron", "cazzo", "chraa", "chuj", "Cock*", "cunt*", "d4mn", "daygo", "dego", "dick*", "dike*", "dupa", "dziwka", "ejackulate", "Ekrem*", "Ekto", "enculer", "faen", "fag*", "fanculo", "fanny", "feces", "feg", "Felcher", "ficken", "fitt*", "Flikker", "foreskin", "Fotze", "Fu(*", "fuk*", "futkretzn", "gook", "guiena", "h0r", "h4x0r", "hell", "helvete", "hoer*", "honkey", "Huevon", "hui", "injun", "jizz", "kanker*", "kike", "klootzak", "kraut", "knulle", "kuk", "kuksuger", "Kurac", "kurwa", "kusi*", "kyrpa*", "lesbo", "mamhoon", "masturbat*", "merd*", "mibun", "monkleigh", "mouliewop", "muie", "mulkku", "muschi", "nazis", "nepesaurio", "nigger*", "orospu", "paska*", "perse", "picka", "pierdol*", "pillu*", "pimmel", "piss*", "pizda", "poontsee", "poop", "porn", "p0rn", "pr0n", "preteen", "pula", "pule", "puta", "puto", "qahbeh", "queef*", "rautenberg", "schaffer", "scheiss*", "schlampe", "schmuck", "screw", "sh!t*", "sharmuta", "sharmute", "shipal", "shiz", "skribz", "skurwysyn", "sphencter", "spic", "spierdalaj", "splooge", "suka", "b00b*", "testicle*", "titt*", "twat", "vittu", "wank*", "wetback*", "wichser", "wop*", "yed", "zabourah", ],
        };
        /***/
    },
    /***/
    "./node_modules/badwords-list/lib/array.js": /*!*************************************************!*\
  !*** ./node_modules/badwords-list/lib/array.js ***!
  \*************************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        module.exports = ["4r5e", "5h1t", "5hit", "a55", "anal", "anus", "ar5e", "arrse", "arse", "ass", "ass-fucker", "asses", "assfucker", "assfukka", "asshole", "assholes", "asswhole", "a_s_s", "b!tch", "b00bs", "b17ch", "b1tch", "ballbag", "balls", "ballsack", "bastard", "beastial", "beastiality", "bellend", "bestial", "bestiality", "bi+ch", "biatch", "bitch", "bitcher", "bitchers", "bitches", "bitchin", "bitching", "bloody", "blow job", "blowjob", "blowjobs", "boiolas", "bollock", "bollok", "boner", "boob", "boobs", "booobs", "boooobs", "booooobs", "booooooobs", "breasts", "buceta", "bugger", "bum", "bunny fucker", "butt", "butthole", "buttmuch", "buttplug", "c0ck", "c0cksucker", "carpet muncher", "cawk", "chink", "cipa", "cl1t", "clit", "clitoris", "clits", "cnut", "cock", "cock-sucker", "cockface", "cockhead", "cockmunch", "cockmuncher", "cocks", "cocksuck", "cocksucked", "cocksucker", "cocksucking", "cocksucks", "cocksuka", "cocksukka", "cok", "cokmuncher", "coksucka", "coon", "cox", "crap", "cum", "cummer", "cumming", "cums", "cumshot", "cunilingus", "cunillingus", "cunnilingus", "cunt", "cuntlick", "cuntlicker", "cuntlicking", "cunts", "cyalis", "cyberfuc", "cyberfuck", "cyberfucked", "cyberfucker", "cyberfuckers", "cyberfucking", "d1ck", "damn", "dick", "dickhead", "dildo", "dildos", "dink", "dinks", "dirsa", "dlck", "dog-fucker", "doggin", "dogging", "donkeyribber", "doosh", "duche", "dyke", "ejaculate", "ejaculated", "ejaculates", "ejaculating", "ejaculatings", "ejaculation", "ejakulate", "f u c k", "f u c k e r", "f4nny", "fag", "fagging", "faggitt", "faggot", "faggs", "fagot", "fagots", "fags", "fanny", "fannyflaps", "fannyfucker", "fanyy", "fatass", "fcuk", "fcuker", "fcuking", "feck", "fecker", "felching", "fellate", "fellatio", "fingerfuck", "fingerfucked", "fingerfucker", "fingerfuckers", "fingerfucking", "fingerfucks", "fistfuck", "fistfucked", "fistfucker", "fistfuckers", "fistfucking", "fistfuckings", "fistfucks", "flange", "fook", "fooker", "fuck", "fucka", "fucked", "fucker", "fuckers", "fuckhead", "fuckheads", "fuckin", "fucking", "fuckings", "fuckingshitmotherfucker", "fuckme", "fucks", "fuckwhit", "fuckwit", "fudge packer", "fudgepacker", "fuk", "fuker", "fukker", "fukkin", "fuks", "fukwhit", "fukwit", "fux", "fux0r", "f_u_c_k", "gangbang", "gangbanged", "gangbangs", "gaylord", "gaysex", "goatse", "God", "god-dam", "god-damned", "goddamn", "goddamned", "hardcoresex", "hell", "heshe", "hoar", "hoare", "hoer", "homo", "hore", "horniest", "horny", "hotsex", "jack-off", "jackoff", "jap", "jerk-off", "jism", "jiz", "jizm", "jizz", "kawk", "knob", "knobead", "knobed", "knobend", "knobhead", "knobjocky", "knobjokey", "kock", "kondum", "kondums", "kum", "kummer", "kumming", "kums", "kunilingus", "l3i+ch", "l3itch", "labia", "lust", "lusting", "m0f0", "m0fo", "m45terbate", "ma5terb8", "ma5terbate", "masochist", "master-bate", "masterb8", "masterbat*", "masterbat3", "masterbate", "masterbation", "masterbations", "masturbate", "mo-fo", "mof0", "mofo", "mothafuck", "mothafucka", "mothafuckas", "mothafuckaz", "mothafucked", "mothafucker", "mothafuckers", "mothafuckin", "mothafucking", "mothafuckings", "mothafucks", "mother fucker", "motherfuck", "motherfucked", "motherfucker", "motherfuckers", "motherfuckin", "motherfucking", "motherfuckings", "motherfuckka", "motherfucks", "muff", "mutha", "muthafecker", "muthafuckker", "muther", "mutherfucker", "n1gga", "n1gger", "nazi", "nigg3r", "nigg4h", "nigga", "niggah", "niggas", "niggaz", "nigger", "niggers", "nob", "nob jokey", "nobhead", "nobjocky", "nobjokey", "numbnuts", "nutsack", "orgasim", "orgasims", "orgasm", "orgasms", "p0rn", "pawn", "pecker", "penis", "penisfucker", "phonesex", "phuck", "phuk", "phuked", "phuking", "phukked", "phukking", "phuks", "phuq", "pigfucker", "pimpis", "piss", "pissed", "pisser", "pissers", "pisses", "pissflaps", "pissin", "pissing", "pissoff", "poop", "porn", "porno", "pornography", "pornos", "prick", "pricks", "pron", "pube", "pusse", "pussi", "pussies", "pussy", "pussys", "rectum", "retard", "rimjaw", "rimming", "s hit", "s.o.b.", "sadist", "schlong", "screwing", "scroat", "scrote", "scrotum", "semen", "sex", "sh!+", "sh!t", "sh1t", "shag", "shagger", "shaggin", "shagging", "shemale", "shi+", "shit", "shitdick", "shite", "shited", "shitey", "shitfuck", "shitfull", "shithead", "shiting", "shitings", "shits", "shitted", "shitter", "shitters", "shitting", "shittings", "shitty", "skank", "slut", "sluts", "smegma", "smut", "snatch", "son-of-a-bitch", "spac", "spunk", "s_h_i_t", "t1tt1e5", "t1tties", "teets", "teez", "testical", "testicle", "tit", "titfuck", "tits", "titt", "tittie5", "tittiefucker", "titties", "tittyfuck", "tittywank", "titwank", "tosser", "turd", "tw4t", "twat", "twathead", "twatty", "twunt", "twunter", "v14gra", "v1gra", "vagina", "viagra", "vulva", "w00se", "wang", "wank", "wanker", "wanky", "whoar", "whore", "willies", "willy", "xrated", "xxx", ];
        /***/
    },
    /***/
    "./node_modules/badwords-list/lib/index.js": /*!*************************************************!*\
  !*** ./node_modules/badwords-list/lib/index.js ***!
  \*************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            object: __webpack_require__(/*! ./object */
            "./node_modules/badwords-list/lib/object.js"),
            array: __webpack_require__(/*! ./array */
            "./node_modules/badwords-list/lib/array.js"),
            regex: __webpack_require__(/*! ./regexp */
            "./node_modules/badwords-list/lib/regexp.js"),
        };
        /***/
    },
    /***/
    "./node_modules/badwords-list/lib/object.js": /*!**************************************************!*\
  !*** ./node_modules/badwords-list/lib/object.js ***!
  \**************************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        module.exports = {
            "4r5e": 1,
            "5h1t": 1,
            "5hit": 1,
            a55: 1,
            anal: 1,
            anus: 1,
            ar5e: 1,
            arrse: 1,
            arse: 1,
            ass: 1,
            "ass-fucker": 1,
            asses: 1,
            assfucker: 1,
            assfukka: 1,
            asshole: 1,
            assholes: 1,
            asswhole: 1,
            a_s_s: 1,
            "b!tch": 1,
            b00bs: 1,
            b17ch: 1,
            b1tch: 1,
            ballbag: 1,
            balls: 1,
            ballsack: 1,
            bastard: 1,
            beastial: 1,
            beastiality: 1,
            bellend: 1,
            bestial: 1,
            bestiality: 1,
            "bi+ch": 1,
            biatch: 1,
            bitch: 1,
            bitcher: 1,
            bitchers: 1,
            bitches: 1,
            bitchin: 1,
            bitching: 1,
            bloody: 1,
            "blow job": 1,
            blowjob: 1,
            blowjobs: 1,
            boiolas: 1,
            bollock: 1,
            bollok: 1,
            boner: 1,
            boob: 1,
            boobs: 1,
            booobs: 1,
            boooobs: 1,
            booooobs: 1,
            booooooobs: 1,
            breasts: 1,
            buceta: 1,
            bugger: 1,
            bum: 1,
            "bunny fucker": 1,
            butt: 1,
            butthole: 1,
            buttmuch: 1,
            buttplug: 1,
            c0ck: 1,
            c0cksucker: 1,
            "carpet muncher": 1,
            cawk: 1,
            chink: 1,
            cipa: 1,
            cl1t: 1,
            clit: 1,
            clitoris: 1,
            clits: 1,
            cnut: 1,
            cock: 1,
            "cock-sucker": 1,
            cockface: 1,
            cockhead: 1,
            cockmunch: 1,
            cockmuncher: 1,
            cocks: 1,
            cocksuck: 1,
            cocksucked: 1,
            cocksucker: 1,
            cocksucking: 1,
            cocksucks: 1,
            cocksuka: 1,
            cocksukka: 1,
            cok: 1,
            cokmuncher: 1,
            coksucka: 1,
            coon: 1,
            cox: 1,
            crap: 1,
            cum: 1,
            cummer: 1,
            cumming: 1,
            cums: 1,
            cumshot: 1,
            cunilingus: 1,
            cunillingus: 1,
            cunnilingus: 1,
            cunt: 1,
            cuntlick: 1,
            cuntlicker: 1,
            cuntlicking: 1,
            cunts: 1,
            cyalis: 1,
            cyberfuc: 1,
            cyberfuck: 1,
            cyberfucked: 1,
            cyberfucker: 1,
            cyberfuckers: 1,
            cyberfucking: 1,
            d1ck: 1,
            damn: 1,
            dick: 1,
            dickhead: 1,
            dildo: 1,
            dildos: 1,
            dink: 1,
            dinks: 1,
            dirsa: 1,
            dlck: 1,
            "dog-fucker": 1,
            doggin: 1,
            dogging: 1,
            donkeyribber: 1,
            doosh: 1,
            duche: 1,
            dyke: 1,
            ejaculate: 1,
            ejaculated: 1,
            ejaculates: 1,
            ejaculating: 1,
            ejaculatings: 1,
            ejaculation: 1,
            ejakulate: 1,
            "f u c k": 1,
            "f u c k e r": 1,
            f4nny: 1,
            fag: 1,
            fagging: 1,
            faggitt: 1,
            faggot: 1,
            faggs: 1,
            fagot: 1,
            fagots: 1,
            fags: 1,
            fanny: 1,
            fannyflaps: 1,
            fannyfucker: 1,
            fanyy: 1,
            fatass: 1,
            fcuk: 1,
            fcuker: 1,
            fcuking: 1,
            feck: 1,
            fecker: 1,
            felching: 1,
            fellate: 1,
            fellatio: 1,
            fingerfuck: 1,
            fingerfucked: 1,
            fingerfucker: 1,
            fingerfuckers: 1,
            fingerfucking: 1,
            fingerfucks: 1,
            fistfuck: 1,
            fistfucked: 1,
            fistfucker: 1,
            fistfuckers: 1,
            fistfucking: 1,
            fistfuckings: 1,
            fistfucks: 1,
            flange: 1,
            fook: 1,
            fooker: 1,
            fuck: 1,
            fucka: 1,
            fucked: 1,
            fucker: 1,
            fuckers: 1,
            fuckhead: 1,
            fuckheads: 1,
            fuckin: 1,
            fucking: 1,
            fuckings: 1,
            fuckingshitmotherfucker: 1,
            fuckme: 1,
            fucks: 1,
            fuckwhit: 1,
            fuckwit: 1,
            "fudge packer": 1,
            fudgepacker: 1,
            fuk: 1,
            fuker: 1,
            fukker: 1,
            fukkin: 1,
            fuks: 1,
            fukwhit: 1,
            fukwit: 1,
            fux: 1,
            fux0r: 1,
            f_u_c_k: 1,
            gangbang: 1,
            gangbanged: 1,
            gangbangs: 1,
            gaylord: 1,
            gaysex: 1,
            goatse: 1,
            God: 1,
            "god-dam": 1,
            "god-damned": 1,
            goddamn: 1,
            goddamned: 1,
            hardcoresex: 1,
            hell: 1,
            heshe: 1,
            hoar: 1,
            hoare: 1,
            hoer: 1,
            homo: 1,
            hore: 1,
            horniest: 1,
            horny: 1,
            hotsex: 1,
            "jack-off": 1,
            jackoff: 1,
            jap: 1,
            "jerk-off": 1,
            jism: 1,
            jiz: 1,
            jizm: 1,
            jizz: 1,
            kawk: 1,
            knob: 1,
            knobead: 1,
            knobed: 1,
            knobend: 1,
            knobhead: 1,
            knobjocky: 1,
            knobjokey: 1,
            kock: 1,
            kondum: 1,
            kondums: 1,
            kum: 1,
            kummer: 1,
            kumming: 1,
            kums: 1,
            kunilingus: 1,
            "l3i+ch": 1,
            l3itch: 1,
            labia: 1,
            lust: 1,
            lusting: 1,
            m0f0: 1,
            m0fo: 1,
            m45terbate: 1,
            ma5terb8: 1,
            ma5terbate: 1,
            masochist: 1,
            "master-bate": 1,
            masterb8: 1,
            "masterbat*": 1,
            masterbat3: 1,
            masterbate: 1,
            masterbation: 1,
            masterbations: 1,
            masturbate: 1,
            "mo-fo": 1,
            mof0: 1,
            mofo: 1,
            mothafuck: 1,
            mothafucka: 1,
            mothafuckas: 1,
            mothafuckaz: 1,
            mothafucked: 1,
            mothafucker: 1,
            mothafuckers: 1,
            mothafuckin: 1,
            mothafucking: 1,
            mothafuckings: 1,
            mothafucks: 1,
            "mother fucker": 1,
            motherfuck: 1,
            motherfucked: 1,
            motherfucker: 1,
            motherfuckers: 1,
            motherfuckin: 1,
            motherfucking: 1,
            motherfuckings: 1,
            motherfuckka: 1,
            motherfucks: 1,
            muff: 1,
            mutha: 1,
            muthafecker: 1,
            muthafuckker: 1,
            muther: 1,
            mutherfucker: 1,
            n1gga: 1,
            n1gger: 1,
            nazi: 1,
            nigg3r: 1,
            nigg4h: 1,
            nigga: 1,
            niggah: 1,
            niggas: 1,
            niggaz: 1,
            nigger: 1,
            niggers: 1,
            nob: 1,
            "nob jokey": 1,
            nobhead: 1,
            nobjocky: 1,
            nobjokey: 1,
            numbnuts: 1,
            nutsack: 1,
            orgasim: 1,
            orgasims: 1,
            orgasm: 1,
            orgasms: 1,
            p0rn: 1,
            pawn: 1,
            pecker: 1,
            penis: 1,
            penisfucker: 1,
            phonesex: 1,
            phuck: 1,
            phuk: 1,
            phuked: 1,
            phuking: 1,
            phukked: 1,
            phukking: 1,
            phuks: 1,
            phuq: 1,
            pigfucker: 1,
            pimpis: 1,
            piss: 1,
            pissed: 1,
            pisser: 1,
            pissers: 1,
            pisses: 1,
            pissflaps: 1,
            pissin: 1,
            pissing: 1,
            pissoff: 1,
            poop: 1,
            porn: 1,
            porno: 1,
            pornography: 1,
            pornos: 1,
            prick: 1,
            pricks: 1,
            pron: 1,
            pube: 1,
            pusse: 1,
            pussi: 1,
            pussies: 1,
            pussy: 1,
            pussys: 1,
            rectum: 1,
            retard: 1,
            rimjaw: 1,
            rimming: 1,
            "s hit": 1,
            "s.o.b.": 1,
            sadist: 1,
            schlong: 1,
            screwing: 1,
            scroat: 1,
            scrote: 1,
            scrotum: 1,
            semen: 1,
            sex: 1,
            "sh!+": 1,
            "sh!t": 1,
            sh1t: 1,
            shag: 1,
            shagger: 1,
            shaggin: 1,
            shagging: 1,
            shemale: 1,
            "shi+": 1,
            shit: 1,
            shitdick: 1,
            shite: 1,
            shited: 1,
            shitey: 1,
            shitfuck: 1,
            shitfull: 1,
            shithead: 1,
            shiting: 1,
            shitings: 1,
            shits: 1,
            shitted: 1,
            shitter: 1,
            shitters: 1,
            shitting: 1,
            shittings: 1,
            shitty: 1,
            skank: 1,
            slut: 1,
            sluts: 1,
            smegma: 1,
            smut: 1,
            snatch: 1,
            "son-of-a-bitch": 1,
            spac: 1,
            spunk: 1,
            s_h_i_t: 1,
            t1tt1e5: 1,
            t1tties: 1,
            teets: 1,
            teez: 1,
            testical: 1,
            testicle: 1,
            tit: 1,
            titfuck: 1,
            tits: 1,
            titt: 1,
            tittie5: 1,
            tittiefucker: 1,
            titties: 1,
            tittyfuck: 1,
            tittywank: 1,
            titwank: 1,
            tosser: 1,
            turd: 1,
            tw4t: 1,
            twat: 1,
            twathead: 1,
            twatty: 1,
            twunt: 1,
            twunter: 1,
            v14gra: 1,
            v1gra: 1,
            vagina: 1,
            viagra: 1,
            vulva: 1,
            w00se: 1,
            wang: 1,
            wank: 1,
            wanker: 1,
            wanky: 1,
            whoar: 1,
            whore: 1,
            willies: 1,
            willy: 1,
            xrated: 1,
            xxx: 1,
        };
        /***/
    },
    /***/
    "./node_modules/badwords-list/lib/regexp.js": /*!**************************************************!*\
  !*** ./node_modules/badwords-list/lib/regexp.js ***!
  \**************************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        module.exports = /\b(4r5e|5h1t|5hit|a55|anal|anus|ar5e|arrse|arse|ass|ass-fucker|asses|assfucker|assfukka|asshole|assholes|asswhole|a_s_s|b!tch|b00bs|b17ch|b1tch|ballbag|balls|ballsack|bastard|beastial|beastiality|bellend|bestial|bestiality|bi\+ch|biatch|bitch|bitcher|bitchers|bitches|bitchin|bitching|bloody|blow job|blowjob|blowjobs|boiolas|bollock|bollok|boner|boob|boobs|booobs|boooobs|booooobs|booooooobs|breasts|buceta|bugger|bum|bunny fucker|butt|butthole|buttmuch|buttplug|c0ck|c0cksucker|carpet muncher|cawk|chink|cipa|cl1t|clit|clitoris|clits|cnut|cock|cock-sucker|cockface|cockhead|cockmunch|cockmuncher|cocks|cocksuck|cocksucked|cocksucker|cocksucking|cocksucks|cocksuka|cocksukka|cok|cokmuncher|coksucka|coon|cox|crap|cum|cummer|cumming|cums|cumshot|cunilingus|cunillingus|cunnilingus|cunt|cuntlick|cuntlicker|cuntlicking|cunts|cyalis|cyberfuc|cyberfuck|cyberfucked|cyberfucker|cyberfuckers|cyberfucking|d1ck|damn|dick|dickhead|dildo|dildos|dink|dinks|dirsa|dlck|dog-fucker|doggin|dogging|donkeyribber|doosh|duche|dyke|ejaculate|ejaculated|ejaculates|ejaculating|ejaculatings|ejaculation|ejakulate|f u c k|f u c k e r|f4nny|fag|fagging|faggitt|faggot|faggs|fagot|fagots|fags|fanny|fannyflaps|fannyfucker|fanyy|fatass|fcuk|fcuker|fcuking|feck|fecker|felching|fellate|fellatio|fingerfuck|fingerfucked|fingerfucker|fingerfuckers|fingerfucking|fingerfucks|fistfuck|fistfucked|fistfucker|fistfuckers|fistfucking|fistfuckings|fistfucks|flange|fook|fooker|fuck|fucka|fucked|fucker|fuckers|fuckhead|fuckheads|fuckin|fucking|fuckings|fuckingshitmotherfucker|fuckme|fucks|fuckwhit|fuckwit|fudge packer|fudgepacker|fuk|fuker|fukker|fukkin|fuks|fukwhit|fukwit|fux|fux0r|f_u_c_k|gangbang|gangbanged|gangbangs|gaylord|gaysex|goatse|God|god-dam|god-damned|goddamn|goddamned|hardcoresex|hell|heshe|hoar|hoare|hoer|homo|hore|horniest|horny|hotsex|jack-off|jackoff|jap|jerk-off|jism|jiz|jizm|jizz|kawk|knob|knobead|knobed|knobend|knobhead|knobjocky|knobjokey|kock|kondum|kondums|kum|kummer|kumming|kums|kunilingus|l3i\+ch|l3itch|labia|lust|lusting|m0f0|m0fo|m45terbate|ma5terb8|ma5terbate|masochist|master-bate|masterb8|masterbat*|masterbat3|masterbate|masterbation|masterbations|masturbate|mo-fo|mof0|mofo|mothafuck|mothafucka|mothafuckas|mothafuckaz|mothafucked|mothafucker|mothafuckers|mothafuckin|mothafucking|mothafuckings|mothafucks|mother fucker|motherfuck|motherfucked|motherfucker|motherfuckers|motherfuckin|motherfucking|motherfuckings|motherfuckka|motherfucks|muff|mutha|muthafecker|muthafuckker|muther|mutherfucker|n1gga|n1gger|nazi|nigg3r|nigg4h|nigga|niggah|niggas|niggaz|nigger|niggers|nob|nob jokey|nobhead|nobjocky|nobjokey|numbnuts|nutsack|orgasim|orgasims|orgasm|orgasms|p0rn|pawn|pecker|penis|penisfucker|phonesex|phuck|phuk|phuked|phuking|phukked|phukking|phuks|phuq|pigfucker|pimpis|piss|pissed|pisser|pissers|pisses|pissflaps|pissin|pissing|pissoff|poop|porn|porno|pornography|pornos|prick|pricks|pron|pube|pusse|pussi|pussies|pussy|pussys|rectum|retard|rimjaw|rimming|s hit|s.o.b.|sadist|schlong|screwing|scroat|scrote|scrotum|semen|sex|sh!\+|sh!t|sh1t|shag|shagger|shaggin|shagging|shemale|shi\+|shit|shitdick|shite|shited|shitey|shitfuck|shitfull|shithead|shiting|shitings|shits|shitted|shitter|shitters|shitting|shittings|shitty|skank|slut|sluts|smegma|smut|snatch|son-of-a-bitch|spac|spunk|s_h_i_t|t1tt1e5|t1tties|teets|teez|testical|testicle|tit|titfuck|tits|titt|tittie5|tittiefucker|titties|tittyfuck|tittywank|titwank|tosser|turd|tw4t|twat|twathead|twatty|twunt|twunter|v14gra|v1gra|vagina|viagra|vulva|w00se|wang|wank|wanker|wanky|whoar|whore|willies|willy|xrated|xxx)\b/gi;
        /***/
    },
    /***/
    "./node_modules/base64-js/index.js": /*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
        }
        // Support decoding URL-safe base64 strings, as Node.js does.
        // See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;

        function getLens(b64) {
            var len = b64.length;
            if (len % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
            }
            // Trim off extra bytes after placeholder bytes are found
            // See: https://github.com/beatgammit/base64-js/issues/42
            var validLen = b64.indexOf("=");
            if (validLen === -1)
                validLen = len;
            var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
            return [validLen, placeHoldersLen];
        }
        // base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function _byteLength(b64, validLen, placeHoldersLen) {
            return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            // if there are placeholders, only get up to the last complete 4 chars
            var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i;
            for (i = 0; i < len; i += 4) {
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
                arr[curByte++] = (tmp >> 16) & 0xff;
                arr[curByte++] = (tmp >> 8) & 0xff;
                arr[curByte++] = tmp & 0xff;
            }
            if (placeHoldersLen === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
                arr[curByte++] = tmp & 0xff;
            }
            if (placeHoldersLen === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
                arr[curByte++] = (tmp >> 8) & 0xff;
                arr[curByte++] = tmp & 0xff;
            }
            return arr;
        }

        function tripletToBase64(num) {
            return (lookup[(num >> 18) & 0x3f] + lookup[(num >> 12) & 0x3f] + lookup[(num >> 6) & 0x3f] + lookup[num & 0x3f]);
        }

        function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for (var i = start; i < end; i += 3) {
                tmp = ((uint8[i] << 16) & 0xff0000) + ((uint8[i + 1] << 8) & 0xff00) + (uint8[i + 2] & 0xff);
                output.push(tripletToBase64(tmp));
            }
            return output.join("");
        }

        function fromByteArray(uint8) {
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3;
            // if we have 1 byte left, pad 2 bytes
            var parts = [];
            var maxChunkLength = 16383;
            // must be multiple of 3
            // go through the array every three bytes, we'll deal with trailing stuff later
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
            }
            // pad the end with zeros, but make sure to not forget the extra bytes
            if (extraBytes === 1) {
                tmp = uint8[len - 1];
                parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                parts.push(lookup[tmp >> 10] + lookup[(tmp >> 4) & 0x3f] + lookup[(tmp << 2) & 0x3f] + "=");
            }
            return parts.join("");
        }
        /***/
    },
    /***/
    "./node_modules/buffer/index.js": /*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */
        (function(global) {
            /*!
                     * The buffer module from node.js, for the browser.
                     *
                     * @author   Feross Aboukhadijeh <http://feross.org>
                     * @license  MIT
                     */
            /* eslint-disable no-proto */
            var base64 = __webpack_require__(/*! base64-js */
            "./node_modules/base64-js/index.js");
            var ieee754 = __webpack_require__(/*! ieee754 */
            "./node_modules/ieee754/index.js");
            var isArray = __webpack_require__(/*! isarray */
            "./node_modules/buffer/node_modules/isarray/index.js");
            exports.Buffer = Buffer;
            exports.SlowBuffer = SlowBuffer;
            exports.INSPECT_MAX_BYTES = 50;
            /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
            Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
            /*
                     * Export kMaxLength after typed array support is determined.
                     */
            exports.kMaxLength = kMaxLength();

            function typedArraySupport() {
                try {
                    var arr = new Uint8Array(1);
                    arr.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42;
                        },
                    };
                    return (arr.foo() === 42 && // typed array instances can be augmented
                    typeof arr.subarray === "function" && // chrome 9-10 lack `subarray`
                    arr.subarray(1, 1).byteLength === 0);
                    // ie10 has broken `subarray`
                } catch (e) {
                    return false;
                }
            }

            function kMaxLength() {
                return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
            }

            function createBuffer(that, length) {
                if (kMaxLength() < length) {
                    throw new RangeError("Invalid typed array length");
                }
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    // Return an augmented `Uint8Array` instance, for best performance
                    that = new Uint8Array(length);
                    that.__proto__ = Buffer.prototype;
                } else {
                    // Fallback: Return an object instance of the Buffer class
                    if (that === null) {
                        that = new Buffer(length);
                    }
                    that.length = length;
                }
                return that;
            }
            /**
                     * The Buffer constructor returns instances of `Uint8Array` that have their
                     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
                     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
                     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
                     * returns a single octet.
                     *
                     * The `Uint8Array` prototype remains unmodified.
                     */
            function Buffer(arg, encodingOrOffset, length) {
                if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                    return new Buffer(arg,encodingOrOffset,length);
                }
                // Common case.
                if (typeof arg === "number") {
                    if (typeof encodingOrOffset === "string") {
                        throw new Error("If encoding is specified then the first argument must be a string");
                    }
                    return allocUnsafe(this, arg);
                }
                return from(this, arg, encodingOrOffset, length);
            }
            Buffer.poolSize = 8192;
            // not used by this implementation
            // TODO: Legacy, not needed anymore. Remove in next major version.
            Buffer._augment = function(arr) {
                arr.__proto__ = Buffer.prototype;
                return arr;
            }
            ;

            function from(that, value, encodingOrOffset, length) {
                if (typeof value === "number") {
                    throw new TypeError('"value" argument must not be a number');
                }
                if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
                    return fromArrayBuffer(that, value, encodingOrOffset, length);
                }
                if (typeof value === "string") {
                    return fromString(that, value, encodingOrOffset);
                }
                return fromObject(that, value);
            }
            /**
                     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
                     * if value is a number.
                     * Buffer.from(str[, encoding])
                     * Buffer.from(array)
                     * Buffer.from(buffer)
                     * Buffer.from(arrayBuffer[, byteOffset[, length]])
                     **/
            Buffer.from = function(value, encodingOrOffset, length) {
                return from(null, value, encodingOrOffset, length);
            }
            ;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                Buffer.prototype.__proto__ = Uint8Array.prototype;
                Buffer.__proto__ = Uint8Array;
                if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
                    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
                    Object.defineProperty(Buffer, Symbol.species, {
                        value: null,
                        configurable: true,
                    });
                }
            }

            function assertSize(size) {
                if (typeof size !== "number") {
                    throw new TypeError('"size" argument must be a number');
                } else if (size < 0) {
                    throw new RangeError('"size" argument must not be negative');
                }
            }

            function alloc(that, size, fill, encoding) {
                assertSize(size);
                if (size <= 0) {
                    return createBuffer(that, size);
                }
                if (fill !== undefined) {
                    // Only pay attention to encoding if it's a string. This
                    // prevents accidentally sending in a number that would
                    // be interpretted as a start offset.
                    return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
                }
                return createBuffer(that, size);
            }
            /**
                     * Creates a new filled Buffer instance.
                     * alloc(size[, fill[, encoding]])
                     **/
            Buffer.alloc = function(size, fill, encoding) {
                return alloc(null, size, fill, encoding);
            }
            ;

            function allocUnsafe(that, size) {
                assertSize(size);
                that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
                if (!Buffer.TYPED_ARRAY_SUPPORT) {
                    for (var i = 0; i < size; ++i) {
                        that[i] = 0;
                    }
                }
                return that;
            }
            /**
                     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
                     * */
            Buffer.allocUnsafe = function(size) {
                return allocUnsafe(null, size);
            }
            ;
            /**
                     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
                     */
            Buffer.allocUnsafeSlow = function(size) {
                return allocUnsafe(null, size);
            }
            ;

            function fromString(that, string, encoding) {
                if (typeof encoding !== "string" || encoding === "") {
                    encoding = "utf8";
                }
                if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError('"encoding" must be a valid string encoding');
                }
                var length = byteLength(string, encoding) | 0;
                that = createBuffer(that, length);
                var actual = that.write(string, encoding);
                if (actual !== length) {
                    // Writing a hex string, for example, that contains invalid characters will
                    // cause everything after the first invalid character to be ignored. (e.g.
                    // 'abxxcd' will be treated as 'ab')
                    that = that.slice(0, actual);
                }
                return that;
            }

            function fromArrayLike(that, array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0;
                that = createBuffer(that, length);
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255;
                }
                return that;
            }

            function fromArrayBuffer(that, array, byteOffset, length) {
                array.byteLength;
                // this throws if `array` is not a valid ArrayBuffer
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError("'offset' is out of bounds");
                }
                if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError("'length' is out of bounds");
                }
                if (byteOffset === undefined && length === undefined) {
                    array = new Uint8Array(array);
                } else if (length === undefined) {
                    array = new Uint8Array(array,byteOffset);
                } else {
                    array = new Uint8Array(array,byteOffset,length);
                }
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    // Return an augmented `Uint8Array` instance, for best performance
                    that = array;
                    that.__proto__ = Buffer.prototype;
                } else {
                    // Fallback: Return an object instance of the Buffer class
                    that = fromArrayLike(that, array);
                }
                return that;
            }

            function fromObject(that, obj) {
                if (Buffer.isBuffer(obj)) {
                    var len = checked(obj.length) | 0;
                    that = createBuffer(that, len);
                    if (that.length === 0) {
                        return that;
                    }
                    obj.copy(that, 0, 0, len);
                    return that;
                }
                if (obj) {
                    if ((typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer) || "length"in obj) {
                        if (typeof obj.length !== "number" || isnan(obj.length)) {
                            return createBuffer(that, 0);
                        }
                        return fromArrayLike(that, obj);
                    }
                    if (obj.type === "Buffer" && isArray(obj.data)) {
                        return fromArrayLike(that, obj.data);
                    }
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
            }

            function checked(length) {
                // Note: cannot use `length < kMaxLength()` here because that fails when
                // length is NaN (which is otherwise coerced to zero.)
                if (length >= kMaxLength()) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes");
                }
                return length | 0;
            }

            function SlowBuffer(length) {
                if (+length != length) {
                    // eslint-disable-line eqeqeq
                    length = 0;
                }
                return Buffer.alloc(+length);
            }
            Buffer.isBuffer = function isBuffer(b) {
                return !!(b != null && b._isBuffer);
            }
            ;
            Buffer.compare = function compare(a, b) {
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError("Arguments must be Buffers");
                }
                if (a === b)
                    return 0;
                var x = a.length;
                var y = b.length;
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                        x = a[i];
                        y = b[i];
                        break;
                    }
                }
                if (x < y)
                    return -1;
                if (y < x)
                    return 1;
                return 0;
            }
            ;
            Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return true;
                default:
                    return false;
                }
            }
            ;
            Buffer.concat = function concat(list, length) {
                if (!isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (list.length === 0) {
                    return Buffer.alloc(0);
                }
                var i;
                if (length === undefined) {
                    length = 0;
                    for (i = 0; i < list.length; ++i) {
                        length += list[i].length;
                    }
                }
                var buffer = Buffer.allocUnsafe(length);
                var pos = 0;
                for (i = 0; i < list.length; ++i) {
                    var buf = list[i];
                    if (!Buffer.isBuffer(buf)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    buf.copy(buffer, pos);
                    pos += buf.length;
                }
                return buffer;
            }
            ;

            function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) {
                    return string.length;
                }
                if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                    return string.byteLength;
                }
                if (typeof string !== "string") {
                    string = "" + string;
                }
                var len = string.length;
                if (len === 0)
                    return 0;
                // Use a for loop to avoid recursion
                var loweredCase = false;
                for (; ; ) {
                    switch (encoding) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return len;
                    case "utf8":
                    case "utf-8":
                    case undefined:
                        return utf8ToBytes(string).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return len * 2;
                    case "hex":
                        return len >>> 1;
                    case "base64":
                        return base64ToBytes(string).length;
                    default:
                        if (loweredCase)
                            return utf8ToBytes(string).length;
                        // assume utf8
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;

            function slowToString(encoding, start, end) {
                var loweredCase = false;
                // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                // property of a typed array.
                // This behaves neither like String nor Uint8Array in that we set start/end
                // to their upper/lower bounds if the value passed is out of range.
                // undefined is handled specially as per ECMA-262 6th Edition,
                // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                if (start === undefined || start < 0) {
                    start = 0;
                }
                // Return early if start > this.length. Done here to prevent potential uint32
                // coercion fail below.
                if (start > this.length) {
                    return "";
                }
                if (end === undefined || end > this.length) {
                    end = this.length;
                }
                if (end <= 0) {
                    return "";
                }
                // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                end >>>= 0;
                start >>>= 0;
                if (end <= start) {
                    return "";
                }
                if (!encoding)
                    encoding = "utf8";
                while (true) {
                    switch (encoding) {
                    case "hex":
                        return hexSlice(this, start, end);
                    case "utf8":
                    case "utf-8":
                        return utf8Slice(this, start, end);
                    case "ascii":
                        return asciiSlice(this, start, end);
                    case "latin1":
                    case "binary":
                        return latin1Slice(this, start, end);
                    case "base64":
                        return base64Slice(this, start, end);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return utf16leSlice(this, start, end);
                    default:
                        if (loweredCase)
                            throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase();
                        loweredCase = true;
                    }
                }
            }
            // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
            // Buffer instances.
            Buffer.prototype._isBuffer = true;

            function swap(b, n, m) {
                var i = b[n];
                b[n] = b[m];
                b[m] = i;
            }
            Buffer.prototype.swap16 = function swap16() {
                var len = this.length;
                if (len % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for (var i = 0; i < len; i += 2) {
                    swap(this, i, i + 1);
                }
                return this;
            }
            ;
            Buffer.prototype.swap32 = function swap32() {
                var len = this.length;
                if (len % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for (var i = 0; i < len; i += 4) {
                    swap(this, i, i + 3);
                    swap(this, i + 1, i + 2);
                }
                return this;
            }
            ;
            Buffer.prototype.swap64 = function swap64() {
                var len = this.length;
                if (len % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for (var i = 0; i < len; i += 8) {
                    swap(this, i, i + 7);
                    swap(this, i + 1, i + 6);
                    swap(this, i + 2, i + 5);
                    swap(this, i + 3, i + 4);
                }
                return this;
            }
            ;
            Buffer.prototype.toString = function toString() {
                var length = this.length | 0;
                if (length === 0)
                    return "";
                if (arguments.length === 0)
                    return utf8Slice(this, 0, length);
                return slowToString.apply(this, arguments);
            }
            ;
            Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b))
                    throw new TypeError("Argument must be a Buffer");
                if (this === b)
                    return true;
                return Buffer.compare(this, b) === 0;
            }
            ;
            Buffer.prototype.inspect = function inspect() {
                var str = "";
                var max = exports.INSPECT_MAX_BYTES;
                if (this.length > 0) {
                    str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                    if (this.length > max)
                        str += " ... ";
                }
                return "<Buffer " + str + ">";
            }
            ;
            Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (!Buffer.isBuffer(target)) {
                    throw new TypeError("Argument must be a Buffer");
                }
                if (start === undefined) {
                    start = 0;
                }
                if (end === undefined) {
                    end = target ? target.length : 0;
                }
                if (thisStart === undefined) {
                    thisStart = 0;
                }
                if (thisEnd === undefined) {
                    thisEnd = this.length;
                }
                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError("out of range index");
                }
                if (thisStart >= thisEnd && start >= end) {
                    return 0;
                }
                if (thisStart >= thisEnd) {
                    return -1;
                }
                if (start >= end) {
                    return 1;
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if (this === target)
                    return 0;
                var x = thisEnd - thisStart;
                var y = end - start;
                var len = Math.min(x, y);
                var thisCopy = this.slice(thisStart, thisEnd);
                var targetCopy = target.slice(start, end);
                for (var i = 0; i < len; ++i) {
                    if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i];
                        y = targetCopy[i];
                        break;
                    }
                }
                if (x < y)
                    return -1;
                if (y < x)
                    return 1;
                return 0;
            }
            ;
            // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
            // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
            //
            // Arguments:
            // - buffer - a Buffer to search
            // - val - a string, Buffer, or number
            // - byteOffset - an index into `buffer`; will be clamped to an int32
            // - encoding - an optional encoding, relevant is val is a string
            // - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                // Empty buffer means no match
                if (buffer.length === 0)
                    return -1;
                // Normalize byteOffset
                if (typeof byteOffset === "string") {
                    encoding = byteOffset;
                    byteOffset = 0;
                } else if (byteOffset > 0x7fffffff) {
                    byteOffset = 0x7fffffff;
                } else if (byteOffset < -0x80000000) {
                    byteOffset = -0x80000000;
                }
                byteOffset = +byteOffset;
                // Coerce to Number.
                if (isNaN(byteOffset)) {
                    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                    byteOffset = dir ? 0 : buffer.length - 1;
                }
                // Normalize byteOffset: negative offsets start from the end of the buffer
                if (byteOffset < 0)
                    byteOffset = buffer.length + byteOffset;
                if (byteOffset >= buffer.length) {
                    if (dir)
                        return -1;
                    else
                        byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                    if (dir)
                        byteOffset = 0;
                    else
                        return -1;
                }
                // Normalize val
                if (typeof val === "string") {
                    val = Buffer.from(val, encoding);
                }
                // Finally, search either indexOf (if dir is true) or lastIndexOf
                if (Buffer.isBuffer(val)) {
                    // Special case: looking for empty string/buffer always fails
                    if (val.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                } else if (typeof val === "number") {
                    val = val & 0xff;
                    // Search for a byte value [0-255]
                    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
                        if (dir) {
                            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                        }
                    }
                    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                }
                throw new TypeError("val must be string, number or Buffer");
            }

            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1;
                var arrLength = arr.length;
                var valLength = val.length;
                if (encoding !== undefined) {
                    encoding = String(encoding).toLowerCase();
                    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                        if (arr.length < 2 || val.length < 2) {
                            return -1;
                        }
                        indexSize = 2;
                        arrLength /= 2;
                        valLength /= 2;
                        byteOffset /= 2;
                    }
                }

                function read(buf, i) {
                    if (indexSize === 1) {
                        return buf[i];
                    } else {
                        return buf.readUInt16BE(i * indexSize);
                    }
                }
                var i;
                if (dir) {
                    var foundIndex = -1;
                    for (i = byteOffset; i < arrLength; i++) {
                        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                            if (foundIndex === -1)
                                foundIndex = i;
                            if (i - foundIndex + 1 === valLength)
                                return foundIndex * indexSize;
                        } else {
                            if (foundIndex !== -1)
                                i -= i - foundIndex;
                            foundIndex = -1;
                        }
                    }
                } else {
                    if (byteOffset + valLength > arrLength)
                        byteOffset = arrLength - valLength;
                    for (i = byteOffset; i >= 0; i--) {
                        var found = true;
                        for (var j = 0; j < valLength; j++) {
                            if (read(arr, i + j) !== read(val, j)) {
                                found = false;
                                break;
                            }
                        }
                        if (found)
                            return i;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1;
            }
            ;
            Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            }
            ;
            Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            }
            ;

            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                var remaining = buf.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = Number(length);
                    if (length > remaining) {
                        length = remaining;
                    }
                }
                // must be an even number of digits
                var strLen = string.length;
                if (strLen % 2 !== 0)
                    throw new TypeError("Invalid hex string");
                if (length > strLen / 2) {
                    length = strLen / 2;
                }
                for (var i = 0; i < length; ++i) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16);
                    if (isNaN(parsed))
                        return i;
                    buf[offset + i] = parsed;
                }
                return i;
            }

            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            }

            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
            }

            function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length);
            }

            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
            }

            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            }
            Buffer.prototype.write = function write(string, offset, length, encoding) {
                // Buffer#write(string)
                if (offset === undefined) {
                    encoding = "utf8";
                    length = this.length;
                    offset = 0;
                    // Buffer#write(string, encoding)
                } else if (length === undefined && typeof offset === "string") {
                    encoding = offset;
                    length = this.length;
                    offset = 0;
                    // Buffer#write(string, offset[, length][, encoding])
                } else if (isFinite(offset)) {
                    offset = offset | 0;
                    if (isFinite(length)) {
                        length = length | 0;
                        if (encoding === undefined)
                            encoding = "utf8";
                    } else {
                        encoding = length;
                        length = undefined;
                    }
                    // legacy write(string, encoding, offset, length) - remove in v0.13
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var remaining = this.length - offset;
                if (length === undefined || length > remaining)
                    length = remaining;
                if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!encoding)
                    encoding = "utf8";
                var loweredCase = false;
                for (; ; ) {
                    switch (encoding) {
                    case "hex":
                        return hexWrite(this, string, offset, length);
                    case "utf8":
                    case "utf-8":
                        return utf8Write(this, string, offset, length);
                    case "ascii":
                        return asciiWrite(this, string, offset, length);
                    case "latin1":
                    case "binary":
                        return latin1Write(this, string, offset, length);
                    case "base64":
                        // Warning: maxLength not taken into account in base64Write
                        return base64Write(this, string, offset, length);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return ucs2Write(this, string, offset, length);
                    default:
                        if (loweredCase)
                            throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                }
            }
            ;
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0),
                };
            }
            ;

            function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf);
                } else {
                    return base64.fromByteArray(buf.slice(start, end));
                }
            }

            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                var res = [];
                var i = start;
                while (i < end) {
                    var firstByte = buf[i];
                    var codePoint = null;
                    var bytesPerSequence = firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;
                    if (i + bytesPerSequence <= end) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint;
                        switch (bytesPerSequence) {
                        case 1:
                            if (firstByte < 0x80) {
                                codePoint = firstByte;
                            }
                            break;
                        case 2:
                            secondByte = buf[i + 1];
                            if ((secondByte & 0xc0) === 0x80) {
                                tempCodePoint = ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
                                if (tempCodePoint > 0x7f) {
                                    codePoint = tempCodePoint;
                                }
                            }
                            break;
                        case 3:
                            secondByte = buf[i + 1];
                            thirdByte = buf[i + 2];
                            if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {
                                tempCodePoint = ((firstByte & 0xf) << 0xc) | ((secondByte & 0x3f) << 0x6) | (thirdByte & 0x3f);
                                if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {
                                    codePoint = tempCodePoint;
                                }
                            }
                            break;
                        case 4:
                            secondByte = buf[i + 1];
                            thirdByte = buf[i + 2];
                            fourthByte = buf[i + 3];
                            if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {
                                tempCodePoint = ((firstByte & 0xf) << 0x12) | ((secondByte & 0x3f) << 0xc) | ((thirdByte & 0x3f) << 0x6) | (fourthByte & 0x3f);
                                if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                                    codePoint = tempCodePoint;
                                }
                            }
                        }
                    }
                    if (codePoint === null) {
                        // we did not generate a valid codePoint so insert a
                        // replacement char (U+FFFD) and advance only 1 byte
                        codePoint = 0xfffd;
                        bytesPerSequence = 1;
                    } else if (codePoint > 0xffff) {
                        // encode to utf16 (surrogate pair dance)
                        codePoint -= 0x10000;
                        res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
                        codePoint = 0xdc00 | (codePoint & 0x3ff);
                    }
                    res.push(codePoint);
                    i += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
            }
            // Based on http://stackoverflow.com/a/22747272/680742, the browser with
            // the lowest limit is Chrome, with 0x10000 args.
            // We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000;

            function decodeCodePointsArray(codePoints) {
                var len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints);
                    // avoid extra slice()
                }
                // Decode in chunks to avoid "call stack size exceeded".
                var res = "";
                var i = 0;
                while (i < len) {
                    res += String.fromCharCode.apply(String, codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)));
                }
                return res;
            }

            function asciiSlice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i] & 0x7f);
                }
                return ret;
            }

            function latin1Slice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i]);
                }
                return ret;
            }

            function hexSlice(buf, start, end) {
                var len = buf.length;
                if (!start || start < 0)
                    start = 0;
                if (!end || end < 0 || end > len)
                    end = len;
                var out = "";
                for (var i = start; i < end; ++i) {
                    out += toHex(buf[i]);
                }
                return out;
            }

            function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end);
                var res = "";
                for (var i = 0; i < bytes.length; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                }
                return res;
            }
            Buffer.prototype.slice = function slice(start, end) {
                var len = this.length;
                start = ~~start;
                end = end === undefined ? len : ~~end;
                if (start < 0) {
                    start += len;
                    if (start < 0)
                        start = 0;
                } else if (start > len) {
                    start = len;
                }
                if (end < 0) {
                    end += len;
                    if (end < 0)
                        end = 0;
                } else if (end > len) {
                    end = len;
                }
                if (end < start)
                    end = start;
                var newBuf;
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    newBuf = this.subarray(start, end);
                    newBuf.__proto__ = Buffer.prototype;
                } else {
                    var sliceLen = end - start;
                    newBuf = new Buffer(sliceLen,undefined);
                    for (var i = 0; i < sliceLen; ++i) {
                        newBuf[i] = this[i + start];
                    }
                }
                return newBuf;
            }
            ;
            /*
                     * Need to make sure that buffer isn't trying to write out of bounds.
                     */
            function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || offset < 0)
                    throw new RangeError("offset is not uint");
                if (offset + ext > length)
                    throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                offset = offset | 0;
                byteLength = byteLength | 0;
                if (!noAssert)
                    checkOffset(offset, byteLength, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul;
                }
                return val;
            }
            ;
            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                offset = offset | 0;
                byteLength = byteLength | 0;
                if (!noAssert) {
                    checkOffset(offset, byteLength, this.length);
                }
                var val = this[offset + --byteLength];
                var mul = 1;
                while (byteLength > 0 && (mul *= 0x100)) {
                    val += this[offset + --byteLength] * mul;
                }
                return val;
            }
            ;
            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 1, this.length);
                return this[offset];
            }
            ;
            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 2, this.length);
                return this[offset] | (this[offset + 1] << 8);
            }
            ;
            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 2, this.length);
                return (this[offset] << 8) | this[offset + 1];
            }
            ;
            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length);
                return ((this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + this[offset + 3] * 0x1000000);
            }
            ;
            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length);
                return (this[offset] * 0x1000000 + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]));
            }
            ;
            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                offset = offset | 0;
                byteLength = byteLength | 0;
                if (!noAssert)
                    checkOffset(offset, byteLength, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul;
                }
                mul *= 0x80;
                if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength);
                return val;
            }
            ;
            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                offset = offset | 0;
                byteLength = byteLength | 0;
                if (!noAssert)
                    checkOffset(offset, byteLength, this.length);
                var i = byteLength;
                var mul = 1;
                var val = this[offset + --i];
                while (i > 0 && (mul *= 0x100)) {
                    val += this[offset + --i] * mul;
                }
                mul *= 0x80;
                if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength);
                return val;
            }
            ;
            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 1, this.length);
                if (!(this[offset] & 0x80))
                    return this[offset];
                return (0xff - this[offset] + 1) * -1;
            }
            ;
            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 2, this.length);
                var val = this[offset] | (this[offset + 1] << 8);
                return val & 0x8000 ? val | 0xffff0000 : val;
            }
            ;
            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 2, this.length);
                var val = this[offset + 1] | (this[offset] << 8);
                return val & 0x8000 ? val | 0xffff0000 : val;
            }
            ;
            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length);
                return (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24));
            }
            ;
            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length);
                return ((this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
            }
            ;
            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, true, 23, 4);
            }
            ;
            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, false, 23, 4);
            }
            ;
            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, true, 52, 8);
            }
            ;
            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, false, 52, 8);
            }
            ;

            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min)
                    throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length)
                    throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset | 0;
                byteLength = byteLength | 0;
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                var mul = 1;
                var i = 0;
                this[offset] = value & 0xff;
                while (++i < byteLength && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xff;
                }
                return offset + byteLength;
            }
            ;
            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset | 0;
                byteLength = byteLength | 0;
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                var i = byteLength - 1;
                var mul = 1;
                this[offset + i] = value & 0xff;
                while (--i >= 0 && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xff;
                }
                return offset + byteLength;
            }
            ;
            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 1, 0xff, 0);
                if (!Buffer.TYPED_ARRAY_SUPPORT)
                    value = Math.floor(value);
                this[offset] = value & 0xff;
                return offset + 1;
            }
            ;

            function objectWriteUInt16(buf, value, offset, littleEndian) {
                if (value < 0)
                    value = 0xffff + value + 1;
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> ((littleEndian ? i : 1 - i) * 8);
                }
            }
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 2, 0xffff, 0);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value & 0xff;
                    this[offset + 1] = value >>> 8;
                } else {
                    objectWriteUInt16(this, value, offset, true);
                }
                return offset + 2;
            }
            ;
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 2, 0xffff, 0);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value >>> 8;
                    this[offset + 1] = value & 0xff;
                } else {
                    objectWriteUInt16(this, value, offset, false);
                }
                return offset + 2;
            }
            ;

            function objectWriteUInt32(buf, value, offset, littleEndian) {
                if (value < 0)
                    value = 0xffffffff + value + 1;
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                    buf[offset + i] = (value >>> ((littleEndian ? i : 3 - i) * 8)) & 0xff;
                }
            }
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 4, 0xffffffff, 0);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset + 3] = value >>> 24;
                    this[offset + 2] = value >>> 16;
                    this[offset + 1] = value >>> 8;
                    this[offset] = value & 0xff;
                } else {
                    objectWriteUInt32(this, value, offset, true);
                }
                return offset + 4;
            }
            ;
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 4, 0xffffffff, 0);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value >>> 24;
                    this[offset + 1] = value >>> 16;
                    this[offset + 2] = value >>> 8;
                    this[offset + 3] = value & 0xff;
                } else {
                    objectWriteUInt32(this, value, offset, false);
                }
                return offset + 4;
            }
            ;
            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                var i = 0;
                var mul = 1;
                var sub = 0;
                this[offset] = value & 0xff;
                while (++i < byteLength && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                        sub = 1;
                    }
                    this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
                }
                return offset + byteLength;
            }
            ;
            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                var i = byteLength - 1;
                var mul = 1;
                var sub = 0;
                this[offset + i] = value & 0xff;
                while (--i >= 0 && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                        sub = 1;
                    }
                    this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
                }
                return offset + byteLength;
            }
            ;
            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 1, 0x7f, -0x80);
                if (!Buffer.TYPED_ARRAY_SUPPORT)
                    value = Math.floor(value);
                if (value < 0)
                    value = 0xff + value + 1;
                this[offset] = value & 0xff;
                return offset + 1;
            }
            ;
            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value & 0xff;
                    this[offset + 1] = value >>> 8;
                } else {
                    objectWriteUInt16(this, value, offset, true);
                }
                return offset + 2;
            }
            ;
            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value >>> 8;
                    this[offset + 1] = value & 0xff;
                } else {
                    objectWriteUInt16(this, value, offset, false);
                }
                return offset + 2;
            }
            ;
            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value & 0xff;
                    this[offset + 1] = value >>> 8;
                    this[offset + 2] = value >>> 16;
                    this[offset + 3] = value >>> 24;
                } else {
                    objectWriteUInt32(this, value, offset, true);
                }
                return offset + 4;
            }
            ;
            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                if (value < 0)
                    value = 0xffffffff + value + 1;
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value >>> 24;
                    this[offset + 1] = value >>> 16;
                    this[offset + 2] = value >>> 8;
                    this[offset + 3] = value & 0xff;
                } else {
                    objectWriteUInt32(this, value, offset, false);
                }
                return offset + 4;
            }
            ;

            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length)
                    throw new RangeError("Index out of range");
                if (offset < 0)
                    throw new RangeError("Index out of range");
            }

            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4);
                return offset + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert);
            }
            ;
            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert);
            }
            ;

            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8);
                return offset + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert);
            }
            ;
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert);
            }
            ;
            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!start)
                    start = 0;
                if (!end && end !== 0)
                    end = this.length;
                if (targetStart >= target.length)
                    targetStart = target.length;
                if (!targetStart)
                    targetStart = 0;
                if (end > 0 && end < start)
                    end = start;
                // Copy 0 bytes; we're done
                if (end === start)
                    return 0;
                if (target.length === 0 || this.length === 0)
                    return 0;
                // Fatal error conditions
                if (targetStart < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (start < 0 || start >= this.length)
                    throw new RangeError("sourceStart out of bounds");
                if (end < 0)
                    throw new RangeError("sourceEnd out of bounds");
                // Are we oob?
                if (end > this.length)
                    end = this.length;
                if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start;
                }
                var len = end - start;
                var i;
                if (this === target && start < targetStart && targetStart < end) {
                    // descending copy from end
                    for (i = len - 1; i >= 0; --i) {
                        target[i + targetStart] = this[i + start];
                    }
                } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                    // ascending copy from start
                    for (i = 0; i < len; ++i) {
                        target[i + targetStart] = this[i + start];
                    }
                } else {
                    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
                }
                return len;
            }
            ;
            // Usage:
            //    buffer.fill(number[, offset[, end]])
            //    buffer.fill(buffer[, offset[, end]])
            //    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill(val, start, end, encoding) {
                // Handle string cases:
                if (typeof val === "string") {
                    if (typeof start === "string") {
                        encoding = start;
                        start = 0;
                        end = this.length;
                    } else if (typeof end === "string") {
                        encoding = end;
                        end = this.length;
                    }
                    if (val.length === 1) {
                        var code = val.charCodeAt(0);
                        if (code < 256) {
                            val = code;
                        }
                    }
                    if (encoding !== undefined && typeof encoding !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                        throw new TypeError("Unknown encoding: " + encoding);
                    }
                } else if (typeof val === "number") {
                    val = val & 255;
                }
                // Invalid ranges are not set to a default, so can range check early.
                if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError("Out of range index");
                }
                if (end <= start) {
                    return this;
                }
                start = start >>> 0;
                end = end === undefined ? this.length : end >>> 0;
                if (!val)
                    val = 0;
                var i;
                if (typeof val === "number") {
                    for (i = start; i < end; ++i) {
                        this[i] = val;
                    }
                } else {
                    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val,encoding).toString());
                    var len = bytes.length;
                    for (i = 0; i < end - start; ++i) {
                        this[i + start] = bytes[i % len];
                    }
                }
                return this;
            }
            ;
            // HELPER FUNCTIONS
            // ================
            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

            function base64clean(str) {
                // Node strips out invalid characters like \n and \t from the string, base64-js does not
                str = stringtrim(str).replace(INVALID_BASE64_RE, "");
                // Node converts strings with length < 2 to ''
                if (str.length < 2)
                    return "";
                // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                while (str.length % 4 !== 0) {
                    str = str + "=";
                }
                return str;
            }

            function stringtrim(str) {
                if (str.trim)
                    return str.trim();
                return str.replace(/^\s+|\s+$/g, "");
            }

            function toHex(n) {
                if (n < 16)
                    return "0" + n.toString(16);
                return n.toString(16);
            }

            function utf8ToBytes(string, units) {
                units = units || Infinity;
                var codePoint;
                var length = string.length;
                var leadSurrogate = null;
                var bytes = [];
                for (var i = 0; i < length; ++i) {
                    codePoint = string.charCodeAt(i);
                    // is surrogate component
                    if (codePoint > 0xd7ff && codePoint < 0xe000) {
                        // last char was a lead
                        if (!leadSurrogate) {
                            // no lead yet
                            if (codePoint > 0xdbff) {
                                // unexpected trail
                                if ((units -= 3) > -1)
                                    bytes.push(0xef, 0xbf, 0xbd);
                                continue;
                            } else if (i + 1 === length) {
                                // unpaired lead
                                if ((units -= 3) > -1)
                                    bytes.push(0xef, 0xbf, 0xbd);
                                continue;
                            }
                            // valid lead
                            leadSurrogate = codePoint;
                            continue;
                        }
                        // 2 leads in a row
                        if (codePoint < 0xdc00) {
                            if ((units -= 3) > -1)
                                bytes.push(0xef, 0xbf, 0xbd);
                            leadSurrogate = codePoint;
                            continue;
                        }
                        // valid surrogate pair
                        codePoint = (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;
                    } else if (leadSurrogate) {
                        // valid bmp char, but last char was a lead
                        if ((units -= 3) > -1)
                            bytes.push(0xef, 0xbf, 0xbd);
                    }
                    leadSurrogate = null;
                    // encode utf8
                    if (codePoint < 0x80) {
                        if ((units -= 1) < 0)
                            break;
                        bytes.push(codePoint);
                    } else if (codePoint < 0x800) {
                        if ((units -= 2) < 0)
                            break;
                        bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
                    } else if (codePoint < 0x10000) {
                        if ((units -= 3) < 0)
                            break;
                        bytes.push((codePoint >> 0xc) | 0xe0, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
                    } else if (codePoint < 0x110000) {
                        if ((units -= 4) < 0)
                            break;
                        bytes.push((codePoint >> 0x12) | 0xf0, ((codePoint >> 0xc) & 0x3f) | 0x80, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return bytes;
            }

            function asciiToBytes(str) {
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                    // Node's code seems to be doing this and not & 0x7F..
                    byteArray.push(str.charCodeAt(i) & 0xff);
                }
                return byteArray;
            }

            function utf16leToBytes(str, units) {
                var c, hi, lo;
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                    if ((units -= 2) < 0)
                        break;
                    c = str.charCodeAt(i);
                    hi = c >> 8;
                    lo = c % 256;
                    byteArray.push(lo);
                    byteArray.push(hi);
                }
                return byteArray;
            }

            function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
            }

            function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                    if (i + offset >= dst.length || i >= src.length)
                        break;
                    dst[i + offset] = src[i];
                }
                return i;
            }

            function isnan(val) {
                return val !== val;
                // eslint-disable-line no-self-compare
            }
            /* WEBPACK VAR INJECTION */
        }
        ).call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */
        "./node_modules/webpack/buildin/global.js"));
        /***/
    },
    /***/
    "./node_modules/buffer/node_modules/isarray/index.js": /*!***********************************************************!*\
  !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
  \***********************************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        var toString = {}.toString;
        module.exports = Array.isArray || function(arr) {
            return toString.call(arr) == "[object Array]";
        }
        ;
        /***/
    },
    /***/
    "./node_modules/charenc/charenc.js": /*!*****************************************!*\
  !*** ./node_modules/charenc/charenc.js ***!
  \*****************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        var charenc = {
            // UTF-8 encoding
            utf8: {
                // Convert a string to a byte array
                stringToBytes: function(str) {
                    return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
                },
                // Convert a byte array to a string
                bytesToString: function(bytes) {
                    return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
                },
            },
            // Binary encoding
            bin: {
                // Convert a string to a byte array
                stringToBytes: function(str) {
                    for (var bytes = [], i = 0; i < str.length; i++)
                        bytes.push(str.charCodeAt(i) & 0xff);
                    return bytes;
                },
                // Convert a byte array to a string
                bytesToString: function(bytes) {
                    for (var str = [], i = 0; i < bytes.length; i++)
                        str.push(String.fromCharCode(bytes[i]));
                    return str.join("");
                },
            },
        };
        module.exports = charenc;
        /***/
    },
    /***/
    "./node_modules/crypt/crypt.js": /*!*************************************!*\
  !*** ./node_modules/crypt/crypt.js ***!
  \*************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        (function() {
            var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
              , crypt = {
                // Bit-wise rotation left
                rotl: function(n, b) {
                    return (n << b) | (n >>> (32 - b));
                },
                // Bit-wise rotation right
                rotr: function(n, b) {
                    return (n << (32 - b)) | (n >>> b);
                },
                // Swap big-endian to little-endian and vice versa
                endian: function(n) {
                    // If number given, swap endian
                    if (n.constructor == Number) {
                        return ((crypt.rotl(n, 8) & 0x00ff00ff) | (crypt.rotl(n, 24) & 0xff00ff00));
                    }
                    // Else, assume array and swap all items
                    for (var i = 0; i < n.length; i++)
                        n[i] = crypt.endian(n[i]);
                    return n;
                },
                // Generate an array of any length of random bytes
                randomBytes: function(n) {
                    for (var bytes = []; n > 0; n--)
                        bytes.push(Math.floor(Math.random() * 256));
                    return bytes;
                },
                // Convert a byte array to big-endian 32-bit words
                bytesToWords: function(bytes) {
                    for (var words = [], i = 0, b = 0; i < bytes.length; i++,
                    b += 8)
                        words[b >>> 5] |= bytes[i] << (24 - (b % 32));
                    return words;
                },
                // Convert big-endian 32-bit words to a byte array
                wordsToBytes: function(words) {
                    for (var bytes = [], b = 0; b < words.length * 32; b += 8)
                        bytes.push((words[b >>> 5] >>> (24 - (b % 32))) & 0xff);
                    return bytes;
                },
                // Convert a byte array to a hex string
                bytesToHex: function(bytes) {
                    for (var hex = [], i = 0; i < bytes.length; i++) {
                        hex.push((bytes[i] >>> 4).toString(16));
                        hex.push((bytes[i] & 0xf).toString(16));
                    }
                    return hex.join("");
                },
                // Convert a hex string to a byte array
                hexToBytes: function(hex) {
                    for (var bytes = [], c = 0; c < hex.length; c += 2)
                        bytes.push(parseInt(hex.substr(c, 2), 16));
                    return bytes;
                },
                // Convert a byte array to a base-64 string
                bytesToBase64: function(bytes) {
                    for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
                        for (var j = 0; j < 4; j++)
                            if (i * 8 + j * 6 <= bytes.length * 8)
                                base64.push(base64map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                            else
                                base64.push("=");
                    }
                    return base64.join("");
                },
                // Convert a base-64 string to a byte array
                base64ToBytes: function(base64) {
                    // Remove non-base-64 characters
                    base64 = base64.replace(/[^A-Z0-9+\/]/gi, "");
                    for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
                        if (imod4 == 0)
                            continue;
                        bytes.push(((base64map.indexOf(base64.charAt(i - 1)) & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2)) | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
                    }
                    return bytes;
                },
            };
            module.exports = crypt;
        }
        )();
        /***/
    },
    /***/
    "./node_modules/event-lite/event-lite.js": /*!***********************************************!*\
  !*** ./node_modules/event-lite/event-lite.js ***!
  \***********************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        /**
                 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
                 *
                 * @copyright Yusuke Kawasaki
                 * @license MIT
                 * @constructor
                 * @see https://github.com/kawanet/event-lite
                 * @see http://kawanet.github.io/event-lite/EventLite.html
                 * @example
                 * var EventLite = require("event-lite");
                 *
                 * function MyClass() {...}             // your class
                 *
                 * EventLite.mixin(MyClass.prototype);  // import event methods
                 *
                 * var obj = new MyClass();
                 * obj.on("foo", function() {...});     // add event listener
                 * obj.once("bar", function() {...});   // add one-time event listener
                 * obj.emit("foo");                     // dispatch event
                 * obj.emit("bar");                     // dispatch another event
                 * obj.off("foo");                      // remove event listener
                 */
        function EventLite() {
            if (!(this instanceof EventLite))
                return new EventLite();
        }
        (function(EventLite) {
            // export the class for node.js
            if (true)
                module.exports = EventLite;
            // property name to hold listeners
            var LISTENERS = "listeners";
            // methods to export
            var methods = {
                on: on,
                once: once,
                off: off,
                emit: emit,
            };
            // mixin to self
            mixin(EventLite.prototype);
            // export mixin function
            EventLite.mixin = mixin;
            /**
                     * Import on(), once(), off() and emit() methods into target object.
                     *
                     * @function EventLite.mixin
                     * @param target {Prototype}
                     */
            function mixin(target) {
                for (var key in methods) {
                    target[key] = methods[key];
                }
                return target;
            }
            /**
                     * Add an event listener.
                     *
                     * @function EventLite.prototype.on
                     * @param type {string}
                     * @param func {Function}
                     * @returns {EventLite} Self for method chaining
                     */
            function on(type, func) {
                getListeners(this, type).push(func);
                return this;
            }
            /**
                     * Add one-time event listener.
                     *
                     * @function EventLite.prototype.once
                     * @param type {string}
                     * @param func {Function}
                     * @returns {EventLite} Self for method chaining
                     */
            function once(type, func) {
                var that = this;
                wrap.originalListener = func;
                getListeners(that, type).push(wrap);
                return that;

                function wrap() {
                    off.call(that, type, wrap);
                    func.apply(this, arguments);
                }
            }
            /**
                     * Remove an event listener.
                     *
                     * @function EventLite.prototype.off
                     * @param [type] {string}
                     * @param [func] {Function}
                     * @returns {EventLite} Self for method chaining
                     */
            function off(type, func) {
                var that = this;
                var listners;
                if (!arguments.length) {
                    delete that[LISTENERS];
                } else if (!func) {
                    listners = that[LISTENERS];
                    if (listners) {
                        delete listners[type];
                        if (!Object.keys(listners).length)
                            return off.call(that);
                    }
                } else {
                    listners = getListeners(that, type, true);
                    if (listners) {
                        listners = listners.filter(ne);
                        if (!listners.length)
                            return off.call(that, type);
                        that[LISTENERS][type] = listners;
                    }
                }
                return that;

                function ne(test) {
                    return test !== func && test.originalListener !== func;
                }
            }
            /**
                     * Dispatch (trigger) an event.
                     *
                     * @function EventLite.prototype.emit
                     * @param type {string}
                     * @param [value] {*}
                     * @returns {boolean} True when a listener received the event
                     */
            function emit(type, value) {
                var that = this;
                var listeners = getListeners(that, type, true);
                if (!listeners)
                    return false;
                var arglen = arguments.length;
                if (arglen === 1) {
                    listeners.forEach(zeroarg);
                } else if (arglen === 2) {
                    listeners.forEach(onearg);
                } else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    listeners.forEach(moreargs);
                }
                return !!listeners.length;

                function zeroarg(func) {
                    func.call(that);
                }

                function onearg(func) {
                    func.call(that, value);
                }

                function moreargs(func) {
                    func.apply(that, args);
                }
            }
            /**
                     * @ignore
                     */
            function getListeners(that, type, readonly) {
                if (readonly && !that[LISTENERS])
                    return;
                var listeners = that[LISTENERS] || (that[LISTENERS] = {});
                return listeners[type] || (listeners[type] = []);
            }
        }
        )(EventLite);
        /***/
    },
    /***/
    "./node_modules/ieee754/index.js": /*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & ((1 << -nBits) - 1);
            s >>= -nBits;
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i],
            i += d,
            nBits -= 8) {}
            m = e & ((1 << -nBits) - 1);
            e >>= -nBits;
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i],
            i += d,
            nBits -= 8) {}
            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        }
        ;
        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }
                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }
            for (; mLen >= 8; buffer[offset + i] = m & 0xff,
            i += d,
            m /= 256,
            mLen -= 8) {}
            e = (e << mLen) | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 0xff,
            i += d,
            e /= 256,
            eLen -= 8) {}
            buffer[offset + i - d] |= s * 128;
        }
        ;
        /***/
    },
    /***/
    "./node_modules/int64-buffer/int64-buffer.js": /*!***************************************************!*\
  !*** ./node_modules/int64-buffer/int64-buffer.js ***!
  \***************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(Buffer) {
            // int64-buffer.js
            /*jshint -W018 */
            // Confusing use of '!'.
            /*jshint -W030 */
            // Expected an assignment or function call and instead saw an expression.
            /*jshint -W093 */
            // Did you mean to return a conditional instead of an assignment?
            var Uint64BE, Int64BE, Uint64LE, Int64LE;
            !(function(exports) {
                // constants
                var UNDEFINED = "undefined";
                var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
                var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
                var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
                var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
                var isArray = Array.isArray || _isArray;
                var BIT32 = 4294967296;
                var BIT24 = 16777216;
                // storage class
                var storage;
                // Array;
                // generate classes
                Uint64BE = factory("Uint64BE", true, true);
                Int64BE = factory("Int64BE", true, false);
                Uint64LE = factory("Uint64LE", false, true);
                Int64LE = factory("Int64LE", false, false);
                // class factory
                function factory(name, bigendian, unsigned) {
                    var posH = bigendian ? 0 : 4;
                    var posL = bigendian ? 4 : 0;
                    var pos0 = bigendian ? 0 : 3;
                    var pos1 = bigendian ? 1 : 2;
                    var pos2 = bigendian ? 2 : 1;
                    var pos3 = bigendian ? 3 : 0;
                    var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
                    var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
                    var proto = Int64.prototype;
                    var isName = "is" + name;
                    var _isInt64 = "_" + isName;
                    // properties
                    proto.buffer = void 0;
                    proto.offset = 0;
                    proto[_isInt64] = true;
                    // methods
                    proto.toNumber = toNumber;
                    proto.toString = toString;
                    proto.toJSON = toNumber;
                    proto.toArray = toArray;
                    // add .toBuffer() method only when Buffer available
                    if (BUFFER)
                        proto.toBuffer = toBuffer;
                    // add .toArrayBuffer() method only when Uint8Array available
                    if (UINT8ARRAY)
                        proto.toArrayBuffer = toArrayBuffer;
                    // isUint64BE, isInt64BE
                    Int64[isName] = isInt64;
                    // CommonJS
                    exports[name] = Int64;
                    return Int64;
                    // constructor
                    function Int64(buffer, offset, value, raddix) {
                        if (!(this instanceof Int64))
                            return new Int64(buffer,offset,value,raddix);
                        return init(this, buffer, offset, value, raddix);
                    }
                    // isUint64BE, isInt64BE
                    function isInt64(b) {
                        return !!(b && b[_isInt64]);
                    }
                    // initializer
                    function init(that, buffer, offset, value, raddix) {
                        if (UINT8ARRAY && ARRAYBUFFER) {
                            if (buffer instanceof ARRAYBUFFER)
                                buffer = new UINT8ARRAY(buffer);
                            if (value instanceof ARRAYBUFFER)
                                value = new UINT8ARRAY(value);
                        }
                        // Int64BE() style
                        if (!buffer && !offset && !value && !storage) {
                            // shortcut to initialize with zero
                            that.buffer = newArray(ZERO, 0);
                            return;
                        }
                        // Int64BE(value, raddix) style
                        if (!isValidBuffer(buffer, offset)) {
                            var _storage = storage || Array;
                            raddix = offset;
                            value = buffer;
                            offset = 0;
                            buffer = new _storage(8);
                        }
                        that.buffer = buffer;
                        that.offset = offset |= 0;
                        // Int64BE(buffer, offset) style
                        if (UNDEFINED === typeof value)
                            return;
                        // Int64BE(buffer, offset, value, raddix) style
                        if ("string" === typeof value) {
                            fromString(buffer, offset, value, raddix || 10);
                        } else if (isValidBuffer(value, raddix)) {
                            fromArray(buffer, offset, value, raddix);
                        } else if ("number" === typeof raddix) {
                            writeInt32(buffer, offset + posH, value);
                            // high
                            writeInt32(buffer, offset + posL, raddix);
                            // low
                        } else if (value > 0) {
                            fromPositive(buffer, offset, value);
                            // positive
                        } else if (value < 0) {
                            fromNegative(buffer, offset, value);
                            // negative
                        } else {
                            fromArray(buffer, offset, ZERO, 0);
                            // zero, NaN and others
                        }
                    }

                    function fromString(buffer, offset, str, raddix) {
                        var pos = 0;
                        var len = str.length;
                        var high = 0;
                        var low = 0;
                        if (str[0] === "-")
                            pos++;
                        var sign = pos;
                        while (pos < len) {
                            var chr = parseInt(str[pos++], raddix);
                            if (!(chr >= 0))
                                break;
                            // NaN
                            low = low * raddix + chr;
                            high = high * raddix + Math.floor(low / BIT32);
                            low %= BIT32;
                        }
                        if (sign) {
                            high = ~high;
                            if (low) {
                                low = BIT32 - low;
                            } else {
                                high++;
                            }
                        }
                        writeInt32(buffer, offset + posH, high);
                        writeInt32(buffer, offset + posL, low);
                    }

                    function toNumber() {
                        var buffer = this.buffer;
                        var offset = this.offset;
                        var high = readInt32(buffer, offset + posH);
                        var low = readInt32(buffer, offset + posL);
                        if (!unsigned)
                            high |= 0;
                        // a trick to get signed
                        return high ? high * BIT32 + low : low;
                    }

                    function toString(radix) {
                        var buffer = this.buffer;
                        var offset = this.offset;
                        var high = readInt32(buffer, offset + posH);
                        var low = readInt32(buffer, offset + posL);
                        var str = "";
                        var sign = !unsigned && high & 0x80000000;
                        if (sign) {
                            high = ~high;
                            low = BIT32 - low;
                        }
                        radix = radix || 10;
                        while (1) {
                            var mod = (high % radix) * BIT32 + low;
                            high = Math.floor(high / radix);
                            low = Math.floor(mod / radix);
                            str = (mod % radix).toString(radix) + str;
                            if (!high && !low)
                                break;
                        }
                        if (sign) {
                            str = "-" + str;
                        }
                        return str;
                    }

                    function writeInt32(buffer, offset, value) {
                        buffer[offset + pos3] = value & 255;
                        value = value >> 8;
                        buffer[offset + pos2] = value & 255;
                        value = value >> 8;
                        buffer[offset + pos1] = value & 255;
                        value = value >> 8;
                        buffer[offset + pos0] = value & 255;
                    }

                    function readInt32(buffer, offset) {
                        return (buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3]);
                    }
                }

                function toArray(raw) {
                    var buffer = this.buffer;
                    var offset = this.offset;
                    storage = null;
                    // Array
                    if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer))
                        return buffer;
                    return newArray(buffer, offset);
                }

                function toBuffer(raw) {
                    var buffer = this.buffer;
                    var offset = this.offset;
                    storage = BUFFER;
                    if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer))
                        return buffer;
                    var dest = new BUFFER(8);
                    fromArray(dest, 0, buffer, offset);
                    return dest;
                }

                function toArrayBuffer(raw) {
                    var buffer = this.buffer;
                    var offset = this.offset;
                    var arrbuf = buffer.buffer;
                    storage = UINT8ARRAY;
                    if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
                        return arrbuf;
                    var dest = new UINT8ARRAY(8);
                    fromArray(dest, 0, buffer, offset);
                    return dest.buffer;
                }

                function isValidBuffer(buffer, offset) {
                    var len = buffer && buffer.length;
                    offset |= 0;
                    return (len && offset + 8 <= len && "string" !== typeof buffer[offset]);
                }

                function fromArray(destbuf, destoff, srcbuf, srcoff) {
                    destoff |= 0;
                    srcoff |= 0;
                    for (var i = 0; i < 8; i++) {
                        destbuf[destoff++] = srcbuf[srcoff++] & 255;
                    }
                }

                function newArray(buffer, offset) {
                    return Array.prototype.slice.call(buffer, offset, offset + 8);
                }

                function fromPositiveBE(buffer, offset, value) {
                    var pos = offset + 8;
                    while (pos > offset) {
                        buffer[--pos] = value & 255;
                        value /= 256;
                    }
                }

                function fromNegativeBE(buffer, offset, value) {
                    var pos = offset + 8;
                    value++;
                    while (pos > offset) {
                        buffer[--pos] = (-value & 255) ^ 255;
                        value /= 256;
                    }
                }

                function fromPositiveLE(buffer, offset, value) {
                    var end = offset + 8;
                    while (offset < end) {
                        buffer[offset++] = value & 255;
                        value /= 256;
                    }
                }

                function fromNegativeLE(buffer, offset, value) {
                    var end = offset + 8;
                    value++;
                    while (offset < end) {
                        buffer[offset++] = (-value & 255) ^ 255;
                        value /= 256;
                    }
                }
                // https://github.com/retrofox/is-array
                function _isArray(val) {
                    return (!!val && "[object Array]" == Object.prototype.toString.call(val));
                }
            }
            )(true && typeof exports.nodeName !== "string" ? exports : this || {});
            /* WEBPACK VAR INJECTION */
        }
        ).call(this, __webpack_require__(/*! ./../buffer/index.js */
        "./node_modules/buffer/index.js").Buffer);
        /***/
    },
    /***/
    "./node_modules/is-buffer/index.js": /*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        /*!
                 * Determine if an object is a Buffer
                 *
                 * @author   Feross Aboukhadijeh <https://feross.org>
                 * @license  MIT
                 */
        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function(obj) {
            return (obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer));
        }
        ;

        function isBuffer(obj) {
            return (!!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj));
        }
        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
            return (typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0)));
        }
        /***/
    },
    /***/
    "./node_modules/md5/md5.js": /*!*********************************!*\
  !*** ./node_modules/md5/md5.js ***!
  \*********************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        (function() {
            var crypt = __webpack_require__(/*! crypt */
            "./node_modules/crypt/crypt.js")
              , utf8 = __webpack_require__(/*! charenc */
            "./node_modules/charenc/charenc.js").utf8
              , isBuffer = __webpack_require__(/*! is-buffer */
            "./node_modules/is-buffer/index.js")
              , bin = __webpack_require__(/*! charenc */
            "./node_modules/charenc/charenc.js").bin
              , // The core
            md5 = function(message, options) {
                // Convert to byte array
                if (message.constructor == String)
                    if (options && options.encoding === "binary")
                        message = bin.stringToBytes(message);
                    else
                        message = utf8.stringToBytes(message);
                else if (isBuffer(message))
                    message = Array.prototype.slice.call(message, 0);
                else if (!Array.isArray(message))
                    message = message.toString();
                // else, assume byte array already
                var m = crypt.bytesToWords(message)
                  , l = message.length * 8
                  , a = 1732584193
                  , b = -271733879
                  , c = -1732584194
                  , d = 271733878;
                // Swap endian
                for (var i = 0; i < m.length; i++) {
                    m[i] = (((m[i] << 8) | (m[i] >>> 24)) & 0x00ff00ff) | (((m[i] << 24) | (m[i] >>> 8)) & 0xff00ff00);
                }
                // Padding
                m[l >>> 5] |= 0x80 << l % 32;
                m[(((l + 64) >>> 9) << 4) + 14] = l;
                // Method shortcuts
                var FF = md5._ff
                  , GG = md5._gg
                  , HH = md5._hh
                  , II = md5._ii;
                for (var i = 0; i < m.length; i += 16) {
                    var aa = a
                      , bb = b
                      , cc = c
                      , dd = d;
                    a = FF(a, b, c, d, m[i + 0], 7, -680876936);
                    d = FF(d, a, b, c, m[i + 1], 12, -389564586);
                    c = FF(c, d, a, b, m[i + 2], 17, 606105819);
                    b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
                    a = FF(a, b, c, d, m[i + 4], 7, -176418897);
                    d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
                    c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
                    b = FF(b, c, d, a, m[i + 7], 22, -45705983);
                    a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
                    d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
                    c = FF(c, d, a, b, m[i + 10], 17, -42063);
                    b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
                    a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
                    d = FF(d, a, b, c, m[i + 13], 12, -40341101);
                    c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
                    b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
                    a = GG(a, b, c, d, m[i + 1], 5, -165796510);
                    d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
                    c = GG(c, d, a, b, m[i + 11], 14, 643717713);
                    b = GG(b, c, d, a, m[i + 0], 20, -373897302);
                    a = GG(a, b, c, d, m[i + 5], 5, -701558691);
                    d = GG(d, a, b, c, m[i + 10], 9, 38016083);
                    c = GG(c, d, a, b, m[i + 15], 14, -660478335);
                    b = GG(b, c, d, a, m[i + 4], 20, -405537848);
                    a = GG(a, b, c, d, m[i + 9], 5, 568446438);
                    d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
                    c = GG(c, d, a, b, m[i + 3], 14, -187363961);
                    b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
                    a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
                    d = GG(d, a, b, c, m[i + 2], 9, -51403784);
                    c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
                    b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
                    a = HH(a, b, c, d, m[i + 5], 4, -378558);
                    d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
                    c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
                    b = HH(b, c, d, a, m[i + 14], 23, -35309556);
                    a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
                    d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
                    c = HH(c, d, a, b, m[i + 7], 16, -155497632);
                    b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
                    a = HH(a, b, c, d, m[i + 13], 4, 681279174);
                    d = HH(d, a, b, c, m[i + 0], 11, -358537222);
                    c = HH(c, d, a, b, m[i + 3], 16, -722521979);
                    b = HH(b, c, d, a, m[i + 6], 23, 76029189);
                    a = HH(a, b, c, d, m[i + 9], 4, -640364487);
                    d = HH(d, a, b, c, m[i + 12], 11, -421815835);
                    c = HH(c, d, a, b, m[i + 15], 16, 530742520);
                    b = HH(b, c, d, a, m[i + 2], 23, -995338651);
                    a = II(a, b, c, d, m[i + 0], 6, -198630844);
                    d = II(d, a, b, c, m[i + 7], 10, 1126891415);
                    c = II(c, d, a, b, m[i + 14], 15, -1416354905);
                    b = II(b, c, d, a, m[i + 5], 21, -57434055);
                    a = II(a, b, c, d, m[i + 12], 6, 1700485571);
                    d = II(d, a, b, c, m[i + 3], 10, -1894986606);
                    c = II(c, d, a, b, m[i + 10], 15, -1051523);
                    b = II(b, c, d, a, m[i + 1], 21, -2054922799);
                    a = II(a, b, c, d, m[i + 8], 6, 1873313359);
                    d = II(d, a, b, c, m[i + 15], 10, -30611744);
                    c = II(c, d, a, b, m[i + 6], 15, -1560198380);
                    b = II(b, c, d, a, m[i + 13], 21, 1309151649);
                    a = II(a, b, c, d, m[i + 4], 6, -145523070);
                    d = II(d, a, b, c, m[i + 11], 10, -1120210379);
                    c = II(c, d, a, b, m[i + 2], 15, 718787259);
                    b = II(b, c, d, a, m[i + 9], 21, -343485551);
                    a = (a + aa) >>> 0;
                    b = (b + bb) >>> 0;
                    c = (c + cc) >>> 0;
                    d = (d + dd) >>> 0;
                }
                return crypt.endian([a, b, c, d]);
            };
            // Auxiliary functions
            md5._ff = function(a, b, c, d, x, s, t) {
                var n = a + ((b & c) | (~b & d)) + (x >>> 0) + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
            ;
            md5._gg = function(a, b, c, d, x, s, t) {
                var n = a + ((b & d) | (c & ~d)) + (x >>> 0) + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
            ;
            md5._hh = function(a, b, c, d, x, s, t) {
                var n = a + (b ^ c ^ d) + (x >>> 0) + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
            ;
            md5._ii = function(a, b, c, d, x, s, t) {
                var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
            ;
            // Package private blocksize
            md5._blocksize = 16;
            md5._digestsize = 16;
            module.exports = function(message, options) {
                if (message === undefined || message === null)
                    throw new Error("Illegal argument " + message);
                var digestbytes = crypt.wordsToBytes(md5(message, options));
                return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
            }
            ;
        }
        )();
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/browser.js": /*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/browser.js ***!
  \**************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // browser.js
        exports.encode = __webpack_require__(/*! ./encode */
        "./node_modules/msgpack-lite/lib/encode.js").encode;
        exports.decode = __webpack_require__(/*! ./decode */
        "./node_modules/msgpack-lite/lib/decode.js").decode;
        exports.Encoder = __webpack_require__(/*! ./encoder */
        "./node_modules/msgpack-lite/lib/encoder.js").Encoder;
        exports.Decoder = __webpack_require__(/*! ./decoder */
        "./node_modules/msgpack-lite/lib/decoder.js").Decoder;
        exports.createCodec = __webpack_require__(/*! ./ext */
        "./node_modules/msgpack-lite/lib/ext.js").createCodec;
        exports.codec = __webpack_require__(/*! ./codec */
        "./node_modules/msgpack-lite/lib/codec.js").codec;
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/buffer-global.js": /*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-global.js ***!
  \********************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(Buffer) {
            /* globals Buffer */
            module.exports = c("undefined" !== typeof Buffer && Buffer) || c(this.Buffer) || c("undefined" !== typeof window && window.Buffer) || this.Buffer;

            function c(B) {
                return B && B.isBuffer && B;
            }
            /* WEBPACK VAR INJECTION */
        }
        ).call(this, __webpack_require__(/*! ./../../buffer/index.js */
        "./node_modules/buffer/index.js").Buffer);
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/buffer-lite.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-lite.js ***!
  \******************************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // buffer-lite.js
        var MAXBUFLEN = 8192;
        exports.copy = copy;
        exports.toString = toString;
        exports.write = write;
        /**
                 * Buffer.prototype.write()
                 *
                 * @param string {String}
                 * @param [offset] {Number}
                 * @returns {Number}
                 */
        function write(string, offset) {
            var buffer = this;
            var index = offset || (offset |= 0);
            var length = string.length;
            var chr = 0;
            var i = 0;
            while (i < length) {
                chr = string.charCodeAt(i++);
                if (chr < 128) {
                    buffer[index++] = chr;
                } else if (chr < 0x800) {
                    // 2 bytes
                    buffer[index++] = 0xc0 | (chr >>> 6);
                    buffer[index++] = 0x80 | (chr & 0x3f);
                } else if (chr < 0xd800 || chr > 0xdfff) {
                    // 3 bytes
                    buffer[index++] = 0xe0 | (chr >>> 12);
                    buffer[index++] = 0x80 | ((chr >>> 6) & 0x3f);
                    buffer[index++] = 0x80 | (chr & 0x3f);
                } else {
                    // 4 bytes - surrogate pair
                    chr = (((chr - 0xd800) << 10) | (string.charCodeAt(i++) - 0xdc00)) + 0x10000;
                    buffer[index++] = 0xf0 | (chr >>> 18);
                    buffer[index++] = 0x80 | ((chr >>> 12) & 0x3f);
                    buffer[index++] = 0x80 | ((chr >>> 6) & 0x3f);
                    buffer[index++] = 0x80 | (chr & 0x3f);
                }
            }
            return index - offset;
        }
        /**
                 * Buffer.prototype.toString()
                 *
                 * @param [encoding] {String} ignored
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {String}
                 */
        function toString(encoding, start, end) {
            var buffer = this;
            var index = start | 0;
            if (!end)
                end = buffer.length;
            var string = "";
            var chr = 0;
            while (index < end) {
                chr = buffer[index++];
                if (chr < 128) {
                    string += String.fromCharCode(chr);
                    continue;
                }
                if ((chr & 0xe0) === 0xc0) {
                    // 2 bytes
                    chr = ((chr & 0x1f) << 6) | (buffer[index++] & 0x3f);
                } else if ((chr & 0xf0) === 0xe0) {
                    // 3 bytes
                    chr = ((chr & 0x0f) << 12) | ((buffer[index++] & 0x3f) << 6) | (buffer[index++] & 0x3f);
                } else if ((chr & 0xf8) === 0xf0) {
                    // 4 bytes
                    chr = ((chr & 0x07) << 18) | ((buffer[index++] & 0x3f) << 12) | ((buffer[index++] & 0x3f) << 6) | (buffer[index++] & 0x3f);
                }
                if (chr >= 0x010000) {
                    // A surrogate pair
                    chr -= 0x010000;
                    string += String.fromCharCode((chr >>> 10) + 0xd800, (chr & 0x3ff) + 0xdc00);
                } else {
                    string += String.fromCharCode(chr);
                }
            }
            return string;
        }
        /**
                 * Buffer.prototype.copy()
                 *
                 * @param target {Buffer}
                 * @param [targetStart] {Number}
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {number}
                 */
        function copy(target, targetStart, start, end) {
            var i;
            if (!start)
                start = 0;
            if (!end && end !== 0)
                end = this.length;
            if (!targetStart)
                targetStart = 0;
            var len = end - start;
            if (target === this && start < targetStart && targetStart < end) {
                // descending
                for (i = len - 1; i >= 0; i--) {
                    target[i + targetStart] = this[i + start];
                }
            } else {
                // ascending
                for (i = 0; i < len; i++) {
                    target[i + targetStart] = this[i + start];
                }
            }
            return len;
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/bufferish-array.js": /*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-array.js ***!
  \**********************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // bufferish-array.js
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var exports = (module.exports = alloc(0));
        exports.alloc = alloc;
        exports.concat = Bufferish.concat;
        exports.from = from;
        /**
                 * @param size {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
        function alloc(size) {
            return new Array(size);
        }
        /**
                 * @param value {Array|ArrayBuffer|Buffer|String}
                 * @returns {Array}
                 */
        function from(value) {
            if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
                // TypedArray to Uint8Array
                value = Bufferish.Uint8Array.from(value);
            } else if (Bufferish.isArrayBuffer(value)) {
                // ArrayBuffer to Uint8Array
                value = new Uint8Array(value);
            } else if (typeof value === "string") {
                // String to Array
                return Bufferish.from.call(exports, value);
            } else if (typeof value === "number") {
                throw new TypeError('"value" argument must not be a number');
            }
            // Array-like to Array
            return Array.prototype.slice.call(value);
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/bufferish-buffer.js": /*!***********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-buffer.js ***!
  \***********************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // bufferish-buffer.js
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var Buffer = Bufferish.global;
        var exports = (module.exports = Bufferish.hasBuffer ? alloc(0) : []);
        exports.alloc = (Bufferish.hasBuffer && Buffer.alloc) || alloc;
        exports.concat = Bufferish.concat;
        exports.from = from;
        /**
                 * @param size {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
        function alloc(size) {
            return new Buffer(size);
        }
        /**
                 * @param value {Array|ArrayBuffer|Buffer|String}
                 * @returns {Buffer}
                 */
        function from(value) {
            if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
                // TypedArray to Uint8Array
                value = Bufferish.Uint8Array.from(value);
            } else if (Bufferish.isArrayBuffer(value)) {
                // ArrayBuffer to Uint8Array
                value = new Uint8Array(value);
            } else if (typeof value === "string") {
                // String to Buffer
                return Bufferish.from.call(exports, value);
            } else if (typeof value === "number") {
                throw new TypeError('"value" argument must not be a number');
            }
            // Array-like to Buffer
            if (Buffer.from && Buffer.from.length !== 1) {
                return Buffer.from(value);
                // node v6+
            } else {
                return new Buffer(value);
                // node v4
            }
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/bufferish-proto.js": /*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-proto.js ***!
  \**********************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // bufferish-proto.js
        /* jshint eqnull:true */
        var BufferLite = __webpack_require__(/*! ./buffer-lite */
        "./node_modules/msgpack-lite/lib/buffer-lite.js");
        exports.copy = copy;
        exports.slice = slice;
        exports.toString = toString;
        exports.write = gen("write");
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var Buffer = Bufferish.global;
        var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT"in Buffer;
        var brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;
        /**
                 * @param target {Buffer|Uint8Array|Array}
                 * @param [targetStart] {Number}
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
        function copy(target, targetStart, start, end) {
            var thisIsBuffer = Bufferish.isBuffer(this);
            var targetIsBuffer = Bufferish.isBuffer(target);
            if (thisIsBuffer && targetIsBuffer) {
                // Buffer to Buffer
                return this.copy(target, targetStart, start, end);
            } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
                // Uint8Array to Uint8Array (except for minor some browsers)
                var buffer = start || end != null ? slice.call(this, start, end) : this;
                target.set(buffer, targetStart);
                return buffer.length;
            } else {
                // other cases
                return BufferLite.copy.call(this, target, targetStart, start, end);
            }
        }
        /**
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
        function slice(start, end) {
            // for Buffer, Uint8Array (except for minor some browsers) and Array
            var f = this.slice || (!brokenTypedArray && this.subarray);
            if (f)
                return f.call(this, start, end);
            // Uint8Array (for minor some browsers)
            var target = Bufferish.alloc.call(this, end - start);
            copy.call(this, target, 0, start, end);
            return target;
        }
        /**
                 * Buffer.prototype.toString()
                 *
                 * @param [encoding] {String} ignored
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {String}
                 */
        function toString(encoding, start, end) {
            var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
            return f.apply(this, arguments);
        }
        /**
                 * @private
                 */
        function gen(method) {
            return wrap;

            function wrap() {
                var f = this[method] || BufferLite[method];
                return f.apply(this, arguments);
            }
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/bufferish-uint8array.js": /*!***************************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-uint8array.js ***!
  \***************************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // bufferish-uint8array.js
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var exports = (module.exports = Bufferish.hasArrayBuffer ? alloc(0) : []);
        exports.alloc = alloc;
        exports.concat = Bufferish.concat;
        exports.from = from;
        /**
                 * @param size {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
        function alloc(size) {
            return new Uint8Array(size);
        }
        /**
                 * @param value {Array|ArrayBuffer|Buffer|String}
                 * @returns {Uint8Array}
                 */
        function from(value) {
            if (Bufferish.isView(value)) {
                // TypedArray to ArrayBuffer
                var byteOffset = value.byteOffset;
                var byteLength = value.byteLength;
                value = value.buffer;
                if (value.byteLength !== byteLength) {
                    if (value.slice) {
                        value = value.slice(byteOffset, byteOffset + byteLength);
                    } else {
                        // Android 4.1 does not have ArrayBuffer.prototype.slice
                        value = new Uint8Array(value);
                        if (value.byteLength !== byteLength) {
                            // TypedArray to ArrayBuffer to Uint8Array to Array
                            value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);
                        }
                    }
                }
            } else if (typeof value === "string") {
                // String to Uint8Array
                return Bufferish.from.call(exports, value);
            } else if (typeof value === "number") {
                throw new TypeError('"value" argument must not be a number');
            }
            return new Uint8Array(value);
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/bufferish.js": /*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish.js ***!
  \****************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // bufferish.js
        var Buffer = (exports.global = __webpack_require__(/*! ./buffer-global */
        "./node_modules/msgpack-lite/lib/buffer-global.js"));
        var hasBuffer = (exports.hasBuffer = Buffer && !!Buffer.isBuffer);
        var hasArrayBuffer = (exports.hasArrayBuffer = "undefined" !== typeof ArrayBuffer);
        var isArray = (exports.isArray = __webpack_require__(/*! isarray */
        "./node_modules/msgpack-lite/node_modules/isarray/index.js"));
        exports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
        var isBuffer = (exports.isBuffer = hasBuffer ? Buffer.isBuffer : _false);
        var isView = (exports.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false);
        exports.alloc = alloc;
        exports.concat = concat;
        exports.from = from;
        var BufferArray = (exports.Array = __webpack_require__(/*! ./bufferish-array */
        "./node_modules/msgpack-lite/lib/bufferish-array.js"));
        var BufferBuffer = (exports.Buffer = __webpack_require__(/*! ./bufferish-buffer */
        "./node_modules/msgpack-lite/lib/bufferish-buffer.js"));
        var BufferUint8Array = (exports.Uint8Array = __webpack_require__(/*! ./bufferish-uint8array */
        "./node_modules/msgpack-lite/lib/bufferish-uint8array.js"));
        var BufferProto = (exports.prototype = __webpack_require__(/*! ./bufferish-proto */
        "./node_modules/msgpack-lite/lib/bufferish-proto.js"));
        /**
                 * @param value {Array|ArrayBuffer|Buffer|String}
                 * @returns {Buffer|Uint8Array|Array}
                 */
        function from(value) {
            if (typeof value === "string") {
                return fromString.call(this, value);
            } else {
                return auto(this).from(value);
            }
        }
        /**
                 * @param size {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
        function alloc(size) {
            return auto(this).alloc(size);
        }
        /**
                 * @param list {Array} array of (Buffer|Uint8Array|Array)s
                 * @param [length]
                 * @returns {Buffer|Uint8Array|Array}
                 */
        function concat(list, length) {
            if (!length) {
                length = 0;
                Array.prototype.forEach.call(list, dryrun);
            }
            var ref = (this !== exports && this) || list[0];
            var result = alloc.call(ref, length);
            var offset = 0;
            Array.prototype.forEach.call(list, append);
            return result;

            function dryrun(buffer) {
                length += buffer.length;
            }

            function append(buffer) {
                offset += BufferProto.copy.call(buffer, result, offset);
            }
        }
        var _isArrayBuffer = _is("ArrayBuffer");

        function isArrayBuffer(value) {
            return value instanceof ArrayBuffer || _isArrayBuffer(value);
        }
        /**
                 * @private
                 */
        function fromString(value) {
            var expected = value.length * 3;
            var that = alloc.call(this, expected);
            var actual = BufferProto.write.call(that, value);
            if (expected !== actual) {
                that = BufferProto.slice.call(that, 0, actual);
            }
            return that;
        }

        function auto(that) {
            return isBuffer(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
        }

        function _false() {
            return false;
        }

        function _is(name, key) {
            /* jshint eqnull:true */
            name = "[object " + name + "]";
            return function(value) {
                return (value != null && {}.toString.call(key ? value[key] : value) === name);
            }
            ;
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/codec-base.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec-base.js ***!
  \*****************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // codec-base.js
        var IS_ARRAY = __webpack_require__(/*! isarray */
        "./node_modules/msgpack-lite/node_modules/isarray/index.js");
        exports.createCodec = createCodec;
        exports.install = install;
        exports.filter = filter;
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");

        function Codec(options) {
            if (!(this instanceof Codec))
                return new Codec(options);
            this.options = options;
            this.init();
        }
        Codec.prototype.init = function() {
            var options = this.options;
            if (options && options.uint8array) {
                this.bufferish = Bufferish.Uint8Array;
            }
            return this;
        }
        ;

        function install(props) {
            for (var key in props) {
                Codec.prototype[key] = add(Codec.prototype[key], props[key]);
            }
        }

        function add(a, b) {
            return a && b ? ab : a || b;

            function ab() {
                a.apply(this, arguments);
                return b.apply(this, arguments);
            }
        }

        function join(filters) {
            filters = filters.slice();
            return function(value) {
                return filters.reduce(iterator, value);
            }
            ;

            function iterator(value, filter) {
                return filter(value);
            }
        }

        function filter(filter) {
            return IS_ARRAY(filter) ? join(filter) : filter;
        }
        // @public
        // msgpack.createCodec()
        function createCodec(options) {
            return new Codec(options);
        }
        // default shared codec
        exports.preset = createCodec({
            preset: true
        });
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/codec.js": /*!************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec.js ***!
  \************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // codec.js
        // load both interfaces
        __webpack_require__(/*! ./read-core */
        "./node_modules/msgpack-lite/lib/read-core.js");
        __webpack_require__(/*! ./write-core */
        "./node_modules/msgpack-lite/lib/write-core.js");
        // @public
        // msgpack.codec.preset
        exports.codec = {
            preset: __webpack_require__(/*! ./codec-base */
            "./node_modules/msgpack-lite/lib/codec-base.js").preset,
        };
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/decode-buffer.js": /*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode-buffer.js ***!
  \********************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // decode-buffer.js
        exports.DecodeBuffer = DecodeBuffer;
        var preset = __webpack_require__(/*! ./read-core */
        "./node_modules/msgpack-lite/lib/read-core.js").preset;
        var FlexDecoder = __webpack_require__(/*! ./flex-buffer */
        "./node_modules/msgpack-lite/lib/flex-buffer.js").FlexDecoder;
        FlexDecoder.mixin(DecodeBuffer.prototype);

        function DecodeBuffer(options) {
            if (!(this instanceof DecodeBuffer))
                return new DecodeBuffer(options);
            if (options) {
                this.options = options;
                if (options.codec) {
                    var codec = (this.codec = options.codec);
                    if (codec.bufferish)
                        this.bufferish = codec.bufferish;
                }
            }
        }
        DecodeBuffer.prototype.codec = preset;
        DecodeBuffer.prototype.fetch = function() {
            return this.codec.decode(this);
        }
        ;
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/decode.js": /*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode.js ***!
  \*************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // decode.js
        exports.decode = decode;
        var DecodeBuffer = __webpack_require__(/*! ./decode-buffer */
        "./node_modules/msgpack-lite/lib/decode-buffer.js").DecodeBuffer;

        function decode(input, options) {
            var decoder = new DecodeBuffer(options);
            decoder.write(input);
            return decoder.read();
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/decoder.js": /*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decoder.js ***!
  \**************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // decoder.js
        exports.Decoder = Decoder;
        var EventLite = __webpack_require__(/*! event-lite */
        "./node_modules/event-lite/event-lite.js");
        var DecodeBuffer = __webpack_require__(/*! ./decode-buffer */
        "./node_modules/msgpack-lite/lib/decode-buffer.js").DecodeBuffer;

        function Decoder(options) {
            if (!(this instanceof Decoder))
                return new Decoder(options);
            DecodeBuffer.call(this, options);
        }
        Decoder.prototype = new DecodeBuffer();
        EventLite.mixin(Decoder.prototype);
        Decoder.prototype.decode = function(chunk) {
            if (arguments.length)
                this.write(chunk);
            this.flush();
        }
        ;
        Decoder.prototype.push = function(chunk) {
            this.emit("data", chunk);
        }
        ;
        Decoder.prototype.end = function(chunk) {
            this.decode(chunk);
            this.emit("end");
        }
        ;
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/encode-buffer.js": /*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode-buffer.js ***!
  \********************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // encode-buffer.js
        exports.EncodeBuffer = EncodeBuffer;
        var preset = __webpack_require__(/*! ./write-core */
        "./node_modules/msgpack-lite/lib/write-core.js").preset;
        var FlexEncoder = __webpack_require__(/*! ./flex-buffer */
        "./node_modules/msgpack-lite/lib/flex-buffer.js").FlexEncoder;
        FlexEncoder.mixin(EncodeBuffer.prototype);

        function EncodeBuffer(options) {
            if (!(this instanceof EncodeBuffer))
                return new EncodeBuffer(options);
            if (options) {
                this.options = options;
                if (options.codec) {
                    var codec = (this.codec = options.codec);
                    if (codec.bufferish)
                        this.bufferish = codec.bufferish;
                }
            }
        }
        EncodeBuffer.prototype.codec = preset;
        EncodeBuffer.prototype.write = function(input) {
            this.codec.encode(this, input);
        }
        ;
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/encode.js": /*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode.js ***!
  \*************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // encode.js
        exports.encode = encode;
        var EncodeBuffer = __webpack_require__(/*! ./encode-buffer */
        "./node_modules/msgpack-lite/lib/encode-buffer.js").EncodeBuffer;

        function encode(input, options) {
            var encoder = new EncodeBuffer(options);
            encoder.write(input);
            return encoder.read();
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/encoder.js": /*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encoder.js ***!
  \**************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // encoder.js
        exports.Encoder = Encoder;
        var EventLite = __webpack_require__(/*! event-lite */
        "./node_modules/event-lite/event-lite.js");
        var EncodeBuffer = __webpack_require__(/*! ./encode-buffer */
        "./node_modules/msgpack-lite/lib/encode-buffer.js").EncodeBuffer;

        function Encoder(options) {
            if (!(this instanceof Encoder))
                return new Encoder(options);
            EncodeBuffer.call(this, options);
        }
        Encoder.prototype = new EncodeBuffer();
        EventLite.mixin(Encoder.prototype);
        Encoder.prototype.encode = function(chunk) {
            this.write(chunk);
            this.emit("data", this.read());
        }
        ;
        Encoder.prototype.end = function(chunk) {
            if (arguments.length)
                this.encode(chunk);
            this.flush();
            this.emit("end");
        }
        ;
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/ext-buffer.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-buffer.js ***!
  \*****************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // ext-buffer.js
        exports.ExtBuffer = ExtBuffer;
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");

        function ExtBuffer(buffer, type) {
            if (!(this instanceof ExtBuffer))
                return new ExtBuffer(buffer,type);
            this.buffer = Bufferish.from(buffer);
            this.type = type;
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/ext-packer.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-packer.js ***!
  \*****************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // ext-packer.js
        exports.setExtPackers = setExtPackers;
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var Buffer = Bufferish.global;
        var packTypedArray = Bufferish.Uint8Array.from;
        var _encode;
        var ERROR_COLUMNS = {
            name: 1,
            message: 1,
            stack: 1,
            columnNumber: 1,
            fileName: 1,
            lineNumber: 1,
        };

        function setExtPackers(codec) {
            codec.addExtPacker(0x0e, Error, [packError, encode]);
            codec.addExtPacker(0x01, EvalError, [packError, encode]);
            codec.addExtPacker(0x02, RangeError, [packError, encode]);
            codec.addExtPacker(0x03, ReferenceError, [packError, encode]);
            codec.addExtPacker(0x04, SyntaxError, [packError, encode]);
            codec.addExtPacker(0x05, TypeError, [packError, encode]);
            codec.addExtPacker(0x06, URIError, [packError, encode]);
            codec.addExtPacker(0x0a, RegExp, [packRegExp, encode]);
            codec.addExtPacker(0x0b, Boolean, [packValueOf, encode]);
            codec.addExtPacker(0x0c, String, [packValueOf, encode]);
            codec.addExtPacker(0x0d, Date, [Number, encode]);
            codec.addExtPacker(0x0f, Number, [packValueOf, encode]);
            if ("undefined" !== typeof Uint8Array) {
                codec.addExtPacker(0x11, Int8Array, packTypedArray);
                codec.addExtPacker(0x12, Uint8Array, packTypedArray);
                codec.addExtPacker(0x13, Int16Array, packTypedArray);
                codec.addExtPacker(0x14, Uint16Array, packTypedArray);
                codec.addExtPacker(0x15, Int32Array, packTypedArray);
                codec.addExtPacker(0x16, Uint32Array, packTypedArray);
                codec.addExtPacker(0x17, Float32Array, packTypedArray);
                // PhantomJS/1.9.7 doesn't have Float64Array
                if ("undefined" !== typeof Float64Array) {
                    codec.addExtPacker(0x18, Float64Array, packTypedArray);
                }
                // IE10 doesn't have Uint8ClampedArray
                if ("undefined" !== typeof Uint8ClampedArray) {
                    codec.addExtPacker(0x19, Uint8ClampedArray, packTypedArray);
                }
                codec.addExtPacker(0x1a, ArrayBuffer, packTypedArray);
                codec.addExtPacker(0x1d, DataView, packTypedArray);
            }
            if (Bufferish.hasBuffer) {
                codec.addExtPacker(0x1b, Buffer, Bufferish.from);
            }
        }

        function encode(input) {
            if (!_encode)
                _encode = __webpack_require__(/*! ./encode */
                "./node_modules/msgpack-lite/lib/encode.js").encode;
            // lazy load
            return _encode(input);
        }

        function packValueOf(value) {
            return value.valueOf();
        }

        function packRegExp(value) {
            value = RegExp.prototype.toString.call(value).split("/");
            value.shift();
            var out = [value.pop()];
            out.unshift(value.join("/"));
            return out;
        }

        function packError(value) {
            var out = {};
            for (var key in ERROR_COLUMNS) {
                out[key] = value[key];
            }
            return out;
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/ext-unpacker.js": /*!*******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-unpacker.js ***!
  \*******************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // ext-unpacker.js
        exports.setExtUnpackers = setExtUnpackers;
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var Buffer = Bufferish.global;
        var _decode;
        var ERROR_COLUMNS = {
            name: 1,
            message: 1,
            stack: 1,
            columnNumber: 1,
            fileName: 1,
            lineNumber: 1,
        };

        function setExtUnpackers(codec) {
            codec.addExtUnpacker(0x0e, [decode, unpackError(Error)]);
            codec.addExtUnpacker(0x01, [decode, unpackError(EvalError)]);
            codec.addExtUnpacker(0x02, [decode, unpackError(RangeError)]);
            codec.addExtUnpacker(0x03, [decode, unpackError(ReferenceError)]);
            codec.addExtUnpacker(0x04, [decode, unpackError(SyntaxError)]);
            codec.addExtUnpacker(0x05, [decode, unpackError(TypeError)]);
            codec.addExtUnpacker(0x06, [decode, unpackError(URIError)]);
            codec.addExtUnpacker(0x0a, [decode, unpackRegExp]);
            codec.addExtUnpacker(0x0b, [decode, unpackClass(Boolean)]);
            codec.addExtUnpacker(0x0c, [decode, unpackClass(String)]);
            codec.addExtUnpacker(0x0d, [decode, unpackClass(Date)]);
            codec.addExtUnpacker(0x0f, [decode, unpackClass(Number)]);
            if ("undefined" !== typeof Uint8Array) {
                codec.addExtUnpacker(0x11, unpackClass(Int8Array));
                codec.addExtUnpacker(0x12, unpackClass(Uint8Array));
                codec.addExtUnpacker(0x13, [unpackArrayBuffer, unpackClass(Int16Array), ]);
                codec.addExtUnpacker(0x14, [unpackArrayBuffer, unpackClass(Uint16Array), ]);
                codec.addExtUnpacker(0x15, [unpackArrayBuffer, unpackClass(Int32Array), ]);
                codec.addExtUnpacker(0x16, [unpackArrayBuffer, unpackClass(Uint32Array), ]);
                codec.addExtUnpacker(0x17, [unpackArrayBuffer, unpackClass(Float32Array), ]);
                // PhantomJS/1.9.7 doesn't have Float64Array
                if ("undefined" !== typeof Float64Array) {
                    codec.addExtUnpacker(0x18, [unpackArrayBuffer, unpackClass(Float64Array), ]);
                }
                // IE10 doesn't have Uint8ClampedArray
                if ("undefined" !== typeof Uint8ClampedArray) {
                    codec.addExtUnpacker(0x19, unpackClass(Uint8ClampedArray));
                }
                codec.addExtUnpacker(0x1a, unpackArrayBuffer);
                codec.addExtUnpacker(0x1d, [unpackArrayBuffer, unpackClass(DataView), ]);
            }
            if (Bufferish.hasBuffer) {
                codec.addExtUnpacker(0x1b, unpackClass(Buffer));
            }
        }

        function decode(input) {
            if (!_decode)
                _decode = __webpack_require__(/*! ./decode */
                "./node_modules/msgpack-lite/lib/decode.js").decode;
            // lazy load
            return _decode(input);
        }

        function unpackRegExp(value) {
            return RegExp.apply(null, value);
        }

        function unpackError(Class) {
            return function(value) {
                var out = new Class();
                for (var key in ERROR_COLUMNS) {
                    out[key] = value[key];
                }
                return out;
            }
            ;
        }

        function unpackClass(Class) {
            return function(value) {
                return new Class(value);
            }
            ;
        }

        function unpackArrayBuffer(value) {
            return new Uint8Array(value).buffer;
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/ext.js": /*!**********************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext.js ***!
  \**********************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // ext.js
        // load both interfaces
        __webpack_require__(/*! ./read-core */
        "./node_modules/msgpack-lite/lib/read-core.js");
        __webpack_require__(/*! ./write-core */
        "./node_modules/msgpack-lite/lib/write-core.js");
        exports.createCodec = __webpack_require__(/*! ./codec-base */
        "./node_modules/msgpack-lite/lib/codec-base.js").createCodec;
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/flex-buffer.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/flex-buffer.js ***!
  \******************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // flex-buffer.js
        exports.FlexDecoder = FlexDecoder;
        exports.FlexEncoder = FlexEncoder;
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var MIN_BUFFER_SIZE = 2048;
        var MAX_BUFFER_SIZE = 65536;
        var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";

        function FlexDecoder() {
            if (!(this instanceof FlexDecoder))
                return new FlexDecoder();
        }

        function FlexEncoder() {
            if (!(this instanceof FlexEncoder))
                return new FlexEncoder();
        }
        FlexDecoder.mixin = mixinFactory(getDecoderMethods());
        FlexDecoder.mixin(FlexDecoder.prototype);
        FlexEncoder.mixin = mixinFactory(getEncoderMethods());
        FlexEncoder.mixin(FlexEncoder.prototype);

        function getDecoderMethods() {
            return {
                bufferish: Bufferish,
                write: write,
                fetch: fetch,
                flush: flush,
                push: push,
                pull: pull,
                read: read,
                reserve: reserve,
                offset: 0,
            };

            function write(chunk) {
                var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
                this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
                this.offset = 0;
            }

            function flush() {
                while (this.offset < this.buffer.length) {
                    var start = this.offset;
                    var value;
                    try {
                        value = this.fetch();
                    } catch (e) {
                        if (e && e.message != BUFFER_SHORTAGE)
                            throw e;
                        // rollback
                        this.offset = start;
                        break;
                    }
                    this.push(value);
                }
            }

            function reserve(length) {
                var start = this.offset;
                var end = start + length;
                if (end > this.buffer.length)
                    throw new Error(BUFFER_SHORTAGE);
                this.offset = end;
                return start;
            }
        }

        function getEncoderMethods() {
            return {
                bufferish: Bufferish,
                write: write,
                fetch: fetch,
                flush: flush,
                push: push,
                pull: pull,
                read: read,
                reserve: reserve,
                send: send,
                maxBufferSize: MAX_BUFFER_SIZE,
                minBufferSize: MIN_BUFFER_SIZE,
                offset: 0,
                start: 0,
            };

            function fetch() {
                var start = this.start;
                if (start < this.offset) {
                    var end = (this.start = this.offset);
                    return Bufferish.prototype.slice.call(this.buffer, start, end);
                }
            }

            function flush() {
                while (this.start < this.offset) {
                    var value = this.fetch();
                    if (value)
                        this.push(value);
                }
            }

            function pull() {
                var buffers = this.buffers || (this.buffers = []);
                var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
                buffers.length = 0;
                // buffer exhausted
                return chunk;
            }

            function reserve(length) {
                var req = length | 0;
                if (this.buffer) {
                    var size = this.buffer.length;
                    var start = this.offset | 0;
                    var end = start + req;
                    // is it long enough?
                    if (end < size) {
                        this.offset = end;
                        return start;
                    }
                    // flush current buffer
                    this.flush();
                    // resize it to 2x current length
                    length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
                }
                // minimum buffer size
                length = Math.max(length, this.minBufferSize);
                // allocate new buffer
                this.buffer = this.bufferish.alloc(length);
                this.start = 0;
                this.offset = req;
                return 0;
            }

            function send(buffer) {
                var length = buffer.length;
                if (length > this.minBufferSize) {
                    this.flush();
                    this.push(buffer);
                } else {
                    var offset = this.reserve(length);
                    Bufferish.prototype.copy.call(buffer, this.buffer, offset);
                }
            }
        }
        // common methods
        function write() {
            throw new Error("method not implemented: write()");
        }

        function fetch() {
            throw new Error("method not implemented: fetch()");
        }

        function read() {
            var length = this.buffers && this.buffers.length;
            // fetch the first result
            if (!length)
                return this.fetch();
            // flush current buffer
            this.flush();
            // read from the results
            return this.pull();
        }

        function push(chunk) {
            var buffers = this.buffers || (this.buffers = []);
            buffers.push(chunk);
        }

        function pull() {
            var buffers = this.buffers || (this.buffers = []);
            return buffers.shift();
        }

        function mixinFactory(source) {
            return mixin;

            function mixin(target) {
                for (var key in source) {
                    target[key] = source[key];
                }
                return target;
            }
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/read-core.js": /*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-core.js ***!
  \****************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // read-core.js
        var ExtBuffer = __webpack_require__(/*! ./ext-buffer */
        "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
        var ExtUnpacker = __webpack_require__(/*! ./ext-unpacker */
        "./node_modules/msgpack-lite/lib/ext-unpacker.js");
        var readUint8 = __webpack_require__(/*! ./read-format */
        "./node_modules/msgpack-lite/lib/read-format.js").readUint8;
        var ReadToken = __webpack_require__(/*! ./read-token */
        "./node_modules/msgpack-lite/lib/read-token.js");
        var CodecBase = __webpack_require__(/*! ./codec-base */
        "./node_modules/msgpack-lite/lib/codec-base.js");
        CodecBase.install({
            addExtUnpacker: addExtUnpacker,
            getExtUnpacker: getExtUnpacker,
            init: init,
        });
        exports.preset = init.call(CodecBase.preset);

        function getDecoder(options) {
            var readToken = ReadToken.getReadToken(options);
            return decode;

            function decode(decoder) {
                var type = readUint8(decoder);
                var func = readToken[type];
                if (!func)
                    throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
                return func(decoder);
            }
        }

        function init() {
            var options = this.options;
            this.decode = getDecoder(options);
            if (options && options.preset) {
                ExtUnpacker.setExtUnpackers(this);
            }
            return this;
        }

        function addExtUnpacker(etype, unpacker) {
            var unpackers = this.extUnpackers || (this.extUnpackers = []);
            unpackers[etype] = CodecBase.filter(unpacker);
        }

        function getExtUnpacker(type) {
            var unpackers = this.extUnpackers || (this.extUnpackers = []);
            return unpackers[type] || extUnpacker;

            function extUnpacker(buffer) {
                return new ExtBuffer(buffer,type);
            }
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/read-format.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-format.js ***!
  \******************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // read-format.js
        var ieee754 = __webpack_require__(/*! ieee754 */
        "./node_modules/ieee754/index.js");
        var Int64Buffer = __webpack_require__(/*! int64-buffer */
        "./node_modules/int64-buffer/int64-buffer.js");
        var Uint64BE = Int64Buffer.Uint64BE;
        var Int64BE = Int64Buffer.Int64BE;
        exports.getReadFormat = getReadFormat;
        exports.readUint8 = uint8;
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var BufferProto = __webpack_require__(/*! ./bufferish-proto */
        "./node_modules/msgpack-lite/lib/bufferish-proto.js");
        var HAS_MAP = "undefined" !== typeof Map;
        var NO_ASSERT = true;

        function getReadFormat(options) {
            var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
            var int64 = options && options.int64;
            var usemap = HAS_MAP && options && options.usemap;
            var readFormat = {
                map: usemap ? map_to_map : map_to_obj,
                array: array,
                str: str,
                bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
                ext: ext,
                uint8: uint8,
                uint16: uint16,
                uint32: uint32,
                uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
                int8: int8,
                int16: int16,
                int32: int32,
                int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
                float32: read(4, readFloatBE),
                float64: read(8, readDoubleBE),
            };
            return readFormat;
        }

        function map_to_obj(decoder, len) {
            var value = {};
            var i;
            var k = new Array(len);
            var v = new Array(len);
            var decode = decoder.codec.decode;
            for (i = 0; i < len; i++) {
                k[i] = decode(decoder);
                v[i] = decode(decoder);
            }
            for (i = 0; i < len; i++) {
                value[k[i]] = v[i];
            }
            return value;
        }

        function map_to_map(decoder, len) {
            var value = new Map();
            var i;
            var k = new Array(len);
            var v = new Array(len);
            var decode = decoder.codec.decode;
            for (i = 0; i < len; i++) {
                k[i] = decode(decoder);
                v[i] = decode(decoder);
            }
            for (i = 0; i < len; i++) {
                value.set(k[i], v[i]);
            }
            return value;
        }

        function array(decoder, len) {
            var value = new Array(len);
            var decode = decoder.codec.decode;
            for (var i = 0; i < len; i++) {
                value[i] = decode(decoder);
            }
            return value;
        }

        function str(decoder, len) {
            var start = decoder.reserve(len);
            var end = start + len;
            return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
        }

        function bin_buffer(decoder, len) {
            var start = decoder.reserve(len);
            var end = start + len;
            var buf = BufferProto.slice.call(decoder.buffer, start, end);
            return Bufferish.from(buf);
        }

        function bin_arraybuffer(decoder, len) {
            var start = decoder.reserve(len);
            var end = start + len;
            var buf = BufferProto.slice.call(decoder.buffer, start, end);
            return Bufferish.Uint8Array.from(buf).buffer;
        }

        function ext(decoder, len) {
            var start = decoder.reserve(len + 1);
            var type = decoder.buffer[start++];
            var end = start + len;
            var unpack = decoder.codec.getExtUnpacker(type);
            if (!unpack)
                throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
            var buf = BufferProto.slice.call(decoder.buffer, start, end);
            return unpack(buf);
        }

        function uint8(decoder) {
            var start = decoder.reserve(1);
            return decoder.buffer[start];
        }

        function int8(decoder) {
            var start = decoder.reserve(1);
            var value = decoder.buffer[start];
            return value & 0x80 ? value - 0x100 : value;
        }

        function uint16(decoder) {
            var start = decoder.reserve(2);
            var buffer = decoder.buffer;
            return (buffer[start++] << 8) | buffer[start];
        }

        function int16(decoder) {
            var start = decoder.reserve(2);
            var buffer = decoder.buffer;
            var value = (buffer[start++] << 8) | buffer[start];
            return value & 0x8000 ? value - 0x10000 : value;
        }

        function uint32(decoder) {
            var start = decoder.reserve(4);
            var buffer = decoder.buffer;
            return (buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start]);
        }

        function int32(decoder) {
            var start = decoder.reserve(4);
            var buffer = decoder.buffer;
            return ((buffer[start++] << 24) | (buffer[start++] << 16) | (buffer[start++] << 8) | buffer[start]);
        }

        function read(len, method) {
            return function(decoder) {
                var start = decoder.reserve(len);
                return method.call(decoder.buffer, start, NO_ASSERT);
            }
            ;
        }

        function readUInt64BE(start) {
            return new Uint64BE(this,start).toNumber();
        }

        function readInt64BE(start) {
            return new Int64BE(this,start).toNumber();
        }

        function readUInt64BE_int64(start) {
            return new Uint64BE(this,start);
        }

        function readInt64BE_int64(start) {
            return new Int64BE(this,start);
        }

        function readFloatBE(start) {
            return ieee754.read(this, start, false, 23, 4);
        }

        function readDoubleBE(start) {
            return ieee754.read(this, start, false, 52, 8);
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/read-token.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-token.js ***!
  \*****************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // read-token.js
        var ReadFormat = __webpack_require__(/*! ./read-format */
        "./node_modules/msgpack-lite/lib/read-format.js");
        exports.getReadToken = getReadToken;

        function getReadToken(options) {
            var format = ReadFormat.getReadFormat(options);
            if (options && options.useraw) {
                return init_useraw(format);
            } else {
                return init_token(format);
            }
        }

        function init_token(format) {
            var i;
            var token = new Array(256);
            // positive fixint -- 0x00 - 0x7f
            for (i = 0x00; i <= 0x7f; i++) {
                token[i] = constant(i);
            }
            // fixmap -- 0x80 - 0x8f
            for (i = 0x80; i <= 0x8f; i++) {
                token[i] = fix(i - 0x80, format.map);
            }
            // fixarray -- 0x90 - 0x9f
            for (i = 0x90; i <= 0x9f; i++) {
                token[i] = fix(i - 0x90, format.array);
            }
            // fixstr -- 0xa0 - 0xbf
            for (i = 0xa0; i <= 0xbf; i++) {
                token[i] = fix(i - 0xa0, format.str);
            }
            // nil -- 0xc0
            token[0xc0] = constant(null);
            // (never used) -- 0xc1
            token[0xc1] = null;
            // false -- 0xc2
            // true -- 0xc3
            token[0xc2] = constant(false);
            token[0xc3] = constant(true);
            // bin 8 -- 0xc4
            // bin 16 -- 0xc5
            // bin 32 -- 0xc6
            token[0xc4] = flex(format.uint8, format.bin);
            token[0xc5] = flex(format.uint16, format.bin);
            token[0xc6] = flex(format.uint32, format.bin);
            // ext 8 -- 0xc7
            // ext 16 -- 0xc8
            // ext 32 -- 0xc9
            token[0xc7] = flex(format.uint8, format.ext);
            token[0xc8] = flex(format.uint16, format.ext);
            token[0xc9] = flex(format.uint32, format.ext);
            // float 32 -- 0xca
            // float 64 -- 0xcb
            token[0xca] = format.float32;
            token[0xcb] = format.float64;
            // uint 8 -- 0xcc
            // uint 16 -- 0xcd
            // uint 32 -- 0xce
            // uint 64 -- 0xcf
            token[0xcc] = format.uint8;
            token[0xcd] = format.uint16;
            token[0xce] = format.uint32;
            token[0xcf] = format.uint64;
            // int 8 -- 0xd0
            // int 16 -- 0xd1
            // int 32 -- 0xd2
            // int 64 -- 0xd3
            token[0xd0] = format.int8;
            token[0xd1] = format.int16;
            token[0xd2] = format.int32;
            token[0xd3] = format.int64;
            // fixext 1 -- 0xd4
            // fixext 2 -- 0xd5
            // fixext 4 -- 0xd6
            // fixext 8 -- 0xd7
            // fixext 16 -- 0xd8
            token[0xd4] = fix(1, format.ext);
            token[0xd5] = fix(2, format.ext);
            token[0xd6] = fix(4, format.ext);
            token[0xd7] = fix(8, format.ext);
            token[0xd8] = fix(16, format.ext);
            // str 8 -- 0xd9
            // str 16 -- 0xda
            // str 32 -- 0xdb
            token[0xd9] = flex(format.uint8, format.str);
            token[0xda] = flex(format.uint16, format.str);
            token[0xdb] = flex(format.uint32, format.str);
            // array 16 -- 0xdc
            // array 32 -- 0xdd
            token[0xdc] = flex(format.uint16, format.array);
            token[0xdd] = flex(format.uint32, format.array);
            // map 16 -- 0xde
            // map 32 -- 0xdf
            token[0xde] = flex(format.uint16, format.map);
            token[0xdf] = flex(format.uint32, format.map);
            // negative fixint -- 0xe0 - 0xff
            for (i = 0xe0; i <= 0xff; i++) {
                token[i] = constant(i - 0x100);
            }
            return token;
        }

        function init_useraw(format) {
            var i;
            var token = init_token(format).slice();
            // raw 8 -- 0xd9
            // raw 16 -- 0xda
            // raw 32 -- 0xdb
            token[0xd9] = token[0xc4];
            token[0xda] = token[0xc5];
            token[0xdb] = token[0xc6];
            // fixraw -- 0xa0 - 0xbf
            for (i = 0xa0; i <= 0xbf; i++) {
                token[i] = fix(i - 0xa0, format.bin);
            }
            return token;
        }

        function constant(value) {
            return function() {
                return value;
            }
            ;
        }

        function flex(lenFunc, decodeFunc) {
            return function(decoder) {
                var len = lenFunc(decoder);
                return decodeFunc(decoder, len);
            }
            ;
        }

        function fix(len, method) {
            return function(decoder) {
                return method(decoder, len);
            }
            ;
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/write-core.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-core.js ***!
  \*****************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // write-core.js
        var ExtBuffer = __webpack_require__(/*! ./ext-buffer */
        "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
        var ExtPacker = __webpack_require__(/*! ./ext-packer */
        "./node_modules/msgpack-lite/lib/ext-packer.js");
        var WriteType = __webpack_require__(/*! ./write-type */
        "./node_modules/msgpack-lite/lib/write-type.js");
        var CodecBase = __webpack_require__(/*! ./codec-base */
        "./node_modules/msgpack-lite/lib/codec-base.js");
        CodecBase.install({
            addExtPacker: addExtPacker,
            getExtPacker: getExtPacker,
            init: init,
        });
        exports.preset = init.call(CodecBase.preset);

        function getEncoder(options) {
            var writeType = WriteType.getWriteType(options);
            return encode;

            function encode(encoder, value) {
                var func = writeType[typeof value];
                if (!func)
                    throw new Error('Unsupported type "' + typeof value + '": ' + value);
                func(encoder, value);
            }
        }

        function init() {
            var options = this.options;
            this.encode = getEncoder(options);
            if (options && options.preset) {
                ExtPacker.setExtPackers(this);
            }
            return this;
        }

        function addExtPacker(etype, Class, packer) {
            packer = CodecBase.filter(packer);
            var name = Class.name;
            if (name && name !== "Object") {
                var packers = this.extPackers || (this.extPackers = {});
                packers[name] = extPacker;
            } else {
                // fallback for IE
                var list = this.extEncoderList || (this.extEncoderList = []);
                list.unshift([Class, extPacker]);
            }

            function extPacker(value) {
                if (packer)
                    value = packer(value);
                return new ExtBuffer(value,etype);
            }
        }

        function getExtPacker(value) {
            var packers = this.extPackers || (this.extPackers = {});
            var c = value.constructor;
            var e = c && c.name && packers[c.name];
            if (e)
                return e;
            // fallback for IE
            var list = this.extEncoderList || (this.extEncoderList = []);
            var len = list.length;
            for (var i = 0; i < len; i++) {
                var pair = list[i];
                if (c === pair[0])
                    return pair[1];
            }
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/write-token.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-token.js ***!
  \******************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // write-token.js
        var ieee754 = __webpack_require__(/*! ieee754 */
        "./node_modules/ieee754/index.js");
        var Int64Buffer = __webpack_require__(/*! int64-buffer */
        "./node_modules/int64-buffer/int64-buffer.js");
        var Uint64BE = Int64Buffer.Uint64BE;
        var Int64BE = Int64Buffer.Int64BE;
        var uint8 = __webpack_require__(/*! ./write-uint8 */
        "./node_modules/msgpack-lite/lib/write-uint8.js").uint8;
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var Buffer = Bufferish.global;
        var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT"in Buffer;
        var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;
        var Buffer_prototype = (Bufferish.hasBuffer && Buffer.prototype) || {};
        exports.getWriteToken = getWriteToken;

        function getWriteToken(options) {
            if (options && options.uint8array) {
                return init_uint8array();
            } else if (NO_TYPED_ARRAY || (Bufferish.hasBuffer && options && options.safe)) {
                return init_safe();
            } else {
                return init_token();
            }
        }

        function init_uint8array() {
            var token = init_token();
            // float 32 -- 0xca
            // float 64 -- 0xcb
            token[0xca] = writeN(0xca, 4, writeFloatBE);
            token[0xcb] = writeN(0xcb, 8, writeDoubleBE);
            return token;
        }
        // Node.js and browsers with TypedArray
        function init_token() {
            // (immediate values)
            // positive fixint -- 0x00 - 0x7f
            // nil -- 0xc0
            // false -- 0xc2
            // true -- 0xc3
            // negative fixint -- 0xe0 - 0xff
            var token = uint8.slice();
            // bin 8 -- 0xc4
            // bin 16 -- 0xc5
            // bin 32 -- 0xc6
            token[0xc4] = write1(0xc4);
            token[0xc5] = write2(0xc5);
            token[0xc6] = write4(0xc6);
            // ext 8 -- 0xc7
            // ext 16 -- 0xc8
            // ext 32 -- 0xc9
            token[0xc7] = write1(0xc7);
            token[0xc8] = write2(0xc8);
            token[0xc9] = write4(0xc9);
            // float 32 -- 0xca
            // float 64 -- 0xcb
            token[0xca] = writeN(0xca, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
            token[0xcb] = writeN(0xcb, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
            // uint 8 -- 0xcc
            // uint 16 -- 0xcd
            // uint 32 -- 0xce
            // uint 64 -- 0xcf
            token[0xcc] = write1(0xcc);
            token[0xcd] = write2(0xcd);
            token[0xce] = write4(0xce);
            token[0xcf] = writeN(0xcf, 8, writeUInt64BE);
            // int 8 -- 0xd0
            // int 16 -- 0xd1
            // int 32 -- 0xd2
            // int 64 -- 0xd3
            token[0xd0] = write1(0xd0);
            token[0xd1] = write2(0xd1);
            token[0xd2] = write4(0xd2);
            token[0xd3] = writeN(0xd3, 8, writeInt64BE);
            // str 8 -- 0xd9
            // str 16 -- 0xda
            // str 32 -- 0xdb
            token[0xd9] = write1(0xd9);
            token[0xda] = write2(0xda);
            token[0xdb] = write4(0xdb);
            // array 16 -- 0xdc
            // array 32 -- 0xdd
            token[0xdc] = write2(0xdc);
            token[0xdd] = write4(0xdd);
            // map 16 -- 0xde
            // map 32 -- 0xdf
            token[0xde] = write2(0xde);
            token[0xdf] = write4(0xdf);
            return token;
        }
        // safe mode: for old browsers and who needs asserts
        function init_safe() {
            // (immediate values)
            // positive fixint -- 0x00 - 0x7f
            // nil -- 0xc0
            // false -- 0xc2
            // true -- 0xc3
            // negative fixint -- 0xe0 - 0xff
            var token = uint8.slice();
            // bin 8 -- 0xc4
            // bin 16 -- 0xc5
            // bin 32 -- 0xc6
            token[0xc4] = writeN(0xc4, 1, Buffer.prototype.writeUInt8);
            token[0xc5] = writeN(0xc5, 2, Buffer.prototype.writeUInt16BE);
            token[0xc6] = writeN(0xc6, 4, Buffer.prototype.writeUInt32BE);
            // ext 8 -- 0xc7
            // ext 16 -- 0xc8
            // ext 32 -- 0xc9
            token[0xc7] = writeN(0xc7, 1, Buffer.prototype.writeUInt8);
            token[0xc8] = writeN(0xc8, 2, Buffer.prototype.writeUInt16BE);
            token[0xc9] = writeN(0xc9, 4, Buffer.prototype.writeUInt32BE);
            // float 32 -- 0xca
            // float 64 -- 0xcb
            token[0xca] = writeN(0xca, 4, Buffer.prototype.writeFloatBE);
            token[0xcb] = writeN(0xcb, 8, Buffer.prototype.writeDoubleBE);
            // uint 8 -- 0xcc
            // uint 16 -- 0xcd
            // uint 32 -- 0xce
            // uint 64 -- 0xcf
            token[0xcc] = writeN(0xcc, 1, Buffer.prototype.writeUInt8);
            token[0xcd] = writeN(0xcd, 2, Buffer.prototype.writeUInt16BE);
            token[0xce] = writeN(0xce, 4, Buffer.prototype.writeUInt32BE);
            token[0xcf] = writeN(0xcf, 8, writeUInt64BE);
            // int 8 -- 0xd0
            // int 16 -- 0xd1
            // int 32 -- 0xd2
            // int 64 -- 0xd3
            token[0xd0] = writeN(0xd0, 1, Buffer.prototype.writeInt8);
            token[0xd1] = writeN(0xd1, 2, Buffer.prototype.writeInt16BE);
            token[0xd2] = writeN(0xd2, 4, Buffer.prototype.writeInt32BE);
            token[0xd3] = writeN(0xd3, 8, writeInt64BE);
            // str 8 -- 0xd9
            // str 16 -- 0xda
            // str 32 -- 0xdb
            token[0xd9] = writeN(0xd9, 1, Buffer.prototype.writeUInt8);
            token[0xda] = writeN(0xda, 2, Buffer.prototype.writeUInt16BE);
            token[0xdb] = writeN(0xdb, 4, Buffer.prototype.writeUInt32BE);
            // array 16 -- 0xdc
            // array 32 -- 0xdd
            token[0xdc] = writeN(0xdc, 2, Buffer.prototype.writeUInt16BE);
            token[0xdd] = writeN(0xdd, 4, Buffer.prototype.writeUInt32BE);
            // map 16 -- 0xde
            // map 32 -- 0xdf
            token[0xde] = writeN(0xde, 2, Buffer.prototype.writeUInt16BE);
            token[0xdf] = writeN(0xdf, 4, Buffer.prototype.writeUInt32BE);
            return token;
        }

        function write1(type) {
            return function(encoder, value) {
                var offset = encoder.reserve(2);
                var buffer = encoder.buffer;
                buffer[offset++] = type;
                buffer[offset] = value;
            }
            ;
        }

        function write2(type) {
            return function(encoder, value) {
                var offset = encoder.reserve(3);
                var buffer = encoder.buffer;
                buffer[offset++] = type;
                buffer[offset++] = value >>> 8;
                buffer[offset] = value;
            }
            ;
        }

        function write4(type) {
            return function(encoder, value) {
                var offset = encoder.reserve(5);
                var buffer = encoder.buffer;
                buffer[offset++] = type;
                buffer[offset++] = value >>> 24;
                buffer[offset++] = value >>> 16;
                buffer[offset++] = value >>> 8;
                buffer[offset] = value;
            }
            ;
        }

        function writeN(type, len, method, noAssert) {
            return function(encoder, value) {
                var offset = encoder.reserve(len + 1);
                encoder.buffer[offset++] = type;
                method.call(encoder.buffer, value, offset, noAssert);
            }
            ;
        }

        function writeUInt64BE(value, offset) {
            new Uint64BE(this,offset,value);
        }

        function writeInt64BE(value, offset) {
            new Int64BE(this,offset,value);
        }

        function writeFloatBE(value, offset) {
            ieee754.write(this, value, offset, false, 23, 4);
        }

        function writeDoubleBE(value, offset) {
            ieee754.write(this, value, offset, false, 52, 8);
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/write-type.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-type.js ***!
  \*****************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        // write-type.js
        var IS_ARRAY = __webpack_require__(/*! isarray */
        "./node_modules/msgpack-lite/node_modules/isarray/index.js");
        var Int64Buffer = __webpack_require__(/*! int64-buffer */
        "./node_modules/int64-buffer/int64-buffer.js");
        var Uint64BE = Int64Buffer.Uint64BE;
        var Int64BE = Int64Buffer.Int64BE;
        var Bufferish = __webpack_require__(/*! ./bufferish */
        "./node_modules/msgpack-lite/lib/bufferish.js");
        var BufferProto = __webpack_require__(/*! ./bufferish-proto */
        "./node_modules/msgpack-lite/lib/bufferish-proto.js");
        var WriteToken = __webpack_require__(/*! ./write-token */
        "./node_modules/msgpack-lite/lib/write-token.js");
        var uint8 = __webpack_require__(/*! ./write-uint8 */
        "./node_modules/msgpack-lite/lib/write-uint8.js").uint8;
        var ExtBuffer = __webpack_require__(/*! ./ext-buffer */
        "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
        var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
        var HAS_MAP = "undefined" !== typeof Map;
        var extmap = [];
        extmap[1] = 0xd4;
        extmap[2] = 0xd5;
        extmap[4] = 0xd6;
        extmap[8] = 0xd7;
        extmap[16] = 0xd8;
        exports.getWriteType = getWriteType;

        function getWriteType(options) {
            var token = WriteToken.getWriteToken(options);
            var useraw = options && options.useraw;
            var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
            var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
            var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
            var usemap = HAS_MAP && options && options.usemap;
            var map = usemap ? map_to_map : obj_to_map;
            var writeType = {
                boolean: bool,
                function: nil,
                number: number,
                object: useraw ? object_raw : object,
                string: _string(useraw ? raw_head_size : str_head_size),
                symbol: nil,
                undefined: nil,
            };
            return writeType;
            // false -- 0xc2
            // true -- 0xc3
            function bool(encoder, value) {
                var type = value ? 0xc3 : 0xc2;
                token[type](encoder, value);
            }

            function number(encoder, value) {
                var ivalue = value | 0;
                var type;
                if (value !== ivalue) {
                    // float 64 -- 0xcb
                    type = 0xcb;
                    token[type](encoder, value);
                    return;
                } else if (-0x20 <= ivalue && ivalue <= 0x7f) {
                    // positive fixint -- 0x00 - 0x7f
                    // negative fixint -- 0xe0 - 0xff
                    type = ivalue & 0xff;
                } else if (0 <= ivalue) {
                    // uint 8 -- 0xcc
                    // uint 16 -- 0xcd
                    // uint 32 -- 0xce
                    type = ivalue <= 0xff ? 0xcc : ivalue <= 0xffff ? 0xcd : 0xce;
                } else {
                    // int 8 -- 0xd0
                    // int 16 -- 0xd1
                    // int 32 -- 0xd2
                    type = -0x80 <= ivalue ? 0xd0 : -0x8000 <= ivalue ? 0xd1 : 0xd2;
                }
                token[type](encoder, ivalue);
            }
            // uint 64 -- 0xcf
            function uint64(encoder, value) {
                var type = 0xcf;
                token[type](encoder, value.toArray());
            }
            // int 64 -- 0xd3
            function int64(encoder, value) {
                var type = 0xd3;
                token[type](encoder, value.toArray());
            }
            // str 8 -- 0xd9
            // str 16 -- 0xda
            // str 32 -- 0xdb
            // fixstr -- 0xa0 - 0xbf
            function str_head_size(length) {
                return length < 32 ? 1 : length <= 0xff ? 2 : length <= 0xffff ? 3 : 5;
            }
            // raw 16 -- 0xda
            // raw 32 -- 0xdb
            // fixraw -- 0xa0 - 0xbf
            function raw_head_size(length) {
                return length < 32 ? 1 : length <= 0xffff ? 3 : 5;
            }

            function _string(head_size) {
                return string;

                function string(encoder, value) {
                    // prepare buffer
                    var length = value.length;
                    var maxsize = 5 + length * 3;
                    encoder.offset = encoder.reserve(maxsize);
                    var buffer = encoder.buffer;
                    // expected header size
                    var expected = head_size(length);
                    // expected start point
                    var start = encoder.offset + expected;
                    // write string
                    length = BufferProto.write.call(buffer, value, start);
                    // actual header size
                    var actual = head_size(length);
                    // move content when needed
                    if (expected !== actual) {
                        var targetStart = start + actual - expected;
                        var end = start + length;
                        BufferProto.copy.call(buffer, buffer, targetStart, start, end);
                    }
                    // write header
                    var type = actual === 1 ? 0xa0 + length : actual <= 3 ? 0xd7 + actual : 0xdb;
                    token[type](encoder, length);
                    // move cursor
                    encoder.offset += length;
                }
            }

            function object(encoder, value) {
                // null
                if (value === null)
                    return nil(encoder, value);
                // Buffer
                if (isBuffer(value))
                    return bin(encoder, value);
                // Array
                if (IS_ARRAY(value))
                    return array(encoder, value);
                // int64-buffer objects
                if (Uint64BE.isUint64BE(value))
                    return uint64(encoder, value);
                if (Int64BE.isInt64BE(value))
                    return int64(encoder, value);
                // ext formats
                var packer = encoder.codec.getExtPacker(value);
                if (packer)
                    value = packer(value);
                if (value instanceof ExtBuffer)
                    return ext(encoder, value);
                // plain old Objects or Map
                map(encoder, value);
            }

            function object_raw(encoder, value) {
                // Buffer
                if (isBuffer(value))
                    return raw(encoder, value);
                // others
                object(encoder, value);
            }
            // nil -- 0xc0
            function nil(encoder, value) {
                var type = 0xc0;
                token[type](encoder, value);
            }
            // fixarray -- 0x90 - 0x9f
            // array 16 -- 0xdc
            // array 32 -- 0xdd
            function array(encoder, value) {
                var length = value.length;
                var type = length < 16 ? 0x90 + length : length <= 0xffff ? 0xdc : 0xdd;
                token[type](encoder, length);
                var encode = encoder.codec.encode;
                for (var i = 0; i < length; i++) {
                    encode(encoder, value[i]);
                }
            }
            // bin 8 -- 0xc4
            // bin 16 -- 0xc5
            // bin 32 -- 0xc6
            function bin_buffer(encoder, value) {
                var length = value.length;
                var type = length < 0xff ? 0xc4 : length <= 0xffff ? 0xc5 : 0xc6;
                token[type](encoder, length);
                encoder.send(value);
            }

            function bin_arraybuffer(encoder, value) {
                bin_buffer(encoder, new Uint8Array(value));
            }
            // fixext 1 -- 0xd4
            // fixext 2 -- 0xd5
            // fixext 4 -- 0xd6
            // fixext 8 -- 0xd7
            // fixext 16 -- 0xd8
            // ext 8 -- 0xc7
            // ext 16 -- 0xc8
            // ext 32 -- 0xc9
            function ext(encoder, value) {
                var buffer = value.buffer;
                var length = buffer.length;
                var type = extmap[length] || (length < 0xff ? 0xc7 : length <= 0xffff ? 0xc8 : 0xc9);
                token[type](encoder, length);
                uint8[value.type](encoder);
                encoder.send(buffer);
            }
            // fixmap -- 0x80 - 0x8f
            // map 16 -- 0xde
            // map 32 -- 0xdf
            function obj_to_map(encoder, value) {
                var keys = Object.keys(value);
                var length = keys.length;
                var type = length < 16 ? 0x80 + length : length <= 0xffff ? 0xde : 0xdf;
                token[type](encoder, length);
                var encode = encoder.codec.encode;
                keys.forEach(function(key) {
                    encode(encoder, key);
                    encode(encoder, value[key]);
                });
            }
            // fixmap -- 0x80 - 0x8f
            // map 16 -- 0xde
            // map 32 -- 0xdf
            function map_to_map(encoder, value) {
                if (!(value instanceof Map))
                    return obj_to_map(encoder, value);
                var length = value.size;
                var type = length < 16 ? 0x80 + length : length <= 0xffff ? 0xde : 0xdf;
                token[type](encoder, length);
                var encode = encoder.codec.encode;
                value.forEach(function(val, key, m) {
                    encode(encoder, key);
                    encode(encoder, val);
                });
            }
            // raw 16 -- 0xda
            // raw 32 -- 0xdb
            // fixraw -- 0xa0 - 0xbf
            function raw(encoder, value) {
                var length = value.length;
                var type = length < 32 ? 0xa0 + length : length <= 0xffff ? 0xda : 0xdb;
                token[type](encoder, length);
                encoder.send(value);
            }
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/lib/write-uint8.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-uint8.js ***!
  \******************************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // write-unit8.js
        var constant = (exports.uint8 = new Array(256));
        for (var i = 0x00; i <= 0xff; i++) {
            constant[i] = write0(i);
        }

        function write0(type) {
            return function(encoder) {
                var offset = encoder.reserve(1);
                encoder.buffer[offset] = type;
            }
            ;
        }
        /***/
    },
    /***/
    "./node_modules/msgpack-lite/node_modules/isarray/index.js": /*!*****************************************************************!*\
  !*** ./node_modules/msgpack-lite/node_modules/isarray/index.js ***!
  \*****************************************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        var toString = {}.toString;
        module.exports = Array.isArray || function(arr) {
            return toString.call(arr) == "[object Array]";
        }
        ;
        /***/
    },
    /***/
    "./node_modules/process/browser.js": /*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // shim for using process in browser
        var process = (module.exports = {});
        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.
        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }

        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        (function() {
            try {
                if (typeof setTimeout === "function") {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === "function") {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }
        )();

        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                //normal enviroments in sane situations
                return setTimeout(fun, 0);
            }
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }

        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                //normal enviroments in sane situations
                return clearTimeout(marker);
            }
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }

        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun,args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        }
        ;
        // v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }
        ;
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
            return [];
        }
        ;
        process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }
        ;
        process.cwd = function() {
            return "/";
        }
        ;
        process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }
        ;
        process.umask = function() {
            return 0;
        }
        ;
        /***/
    },
    /***/
    "./node_modules/punycode/punycode.js": /*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(module, global) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            /*! https://mths.be/punycode v1.4.1 by @mathias */
            (function(root) {
                /** Detect free variables */
                var freeExports = true && exports && !exports.nodeType && exports;
                var freeModule = true && module && !module.nodeType && module;
                var freeGlobal = typeof global == "object" && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                    root = freeGlobal;
                }
                /**
                         * The `punycode` object.
                         * @name punycode
                         * @type Object
                         */
                var punycode, /** Highest positive signed 32-bit float value */
                maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
                /** Bootstring parameters */
                base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, // 0x80
                delimiter = "-", // '\x2D'
                /** Regular expressions */
                regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
                /** Error messages */
                errors = {
                    overflow: "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input",
                }, /** Convenience shortcuts */
                baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, /** Temporary variable */
                key;
                /*--------------------------------------------------------------------------*/
                /**
                         * A generic error utility function.
                         * @private
                         * @param {String} type The error type.
                         * @returns {Error} Throws a `RangeError` with the applicable error message.
                         */
                function error(type) {
                    throw new RangeError(errors[type]);
                }
                /**
                         * A generic `Array#map` utility function.
                         * @private
                         * @param {Array} array The array to iterate over.
                         * @param {Function} callback The function that gets called for every array
                         * item.
                         * @returns {Array} A new array of values returned by the callback function.
                         */
                function map(array, fn) {
                    var length = array.length;
                    var result = [];
                    while (length--) {
                        result[length] = fn(array[length]);
                    }
                    return result;
                }
                /**
                         * A simple `Array#map`-like wrapper to work with domain name strings or email
                         * addresses.
                         * @private
                         * @param {String} domain The domain name or email address.
                         * @param {Function} callback The function that gets called for every
                         * character.
                         * @returns {Array} A new string of characters returned by the callback
                         * function.
                         */
                function mapDomain(string, fn) {
                    var parts = string.split("@");
                    var result = "";
                    if (parts.length > 1) {
                        // In email addresses, only the domain name should be punycoded. Leave
                        // the local part (i.e. everything up to `@`) intact.
                        result = parts[0] + "@";
                        string = parts[1];
                    }
                    // Avoid `split(regex)` for IE8 compatibility. See #17.
                    string = string.replace(regexSeparators, ".");
                    var labels = string.split(".");
                    var encoded = map(labels, fn).join(".");
                    return result + encoded;
                }
                /**
                         * Creates an array containing the numeric code points of each Unicode
                         * character in the string. While JavaScript uses UCS-2 internally,
                         * this function will convert a pair of surrogate halves (each of which
                         * UCS-2 exposes as separate characters) into a single code point,
                         * matching UTF-16.
                         * @see `punycode.ucs2.encode`
                         * @see <https://mathiasbynens.be/notes/javascript-encoding>
                         * @memberOf punycode.ucs2
                         * @name decode
                         * @param {String} string The Unicode input string (UCS-2).
                         * @returns {Array} The new array of code points.
                         */
                function ucs2decode(string) {
                    var output = [], counter = 0, length = string.length, value, extra;
                    while (counter < length) {
                        value = string.charCodeAt(counter++);
                        if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                            // high surrogate, and there is a next character
                            extra = string.charCodeAt(counter++);
                            if ((extra & 0xfc00) == 0xdc00) {
                                // low surrogate
                                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
                            } else {
                                // unmatched surrogate; only append this code unit, in case the next
                                // code unit is the high surrogate of a surrogate pair
                                output.push(value);
                                counter--;
                            }
                        } else {
                            output.push(value);
                        }
                    }
                    return output;
                }
                /**
                         * Creates a string based on an array of numeric code points.
                         * @see `punycode.ucs2.decode`
                         * @memberOf punycode.ucs2
                         * @name encode
                         * @param {Array} codePoints The array of numeric code points.
                         * @returns {String} The new Unicode string (UCS-2).
                         */
                function ucs2encode(array) {
                    return map(array, function(value) {
                        var output = "";
                        if (value > 0xffff) {
                            value -= 0x10000;
                            output += stringFromCharCode(((value >>> 10) & 0x3ff) | 0xd800);
                            value = 0xdc00 | (value & 0x3ff);
                        }
                        output += stringFromCharCode(value);
                        return output;
                    }).join("");
                }
                /**
                         * Converts a basic code point into a digit/integer.
                         * @see `digitToBasic()`
                         * @private
                         * @param {Number} codePoint The basic numeric code point value.
                         * @returns {Number} The numeric value of a basic code point (for use in
                         * representing integers) in the range `0` to `base - 1`, or `base` if
                         * the code point does not represent a value.
                         */
                function basicToDigit(codePoint) {
                    if (codePoint - 48 < 10) {
                        return codePoint - 22;
                    }
                    if (codePoint - 65 < 26) {
                        return codePoint - 65;
                    }
                    if (codePoint - 97 < 26) {
                        return codePoint - 97;
                    }
                    return base;
                }
                /**
                         * Converts a digit/integer into a basic code point.
                         * @see `basicToDigit()`
                         * @private
                         * @param {Number} digit The numeric value of a basic code point.
                         * @returns {Number} The basic code point whose value (when used for
                         * representing integers) is `digit`, which needs to be in the range
                         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                         * used; else, the lowercase form is used. The behavior is undefined
                         * if `flag` is non-zero and `digit` has no uppercase form.
                         */
                function digitToBasic(digit, flag) {
                    //  0..25 map to ASCII a..z or A..Z
                    // 26..35 map to ASCII 0..9
                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }
                /**
                         * Bias adaptation function as per section 3.4 of RFC 3492.
                         * https://tools.ietf.org/html/rfc3492#section-3.4
                         * @private
                         */
                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for (; /* no initialization */
                    delta > (baseMinusTMin * tMax) >> 1; k += base) {
                        delta = floor(delta / baseMinusTMin);
                    }
                    return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
                }
                /**
                         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                         * symbols.
                         * @memberOf punycode
                         * @param {String} input The Punycode string of ASCII-only symbols.
                         * @returns {String} The resulting string of Unicode symbols.
                         */
                function decode(input) {
                    // Don't use UCS-2
                    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, /** Cached calculation results */
                    baseMinusT;
                    // Handle the basic code points: let `basic` be the number of input code
                    // points before the last delimiter, or `0` if there is none, then copy
                    // the first basic code points to the output.
                    basic = input.lastIndexOf(delimiter);
                    if (basic < 0) {
                        basic = 0;
                    }
                    for (j = 0; j < basic; ++j) {
                        // if it's not a basic code point
                        if (input.charCodeAt(j) >= 0x80) {
                            error("not-basic");
                        }
                        output.push(input.charCodeAt(j));
                    }
                    // Main decoding loop: start just after the last delimiter if any basic code
                    // points were copied; start at the beginning otherwise.
                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */
                    ; ) {
                        // `index` is the index of the next character to be consumed.
                        // Decode a generalized variable-length integer into `delta`,
                        // which gets added to `i`. The overflow checking is easier
                        // if we increase `i` as we go, then subtract off its starting
                        // value at the end to obtain `delta`.
                        for (oldi = i,
                        w = 1,
                        k = base /* no condition */
                        ; ; k += base) {
                            if (index >= inputLength) {
                                error("invalid-input");
                            }
                            digit = basicToDigit(input.charCodeAt(index++));
                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                error("overflow");
                            }
                            i += digit * w;
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (digit < t) {
                                break;
                            }
                            baseMinusT = base - t;
                            if (w > floor(maxInt / baseMinusT)) {
                                error("overflow");
                            }
                            w *= baseMinusT;
                        }
                        out = output.length + 1;
                        bias = adapt(i - oldi, out, oldi == 0);
                        // `i` was supposed to wrap around from `out` to `0`,
                        // incrementing `n` each time, so we'll fix that now:
                        if (floor(i / out) > maxInt - n) {
                            error("overflow");
                        }
                        n += floor(i / out);
                        i %= out;
                        // Insert `n` at position `i` of the output
                        output.splice(i++, 0, n);
                    }
                    return ucs2encode(output);
                }
                /**
                         * Converts a string of Unicode symbols (e.g. a domain name label) to a
                         * Punycode string of ASCII-only symbols.
                         * @memberOf punycode
                         * @param {String} input The string of Unicode symbols.
                         * @returns {String} The resulting Punycode string of ASCII-only symbols.
                         */
                function encode(input) {
                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], /** `inputLength` will hold the number of code points in `input`. */
                    inputLength, /** Cached calculation results */
                    handledCPCountPlusOne, baseMinusT, qMinusT;
                    // Convert the input in UCS-2 to Unicode
                    input = ucs2decode(input);
                    // Cache the length
                    inputLength = input.length;
                    // Initialize the state
                    n = initialN;
                    delta = 0;
                    bias = initialBias;
                    // Handle the basic code points
                    for (j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue < 0x80) {
                            output.push(stringFromCharCode(currentValue));
                        }
                    }
                    handledCPCount = basicLength = output.length;
                    // `handledCPCount` is the number of code points that have been handled;
                    // `basicLength` is the number of basic code points.
                    // Finish the basic string - if it is not empty - with a delimiter
                    if (basicLength) {
                        output.push(delimiter);
                    }
                    // Main encoding loop:
                    while (handledCPCount < inputLength) {
                        // All non-basic code points < n have been handled already. Find the next
                        // larger one:
                        for (m = maxInt,
                        j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue >= n && currentValue < m) {
                                m = currentValue;
                            }
                        }
                        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                        // but guard against overflow
                        handledCPCountPlusOne = handledCPCount + 1;
                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                            error("overflow");
                        }
                        delta += (m - n) * handledCPCountPlusOne;
                        n = m;
                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue < n && ++delta > maxInt) {
                                error("overflow");
                            }
                            if (currentValue == n) {
                                // Represent delta as a generalized variable-length integer
                                for (q = delta,
                                k = base /* no condition */
                                ; ; k += base) {
                                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                    if (q < t) {
                                        break;
                                    }
                                    qMinusT = q - t;
                                    baseMinusT = base - t;
                                    output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));
                                    q = floor(qMinusT / baseMinusT);
                                }
                                output.push(stringFromCharCode(digitToBasic(q, 0)));
                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                delta = 0;
                                ++handledCPCount;
                            }
                        }
                        ++delta;
                        ++n;
                    }
                    return output.join("");
                }
                /**
                         * Converts a Punycode string representing a domain name or an email address
                         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                         * it doesn't matter if you call it on a string that has already been
                         * converted to Unicode.
                         * @memberOf punycode
                         * @param {String} input The Punycoded domain name or email address to
                         * convert to Unicode.
                         * @returns {String} The Unicode representation of the given Punycode
                         * string.
                         */
                function toUnicode(input) {
                    return mapDomain(input, function(string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                }
                /**
                         * Converts a Unicode string representing a domain name or an email address to
                         * Punycode. Only the non-ASCII parts of the domain name will be converted,
                         * i.e. it doesn't matter if you call it with a domain that's already in
                         * ASCII.
                         * @memberOf punycode
                         * @param {String} input The domain name or email address to convert, as a
                         * Unicode string.
                         * @returns {String} The Punycode representation of the given domain name or
                         * email address.
                         */
                function toASCII(input) {
                    return mapDomain(input, function(string) {
                        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                    });
                }
                /*--------------------------------------------------------------------------*/
                /** Define the public API */
                punycode = {
                    /**
                             * A string representing the current Punycode.js version number.
                             * @memberOf punycode
                             * @type String
                             */
                    version: "1.4.1",
                    /**
                             * An object of methods to convert from JavaScript's internal character
                             * representation (UCS-2) to Unicode code points, and back.
                             * @see <https://mathiasbynens.be/notes/javascript-encoding>
                             * @memberOf punycode
                             * @type Object
                             */
                    ucs2: {
                        decode: ucs2decode,
                        encode: ucs2encode,
                    },
                    decode: decode,
                    encode: encode,
                    toASCII: toASCII,
                    toUnicode: toUnicode,
                };
                /** Expose `punycode` */
                // Some AMD build optimizers, like r.js, check for specific condition patterns
                // like the following:
                if (true) {
                    !((__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return punycode;
                    }
                    .call(exports, __webpack_require__, exports, module)),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {}
            }
            )(this);
            /* WEBPACK VAR INJECTION */
        }
        ).call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */
        "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */
        "./node_modules/webpack/buildin/global.js"));
        /***/
    },
    /***/
    "./node_modules/querystring-es3/decode.js": /*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707
        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module.exports = function(qs, sep, eq, options) {
            sep = sep || "&";
            eq = eq || "=";
            var obj = {};
            if (typeof qs !== "string" || qs.length === 0) {
                return obj;
            }
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1000;
            if (options && typeof options.maxKeys === "number") {
                maxKeys = options.maxKeys;
            }
            var len = qs.length;
            // maxKeys <= 0 means that we should not limit keys count
            if (maxKeys > 0 && len > maxKeys) {
                len = maxKeys;
            }
            for (var i = 0; i < len; ++i) {
                var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
                if (idx >= 0) {
                    kstr = x.substr(0, idx);
                    vstr = x.substr(idx + 1);
                } else {
                    kstr = x;
                    vstr = "";
                }
                k = decodeURIComponent(kstr);
                v = decodeURIComponent(vstr);
                if (!hasOwnProperty(obj, k)) {
                    obj[k] = v;
                } else if (isArray(obj[k])) {
                    obj[k].push(v);
                } else {
                    obj[k] = [obj[k], v];
                }
            }
            return obj;
        }
        ;
        var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
        }
        ;
        /***/
    },
    /***/
    "./node_modules/querystring-es3/encode.js": /*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        var stringifyPrimitive = function(v) {
            switch (typeof v) {
            case "string":
                return v;
            case "boolean":
                return v ? "true" : "false";
            case "number":
                return isFinite(v) ? v : "";
            default:
                return "";
            }
        };
        module.exports = function(obj, sep, eq, name) {
            sep = sep || "&";
            eq = eq || "=";
            if (obj === null) {
                obj = undefined;
            }
            if (typeof obj === "object") {
                return map(objectKeys(obj), function(k) {
                    var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                    if (isArray(obj[k])) {
                        return map(obj[k], function(v) {
                            return ks + encodeURIComponent(stringifyPrimitive(v));
                        }).join(sep);
                    } else {
                        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                    }
                }).join(sep);
            }
            if (!name)
                return "";
            return (encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj)));
        }
        ;
        var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
        }
        ;

        function map(xs, f) {
            if (xs.map)
                return xs.map(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
                res.push(f(xs[i], i));
            }
            return res;
        }
        var objectKeys = Object.keys || function(obj) {
            var res = [];
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key))
                    res.push(key);
            }
            return res;
        }
        ;
        /***/
    },
    /***/
    "./node_modules/querystring-es3/index.js": /*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.decode = exports.parse = __webpack_require__(/*! ./decode */
        "./node_modules/querystring-es3/decode.js");
        exports.encode = exports.stringify = __webpack_require__(/*! ./encode */
        "./node_modules/querystring-es3/encode.js");
        /***/
    },
    /***/
    "./node_modules/url/url.js": /*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        var punycode = __webpack_require__(/*! punycode */
        "./node_modules/punycode/punycode.js");
        var util = __webpack_require__(/*! ./util */
        "./node_modules/url/util.js");
        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;
        exports.Url = Url;

        function Url() {
            this.protocol = null;
            this.slashes = null;
            this.auth = null;
            this.host = null;
            this.port = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.query = null;
            this.pathname = null;
            this.path = null;
            this.href = null;
        }
        // Reference: RFC 3986, RFC 1808, RFC 2396
        // define these here so at least they only have to be
        // compiled once on the first module load.
        var protocolPattern = /^([a-z0-9.+-]+:)/i
          , portPattern = /:[0-9]*$/
          , // Special case for a simple path URL
        simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/
          , // RFC 2396: characters reserved for delimiting URLs.
        // We actually just auto-escape these.
        delims = ["<", ">", '"', "`", " ", "\r", "\n", "\t"]
          , // RFC 2396: characters not allowed for various reasons.
        unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims)
          , // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
        autoEscape = ["'"].concat(unwise)
          , // Characters that are never ever allowed in a hostname.
        // Note that any invalid chars are also handled, but these
        // are the ones that are *expected* to be seen, so we fast-path
        // them.
        nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape)
          , hostEndingChars = ["/", "?", "#"]
          , hostnameMaxLen = 255
          , hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/
          , hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
          , // protocols that can allow "unsafe" and "unwise" chars.
        unsafeProtocol = {
            javascript: true,
            "javascript:": true,
        }
          , // protocols that never have a hostname.
        hostlessProtocol = {
            javascript: true,
            "javascript:": true,
        }
          , // protocols that always contain a // bit.
        slashedProtocol = {
            http: true,
            https: true,
            ftp: true,
            gopher: true,
            file: true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true,
        }
          , querystring = __webpack_require__(/*! querystring */
        "./node_modules/querystring-es3/index.js");

        function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && util.isObject(url) && url instanceof Url)
                return url;
            var u = new Url();
            u.parse(url, parseQueryString, slashesDenoteHost);
            return u;
        }
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
            if (!util.isString(url)) {
                throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
            }
            // Copy chrome, IE, opera backslash-handling behavior.
            // Back slashes before the query string get converted to forward slashes
            // See: https://code.google.com/p/chromium/issues/detail?id=25916
            var queryIndex = url.indexOf("?")
              , splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#"
              , uSplit = url.split(splitter)
              , slashRegex = /\\/g;
            uSplit[0] = uSplit[0].replace(slashRegex, "/");
            url = uSplit.join(splitter);
            var rest = url;
            // trim before proceeding.
            // This is to support parse stuff like "  http://foo.com  \n"
            rest = rest.trim();
            if (!slashesDenoteHost && url.split("#").length === 1) {
                // Try fast path regexp
                var simplePath = simplePathPattern.exec(rest);
                if (simplePath) {
                    this.path = rest;
                    this.href = rest;
                    this.pathname = simplePath[1];
                    if (simplePath[2]) {
                        this.search = simplePath[2];
                        if (parseQueryString) {
                            this.query = querystring.parse(this.search.substr(1));
                        } else {
                            this.query = this.search.substr(1);
                        }
                    } else if (parseQueryString) {
                        this.search = "";
                        this.query = {};
                    }
                    return this;
                }
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
                proto = proto[0];
                var lowerProto = proto.toLowerCase();
                this.protocol = lowerProto;
                rest = rest.substr(proto.length);
            }
            // figure out if it's got a host
            // user@server is *always* interpreted as a hostname, and url
            // resolution will treat //foo/bar as host=foo,path=bar because that's
            // how the browser resolves relative URLs.
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = rest.substr(0, 2) === "//";
                if (slashes && !(proto && hostlessProtocol[proto])) {
                    rest = rest.substr(2);
                    this.slashes = true;
                }
            }
            if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
                // there's a hostname.
                // the first instance of /, ?, ;, or # ends the host.
                //
                // If there is an @ in the hostname, then non-host chars *are* allowed
                // to the left of the last @ sign, unless some host-ending character
                // comes *before* the @-sign.
                // URLs are obnoxious.
                //
                // ex:
                // http://a@b@c/ => user:a@b host:c
                // http://a@b?@c => user:a host:c path:/?@c
                // v0.12 TODO(isaacs): This is not quite how Chrome does things.
                // Review our test case against browsers more comprehensively.
                // find the first instance of any hostEndingChars
                var hostEnd = -1;
                for (var i = 0; i < hostEndingChars.length; i++) {
                    var hec = rest.indexOf(hostEndingChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                        hostEnd = hec;
                }
                // at this point, either we have an explicit point where the
                // auth portion cannot go past, or the last @ char is the decider.
                var auth, atSign;
                if (hostEnd === -1) {
                    // atSign can be anywhere.
                    atSign = rest.lastIndexOf("@");
                } else {
                    // atSign must be in auth portion.
                    // http://a@b/c@d => host:b auth:a path:/c@d
                    atSign = rest.lastIndexOf("@", hostEnd);
                }
                // Now we have a portion which is definitely the auth.
                // Pull that off.
                if (atSign !== -1) {
                    auth = rest.slice(0, atSign);
                    rest = rest.slice(atSign + 1);
                    this.auth = decodeURIComponent(auth);
                }
                // the host is the remaining to the left of the first non-host char
                hostEnd = -1;
                for (var i = 0; i < nonHostChars.length; i++) {
                    var hec = rest.indexOf(nonHostChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                        hostEnd = hec;
                }
                // if we still have not hit it, then the entire thing is a host.
                if (hostEnd === -1)
                    hostEnd = rest.length;
                this.host = rest.slice(0, hostEnd);
                rest = rest.slice(hostEnd);
                // pull out port.
                this.parseHost();
                // we've indicated that there is a hostname,
                // so even if it's empty, it has to be present.
                this.hostname = this.hostname || "";
                // if hostname begins with [ and ends with ]
                // assume that it's an IPv6 address.
                var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                // validate a little.
                if (!ipv6Hostname) {
                    var hostparts = this.hostname.split(/\./);
                    for (var i = 0, l = hostparts.length; i < l; i++) {
                        var part = hostparts[i];
                        if (!part)
                            continue;
                        if (!part.match(hostnamePartPattern)) {
                            var newpart = "";
                            for (var j = 0, k = part.length; j < k; j++) {
                                if (part.charCodeAt(j) > 127) {
                                    // we replace non-ASCII char with a temporary placeholder
                                    // we need this to make sure size of hostname is not
                                    // broken by replacing non-ASCII by nothing
                                    newpart += "x";
                                } else {
                                    newpart += part[j];
                                }
                            }
                            // we test again with ASCII char only
                            if (!newpart.match(hostnamePartPattern)) {
                                var validParts = hostparts.slice(0, i);
                                var notHost = hostparts.slice(i + 1);
                                var bit = part.match(hostnamePartStart);
                                if (bit) {
                                    validParts.push(bit[1]);
                                    notHost.unshift(bit[2]);
                                }
                                if (notHost.length) {
                                    rest = "/" + notHost.join(".") + rest;
                                }
                                this.hostname = validParts.join(".");
                                break;
                            }
                        }
                    }
                }
                if (this.hostname.length > hostnameMaxLen) {
                    this.hostname = "";
                } else {
                    // hostnames are always lower case.
                    this.hostname = this.hostname.toLowerCase();
                }
                if (!ipv6Hostname) {
                    // IDNA Support: Returns a punycoded representation of "domain".
                    // It only converts parts of the domain name that
                    // have non-ASCII characters, i.e. it doesn't matter if
                    // you call it with a domain that already is ASCII-only.
                    this.hostname = punycode.toASCII(this.hostname);
                }
                var p = this.port ? ":" + this.port : "";
                var h = this.hostname || "";
                this.host = h + p;
                this.href += this.host;
                // strip [ and ] from the hostname
                // the host field still retains them, though
                if (ipv6Hostname) {
                    this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                    if (rest[0] !== "/") {
                        rest = "/" + rest;
                    }
                }
            }
            // now rest is set to the post-host stuff.
            // chop off any delim chars.
            if (!unsafeProtocol[lowerProto]) {
                // First, make 100% sure that any "autoEscape" chars get
                // escaped, even if encodeURIComponent doesn't think they
                // need to be.
                for (var i = 0, l = autoEscape.length; i < l; i++) {
                    var ae = autoEscape[i];
                    if (rest.indexOf(ae) === -1)
                        continue;
                    var esc = encodeURIComponent(ae);
                    if (esc === ae) {
                        esc = escape(ae);
                    }
                    rest = rest.split(ae).join(esc);
                }
            }
            // chop off from the tail first.
            var hash = rest.indexOf("#");
            if (hash !== -1) {
                // got a fragment string.
                this.hash = rest.substr(hash);
                rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf("?");
            if (qm !== -1) {
                this.search = rest.substr(qm);
                this.query = rest.substr(qm + 1);
                if (parseQueryString) {
                    this.query = querystring.parse(this.query);
                }
                rest = rest.slice(0, qm);
            } else if (parseQueryString) {
                // no query string, but parseQueryString still requested
                this.search = "";
                this.query = {};
            }
            if (rest)
                this.pathname = rest;
            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                this.pathname = "/";
            }
            //to support http.request
            if (this.pathname || this.search) {
                var p = this.pathname || "";
                var s = this.search || "";
                this.path = p + s;
            }
            // finally, reconstruct the href based on what has been validated.
            this.href = this.format();
            return this;
        }
        ;
        // format a parsed object into a url string
        function urlFormat(obj) {
            // ensure it's an object, and not a string url.
            // If it's an obj, this is a no-op.
            // this way, you can call url_format() on strings
            // to clean up potentially wonky urls.
            if (util.isString(obj))
                obj = urlParse(obj);
            if (!(obj instanceof Url))
                return Url.prototype.format.call(obj);
            return obj.format();
        }
        Url.prototype.format = function() {
            var auth = this.auth || "";
            if (auth) {
                auth = encodeURIComponent(auth);
                auth = auth.replace(/%3A/i, ":");
                auth += "@";
            }
            var protocol = this.protocol || ""
              , pathname = this.pathname || ""
              , hash = this.hash || ""
              , host = false
              , query = "";
            if (this.host) {
                host = auth + this.host;
            } else if (this.hostname) {
                host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
                if (this.port) {
                    host += ":" + this.port;
                }
            }
            if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
                query = querystring.stringify(this.query);
            }
            var search = this.search || (query && "?" + query) || "";
            if (protocol && protocol.substr(-1) !== ":")
                protocol += ":";
            // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
            // unless they had them to begin with.
            if (this.slashes || ((!protocol || slashedProtocol[protocol]) && host !== false)) {
                host = "//" + (host || "");
                if (pathname && pathname.charAt(0) !== "/")
                    pathname = "/" + pathname;
            } else if (!host) {
                host = "";
            }
            if (hash && hash.charAt(0) !== "#")
                hash = "#" + hash;
            if (search && search.charAt(0) !== "?")
                search = "?" + search;
            pathname = pathname.replace(/[?#]/g, function(match) {
                return encodeURIComponent(match);
            });
            search = search.replace("#", "%23");
            return protocol + host + pathname + search + hash;
        }
        ;

        function urlResolve(source, relative) {
            return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function(relative) {
            return this.resolveObject(urlParse(relative, false, true)).format();
        }
        ;

        function urlResolveObject(source, relative) {
            if (!source)
                return relative;
            return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function(relative) {
            if (util.isString(relative)) {
                var rel = new Url();
                rel.parse(relative, false, true);
                relative = rel;
            }
            var result = new Url();
            var tkeys = Object.keys(this);
            for (var tk = 0; tk < tkeys.length; tk++) {
                var tkey = tkeys[tk];
                result[tkey] = this[tkey];
            }
            // hash is always overridden, no matter what.
            // even href="" will remove it.
            result.hash = relative.hash;
            // if the relative url is empty, then there's nothing left to do here.
            if (relative.href === "") {
                result.href = result.format();
                return result;
            }
            // hrefs like //foo/bar always cut to the protocol.
            if (relative.slashes && !relative.protocol) {
                // take everything except the protocol from relative
                var rkeys = Object.keys(relative);
                for (var rk = 0; rk < rkeys.length; rk++) {
                    var rkey = rkeys[rk];
                    if (rkey !== "protocol")
                        result[rkey] = relative[rkey];
                }
                //urlParse appends trailing / to urls like http://www.example.com
                if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                    result.path = result.pathname = "/";
                }
                result.href = result.format();
                return result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
                // if it's a known url protocol, then changing
                // the protocol does weird things
                // first, if it's not file:, then we MUST have a host,
                // and if there was a path
                // to begin with, then we MUST have a path.
                // if it is file:, then the host is dropped,
                // because that's known to be hostless.
                // anything else is assumed to be absolute.
                if (!slashedProtocol[relative.protocol]) {
                    var keys = Object.keys(relative);
                    for (var v = 0; v < keys.length; v++) {
                        var k = keys[v];
                        result[k] = relative[k];
                    }
                    result.href = result.format();
                    return result;
                }
                result.protocol = relative.protocol;
                if (!relative.host && !hostlessProtocol[relative.protocol]) {
                    var relPath = (relative.pathname || "").split("/");
                    while (relPath.length && !(relative.host = relPath.shift()))
                        ;
                    if (!relative.host)
                        relative.host = "";
                    if (!relative.hostname)
                        relative.hostname = "";
                    if (relPath[0] !== "")
                        relPath.unshift("");
                    if (relPath.length < 2)
                        relPath.unshift("");
                    result.pathname = relPath.join("/");
                } else {
                    result.pathname = relative.pathname;
                }
                result.search = relative.search;
                result.query = relative.query;
                result.host = relative.host || "";
                result.auth = relative.auth;
                result.hostname = relative.hostname || relative.host;
                result.port = relative.port;
                // to support http.request
                if (result.pathname || result.search) {
                    var p = result.pathname || "";
                    var s = result.search || "";
                    result.path = p + s;
                }
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
            }
            var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/"
              , isRelAbs = relative.host || (relative.pathname && relative.pathname.charAt(0) === "/")
              , mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname)
              , removeAllDots = mustEndAbs
              , srcPath = (result.pathname && result.pathname.split("/")) || []
              , relPath = (relative.pathname && relative.pathname.split("/")) || []
              , psychotic = result.protocol && !slashedProtocol[result.protocol];
            // if the url is a non-slashed url, then relative
            // links like ../.. should be able
            // to crawl up to the hostname, as well.  This is strange.
            // result.protocol has already been set by now.
            // Later on, put the first path part into the host field.
            if (psychotic) {
                result.hostname = "";
                result.port = null;
                if (result.host) {
                    if (srcPath[0] === "")
                        srcPath[0] = result.host;
                    else
                        srcPath.unshift(result.host);
                }
                result.host = "";
                if (relative.protocol) {
                    relative.hostname = null;
                    relative.port = null;
                    if (relative.host) {
                        if (relPath[0] === "")
                            relPath[0] = relative.host;
                        else
                            relPath.unshift(relative.host);
                    }
                    relative.host = null;
                }
                mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
            }
            if (isRelAbs) {
                // it's absolute.
                result.host = relative.host || relative.host === "" ? relative.host : result.host;
                result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
                result.search = relative.search;
                result.query = relative.query;
                srcPath = relPath;
                // fall through to the dot-handling below.
            } else if (relPath.length) {
                // it's relative
                // throw away the existing file, and take the new path instead.
                if (!srcPath)
                    srcPath = [];
                srcPath.pop();
                srcPath = srcPath.concat(relPath);
                result.search = relative.search;
                result.query = relative.query;
            } else if (!util.isNullOrUndefined(relative.search)) {
                // just pull out the search.
                // like href='?foo'.
                // Put this after the other two cases because it simplifies the booleans
                if (psychotic) {
                    result.hostname = result.host = srcPath.shift();
                    //occationaly the auth can get stuck only in host
                    //this especially happens in cases like
                    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }
                result.search = relative.search;
                result.query = relative.query;
                //to support http.request
                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
                }
                result.href = result.format();
                return result;
            }
            if (!srcPath.length) {
                // no path at all.  easy.
                // we've already handled the other stuff above.
                result.pathname = null;
                //to support http.request
                if (result.search) {
                    result.path = "/" + result.search;
                } else {
                    result.path = null;
                }
                result.href = result.format();
                return result;
            }
            // if a url ENDs in . or .., then it must get a trailing slash.
            // however, if it ends in anything else non-slashy,
            // then it must NOT get a trailing slash.
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..")) || last === "";
            // strip single dots, resolve double dots to parent dir
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
                last = srcPath[i];
                if (last === ".") {
                    srcPath.splice(i, 1);
                } else if (last === "..") {
                    srcPath.splice(i, 1);
                    up++;
                } else if (up) {
                    srcPath.splice(i, 1);
                    up--;
                }
            }
            // if the path is allowed to go above the root, restore leading ..s
            if (!mustEndAbs && !removeAllDots) {
                for (; up--; up) {
                    srcPath.unshift("..");
                }
            }
            if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
                srcPath.unshift("");
            }
            if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
                srcPath.push("");
            }
            var isAbsolute = srcPath[0] === "" || (srcPath[0] && srcPath[0].charAt(0) === "/");
            // put the host back
            if (psychotic) {
                result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                //occationaly the auth can get stuck only in host
                //this especially happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }
            mustEndAbs = mustEndAbs || (result.host && srcPath.length);
            if (mustEndAbs && !isAbsolute) {
                srcPath.unshift("");
            }
            if (!srcPath.length) {
                result.pathname = null;
                result.path = null;
            } else {
                result.pathname = srcPath.join("/");
            }
            //to support request.http
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        }
        ;
        Url.prototype.parseHost = function() {
            var host = this.host;
            var port = portPattern.exec(host);
            if (port) {
                port = port[0];
                if (port !== ":") {
                    this.port = port.substr(1);
                }
                host = host.substr(0, host.length - port.length);
            }
            if (host)
                this.hostname = host;
        }
        ;
        /***/
    },
    /***/
    "./node_modules/url/util.js": /*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = {
            isString: function(arg) {
                return typeof arg === "string";
            },
            isObject: function(arg) {
                return typeof arg === "object" && arg !== null;
            },
            isNull: function(arg) {
                return arg === null;
            },
            isNullOrUndefined: function(arg) {
                return arg == null;
            },
        };
        /***/
    },
    /***/
    "./node_modules/webpack/buildin/global.js": /*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        var g;
        // This works in non-strict mode
        g = (function() {
            return this;
        }
        )();
        try {
            // This works if eval is allowed (see CSP)
            g = g || new Function("return this")();
        } catch (e) {
            // This works if the window reference is available
            if (typeof window === "object")
                g = window;
        }
        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}
        module.exports = g;
        /***/
    },
    /***/
    "./node_modules/webpack/buildin/module.js": /*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        module.exports = function(module) {
            if (!module.webpackPolyfill) {
                module.deprecate = function() {}
                ;
                module.paths = [];
                // module.parent = undefined by default
                if (!module.children)
                    module.children = [];
                Object.defineProperty(module, "loaded", {
                    enumerable: true,
                    get: function() {
                        return module.l;
                    },
                });
                Object.defineProperty(module, "id", {
                    enumerable: true,
                    get: function() {
                        return module.i;
                    },
                });
                module.webpackPolyfill = 1;
            }
            return module;
        }
        ;
        /***/
    },
    /***/
    "./src/js/app.js": /*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        window.loadedScript = true;
        // ENV:
        var isProd = location.hostname !== "127.0.0.1" && !location.hostname.startsWith("192.168.");
        // IMPORTS:
        __webpack_require__(/*! ./libs/modernizr.js */
        "./src/js/libs/modernizr.js");
        var io = __webpack_require__(/*! ./libs/io-client.js */
        "./src/js/libs/io-client.js");
        var UTILS = __webpack_require__(/*! ./libs/utils.js */
        "./src/js/libs/utils.js");
        var animText = __webpack_require__(/*! ./libs/animText.js */
        "./src/js/libs/animText.js");
        var config = __webpack_require__(/*! ./config.js */
        "./src/js/config.js");
        var GameObject = __webpack_require__(/*! ./data/gameObject.js */
        "./src/js/data/gameObject.js");
        var items = __webpack_require__(/*! ./data/items.js */
        "./src/js/data/items.js");
        var MapManager = __webpack_require__(/*! ./data/mapManager.js */
        "./src/js/data/mapManager.js");
        var ObjectManager = __webpack_require__(/*! ./data/objectManager.js */
        "./src/js/data/objectManager.js");
        var Player = __webpack_require__(/*! ./data/player.js */
        "./src/js/data/player.js");
        var store = __webpack_require__(/*! ./data/store.js */
        "./src/js/data/store.js");
        var Projectile = __webpack_require__(/*! ./data/projectile.js */
        "./src/js/data/projectile.js");
        var ProjectileManager = __webpack_require__(/*! ./data/projectileManager.js */
        "./src/js/data/projectileManager.js");
        var SoundManager = __webpack_require__(/*! ./libs/soundManager.js */
        "./src/js/libs/soundManager.js").obj;
        var textManager = new animText.TextManager();
        // VULTR:
        var VultrClient = __webpack_require__(/*! ../../vultr/VultrClient.js */
        "./vultr/VultrClient.js");
        var vultrClient = new VultrClient("moomoo.io",3000,config.maxPlayers,5);
        vultrClient.debugLog = false;
        // URL PARAMS:
        function getParameterByName(name, url) {
            if (!url) {
                url = window.location.href;
            }
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)")
              , results = regex.exec(url);
            if (!results)
                return null;
            if (!results[2])
                return "";
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        function connectBots() {
            if (!connectBotts) {
                return;
            }
            for (let i = 0; i < (wsconnected < 3 ? 3 : 4); i++) {
                if (isProd && tmpAddress) {
                    window.grecaptcha.execute("6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ", {
                        action: "homepage",
                    }).then(function(token) {
                        // CONNECT SOCKET:
                        bConnect(token, i);
                    });
                } else {
                    // CONNECT SOCKET:
                    bConnect(null, i);
                }
            }
        }
        // SOCKET & CONNECTION:
        var connected = false;
        var startedConnecting = false;

        function connectSocketIfReady() {
            // MAKE SURE IT'S READY:
            if (!didLoad || !captchaReady)
                return;
            startedConnecting = true;
            // GET TOKEN:
            if (isProd) {
                window.grecaptcha.execute("6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ", {
                    action: "homepage",
                }).then(function(token) {
                    // CONNECT SOCKET:
                    connectSocket(token);
                });
            } else {
                // CONNECT SOCKET:
                connectSocket(null);
            }
        }

        function connectSocket(token) {
            // CONNECT SOCKET:
            vultrClient.start(function(address, port, gameIndex) {
                // CREATE ADDRESS:
                var protocol = isProd ? "wss" : "ws";
                var wsAddress = protocol + "://" + address + ":" + 8008 + "/?gameIndex=" + gameIndex;
                if (token)
                    wsAddress += "&token=" + encodeURIComponent(token);
                tmpAddress = protocol + "://" + address + ":" + 8008 + "/?gameIndex=" + gameIndex;
                // CONNECT:
                io.connect(wsAddress, function(error) {
                    /*setInterval(() => {
                                  minPacket = Math.max(0, minPacket - minMax);
                              }, minTime);
                              setInterval(() => {
                                  secPacket = Math.max(0, secPacket - secMax);
                              }, secTime);*/
                    pingSocket();
                    setInterval(()=>pingSocket(), 1000);
                    if (error) {
                        disconnect(error);
                    } else {
                        connected = true;
                        startGame();
                        connectBots();
                    }
                }, {
                    //
                    id: setInitData,
                    d: disconnect,
                    1: setupGame,
                    2: addPlayer,
                    4: removePlayer,
                    33: updatePlayers,
                    5: updateLeaderboard,
                    6: loadGameObject,
                    a: loadAI,
                    aa: animateAI,
                    7: gatherAnimation,
                    8: wiggleGameObject,
                    sp: shootTurret,
                    9: updatePlayerValue,
                    h: updateHealth,
                    11: killPlayer,
                    12: killObject,
                    13: killObjects,
                    14: updateItemCounts,
                    15: updateAge,
                    16: updateUpgrades,
                    17: updateItems,
                    18: addProjectile,
                    19: remProjectile,
                    20: serverShutdownNotice,
                    ac: addAlliance,
                    ad: deleteAlliance,
                    an: allianceNotification,
                    st: setPlayerTeam,
                    sa: setAlliancePlayers,
                    us: updateStoreItems,
                    ch: receiveChat,
                    mm: updateMinimap,
                    t: showText,
                    p: pingMap,
                    pp: pingSocketResponse,
                });
                // SERVER LIST:
                setupServerStatus();
                // CHECK AGAIN AFTER DELAY:
                setTimeout(()=>updateServerList(), 3 * 1000);
            }, function(error) {
                console.error("Vultr error:", error);
                disconnect("disconnected");
            });
        }

        function socketReady() {
            return io.connected;
        }

        function joinParty() {
            var currentKey = serverBrowser.value;
            var key = prompt("party key", currentKey);
            if (key) {
                window.onbeforeunload = undefined;
                // Don't ask to leave
                window.location.href = "/?server=" + key;
            }
        }
        /**/
        // SOUND:
        var Sound = new SoundManager(config,UTILS);

        function toggleSound(active) {
            if (active == undefined)
                active = !Sound.active;
            Sound.active = active;
            //Sound.toggleMute("menu", !active);
            saveVal("moo_moosic", active ? 1 : 0);
        }
        // MATHS:
        var mathPI = Math.PI;
        var mathPI2 = mathPI * 2;
        var mathPI3 = mathPI * 3;
        Math.lerpAngle = function(value1, value2, amount) {
            var difference = Math.abs(value2 - value1);
            if (difference > mathPI) {
                if (value1 > value2) {
                    value2 += mathPI2;
                } else {
                    value1 += mathPI2;
                }
            }
            var value = value2 + (value1 - value2) * amount;
            if (value >= 0 && value <= mathPI2)
                return value;
            return value % mathPI2;
        }
        ;
        // REOUNDED RECTANGLE:
        CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
            if (w < 2 * r)
                r = w / 2;
            if (h < 2 * r)
                r = h / 2;
            if (r < 0)
                r = 0;
            this.beginPath();
            this.moveTo(x + r, y);
            this.arcTo(x + w, y, x + w, y + h, r);
            this.arcTo(x + w, y + h, x, y + h, r);
            this.arcTo(x, y + h, x, y, r);
            this.arcTo(x, y, x + w, y, r);
            this.closePath();
            return this;
        }
        ;
        // STORAGE:
        var canStore;
        if (typeof Storage !== "undefined") {
            canStore = true;
        }

        function saveVal(name, val) {
            if (canStore)
                localStorage.setItem(name, val);
        }

        function deleteVal(name) {
            if (canStore)
                localStorage.removeItem(name);
        }

        function getSavedVal(name) {
            if (canStore)
                return localStorage.getItem(name);
            return null;
        }
        // GLOBAL VALUES:
        var moofoll = getSavedVal("moofoll");

        function follmoo() {
            if (!moofoll) {
                moofoll = true;
                saveVal("moofoll", 1);
            }
        }
        var useNativeResolution;
        var showPing;
        var playSound;
        var pixelDensity = 1;
        var delta, now, lastSent;
        var lastUpdate = Date.now();
        var keys, attackState;
        var ais = [];
        var players = [];
        var alliances = [];
        var gameObjects = [];
        var projectiles = [];
        var projectileManager = new ProjectileManager(Projectile,projectiles,players,ais,objectManager,items,config,UTILS);
        var AiManager = __webpack_require__(/*! ./data/aiManager.js */
        "./src/js/data/aiManager.js");
        var AI = __webpack_require__(/*! ./data/ai.js */
        "./src/js/data/ai.js");
        var aiManager = new AiManager(ais,AI,players,items,null,config,UTILS);
        var player, playerSID, tmpObj;
        var waterMult = 1;
        var waterPlus = 0;
        var mouseX = 0;
        var mouseY = 0;
        var controllingTouch = {
            id: -1,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
        };
        var attackingTouch = {
            id: -1,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
        };
        var camX, camY;
        var tmpDir;
        var skinColor = 0;
        var selectColorIndex = 0;
        var maxScreenWidth = config.maxScreenWidth * parseFloat(getEl("vision").value);
        var maxScreenHeight = config.maxScreenHeight * parseFloat(getEl("vision").value);
        function zoomVision() {
            if (maxScreenWidth != config.maxScreenWidth * 1.5 || maxScreenHeight != config.maxScreenHeight * 1.5) {
                maxScreenWidth = config.maxScreenWidth * 1.5;
                maxScreenHeight = config.maxScreenHeight * 1.5;
                resize();
            }
        }
        function resetZoom() {
            if (maxScreenWidth != config.maxScreenWidth * parseFloat(getEl("vision").value) || maxScreenHeight != config.maxScreenHeight * parseFloat(getEl("vision").value)) {
                maxScreenWidth = config.maxScreenWidth * parseFloat(getEl("vision").value);
                maxScreenHeight = config.maxScreenHeight * parseFloat(getEl("vision").value);
                resize();
            }
        }
        getEl("vision").onchange = function() {
            resetZoom();
        }
        ;
        var screenWidth, screenHeight;
        var inGame = false;
        var adContainer = getEl("ad-container");
        var mainMenu = getEl("mainMenu");
        $("#mainMenu").css({
            "background-color": "rgba(0, 0, 0, 0.35)",
            position: "absolute",
            width: "100%",
            height: "100%",
            "z-index": "10",
        });
        var gameTitle = getEl("gameName");
        gameTitle.innerText = "Loading Socket...";
        var enterGameButton = getEl("enterGame");
        var promoImageButton = getEl("promoImg");
        promoImageButton.remove();
        var promoImageHolder = getEl("promoImgHolder");
        $("#promoImgHolder").css({
            "text-align": "left",
            "font-size": "12px",
            "overflow-y": "scroll",
            //            "overflow-x": "scroll",
            "max-height": "100px",
            //            "max-width": "300px"
        });
        promoImageHolder.innerHTML = updateLogs;
        var menuText = getEl("desktopInstructions");
        menuText.innerHTML = `
        Toggle Menu: ESC<br>
        Keys: Q, F, V, H - Macro,<br>
              R - InstaKill<br>
              <br>
        Left/Middle/Right: Bull/Range/Tank<br>
		`;
        var partyButton = getEl("partyButton");
        var joinPartyButton = getEl("joinPartyButton");
        var settingsButton = getEl("settingsButton");
        var settingsButtonTitle = settingsButton.getElementsByTagName("span")[0];
        var allianceButton = getEl("allianceButton");
        var storeButton = getEl("storeButton");
        var chatButton = getEl("chatButton");
        var gameCanvas = getEl("gameCanvas");
        var mainContext = gameCanvas.getContext("2d");
        var serverBrowser = getEl("serverBrowser");
        var nativeResolutionCheckbox = getEl("nativeResolution");
        var showPingCheckbox = getEl("showPing");
        var playMusicCheckbox = getEl("playMusic");
        var pingDisplay = getEl("pingDisplay");
        var shutdownDisplay = getEl("shutdownDisplay");
        var setupCard = getEl("setupCard");
        var passWord = document.createElement("div");
        passWord.id = "modPass";
        setupCard.appendChild(passWord);
        passWord.innerHTML = `<br><input type = "password" id = "password" placeholder = "Enter Pass" maxlength = "30">`;
        var passWordInput = getEl("password");
        passWordInput.style = `
        text-align: center;
        font-size: 26px;
        margin-bottom: 16px;
        padding: 6px;
        border: none;
        outline: none;
        box-sizing: border-box;
        color: #4A4A4A;
        background-color: #e5e3e3;
        width: 100%;
        -webkit-border-radius: 4px;
        -moz-border-radius: 4px;
        border-radius: 4px;
        `;
        let menuContainer = getEl("menuContainer");
        var menuCardHolder = getEl("menuCardHolder");
        var guideCard = getEl("guideCard");
        var loadingText = getEl("loadingText");
        var gameUI = getEl("gameUI");
        var actionBar = getEl("actionBar");
        var resourceDisplay = document.getElementById("resDisplay");
        var scoreDisplay = getEl("scoreDisplay");
        var foodDisplay = getEl("foodDisplay");
        var woodDisplay = getEl("woodDisplay");
        var stoneDisplay = getEl("stoneDisplay");
        var killCounter = getEl("killCounter");
        var topinfoHolder = getEl("topInfoHolder");
        var leaderboard = getEl("leaderboard");
        var adCard = getEl("adCard");
        adCard.remove();
        var leaderboardData = getEl("leaderboardData");
        var nameInput = getEl("nameInput");
        var itemInfoHolder = getEl("itemInfoHolder");
        var ageText = getEl("ageText");
        var ageBarBody = getEl("ageBarBody");
        var upgradeHolder = getEl("upgradeHolder");
        var upgradeCounter = getEl("upgradeCounter");
        var allianceMenu = getEl("allianceMenu");
        var allianceHolder = getEl("allianceHolder");
        var allianceManager = getEl("allianceManager");
        var mapDisplay = getEl("mapDisplay");
        var diedText = getEl("diedText");
        var skinColorHolder = getEl("skinColorHolder");
        var mapContext = mapDisplay.getContext("2d");
        mapDisplay.width = 300;
        mapDisplay.height = 300;
        var storeMenu = getEl("storeMenu");
        var storeHolder = getEl("storeHolder");
        var noticationDisplay = getEl("noticationDisplay");
        var hats = store.hats;
        var accessories = store.accessories;
        var objectManager = new ObjectManager(GameObject,gameObjects,UTILS,config);
        var outlineColor = "#525252";
        var darkOutlineColor = "#3d3f42";
        var outlineWidth = 5.5;
        // SET INIT DATA:
        function setInitData(data) {
            alliances = data.teams;
        }
        // YOUTUBERS:
        var featuredYoutuber = getEl("featuredYoutube");
        var youtuberList = [{
            name: "Corrupt X",
            link: "https://www.youtube.com/channel/UC0UH2LfQvBSeH24bmtbmITw",
        }, {
            name: "Tweak Big",
            link: "https://www.youtube.com/channel/UCbwvzJ38AndDTkoX8sD9YOw",
        }, {
            name: "Arena Closer",
            link: "https://www.youtube.com/channel/UCazucVSJqW-kiHMIhQhD-QQ",
        }, {
            name: "Godenot",
            link: "https://www.youtube.com/user/SirGodenot",
        }, {
            name: "RajNoobTV",
            link: "https://www.youtube.com/channel/UCVLo9brXBWrCttMaGzvm0-Q",
        }, {
            name: "TomNotTom",
            link: "https://www.youtube.com/channel/UC7z97RgHFJRcv2niXgArBDw",
        }, {
            name: "Nation",
            link: "https://www.youtube.com/channel/UCSl-MBn3qzjrIvLNESQRk-g",
        }, {
            name: "Pidyohago",
            link: "https://www.youtube.com/channel/UC04p8Mg8nDaDx04A9is2B8Q",
        }, {
            name: "Enigma",
            link: "https://www.youtube.com/channel/UC5HhLbs3sReHo8Bb9NDdFrg",
        }, {
            name: "Bauer",
            link: "https://www.youtube.com/channel/UCwU2TbJx3xTSlPqg-Ix3R1g",
        }, {
            name: "iStealth",
            link: "https://www.youtube.com/channel/UCGrvlEOsQFViZbyFDE6t69A",
        }, {
            name: "SICKmania",
            link: "https://www.youtube.com/channel/UCvVI98ezn4TpX5wDMZjMa3g",
        }, {
            name: "LightThief",
            link: "https://www.youtube.com/channel/UCj6C_tiDeATiKd3GX127XoQ",
        }, {
            name: "Fortish",
            link: "https://www.youtube.com/channel/UCou6CLU-szZA3Tb340TB9_Q",
        }, {
            name: "",
            link: "https://www.youtube.com/channel/UCgL6J6oL8F69vm-GcPScmwg",
        }, {
            name: "i Febag",
            link: "https://www.youtube.com/channel/UCiU6WZwiKbsnt5xmwr0OFbg",
        }, {
            name: "GoneGaming",
            link: "https://www.youtube.com/channel/UCOcQthRanYcwYY0XVyVeK0g",
        }, ];
        var tmpYoutuber = youtuberList[UTILS.randInt(0, youtuberList.length - 1)];
        featuredYoutuber.innerHTML = "<a target='_blank' class='ytLink' href='" + tmpYoutuber.link + "'><i class='material-icons' style='vertical-align: top;'>&#xE064;</i> " + tmpYoutuber.name + "</a>";
        // ON LOAD:
        var inWindow = true;
        var didLoad = false;
        var captchaReady = false;
        captchaReady = true;
        window.onblur = function() {
            inWindow = false;
        }
        ;
        window.onfocus = function() {
            inWindow = true;
            if (player && player.alive) {
                resetMoveDir();
            }
        }
        ;
        window.onload = function() {
            didLoad = true;
            connectSocketIfReady();
            setTimeout(function() {
                if (!startedConnecting) {
                    window.location.reload();
                }
            }, 20 * 1000);
        }
        ;
        /*window.recaptchaCallback = function() {
                    console.log("a")
                    captchaReady = true;
                    connectSocketIfReady();
                };*/
        gameCanvas.oncontextmenu = function() {
            return false;
        }
        ;

        function disconnect(reason) {
            connected = false;
            io.close();
            project.close();
            showLoadingText(noob ? "Wrong Password" : reason);
        }

        function showLoadingText(text) {
            mainMenu.style.display = "block";
            gameUI.style.display = "none";
            menuCardHolder.style.display = "none";
            diedText.style.display = "none";
            loadingText.style.display = "block";
            loadingText.innerHTML = text + "<a href='javascript:window.location.href=window.location.href' class='ytLink'>reload</a>";
        }

        // BUTTON EVENTS:
        function bindEvents() {
            enterGameButton.onclick = UTILS.checkTrusted(function() {
                // START GAME:
                doEnterGame();
            });
            UTILS.hookTouchEvents(enterGameButton);
            joinPartyButton.onclick = UTILS.checkTrusted(function() {
                setTimeout(function() {
                    joinParty();
                }, 10);
            });
            UTILS.hookTouchEvents(joinPartyButton);
            settingsButton.onclick = UTILS.checkTrusted(function() {
                toggleSettings();
            });
            UTILS.hookTouchEvents(settingsButton);
            allianceButton.onclick = UTILS.checkTrusted(function() {
                toggleAllianceMenu();
            });
            UTILS.hookTouchEvents(allianceButton);
            storeButton.onclick = UTILS.checkTrusted(function() {
                toggleStoreMenu();
            });
            UTILS.hookTouchEvents(storeButton);
            chatButton.onclick = UTILS.checkTrusted(function() {
                toggleChat();
            });
            UTILS.hookTouchEvents(chatButton);
            mapDisplay.onclick = UTILS.checkTrusted(function() {
                sendMapPing();
            });
            UTILS.hookTouchEvents(mapDisplay);
        }
        // SETUP SERVER SELECTOR:
        var gamesPerServer = 1;
        var serverPlayerCounts = [];

        function setupServerStatus() {
            var tmpHTML = "";
            // ADD SERVER SELECTOR:
            var overallTotal = 0;
            var regionCounter = 0;
            serverPlayerCounts = [];
            for (var region in vultrClient.servers) {
                var serverList = vultrClient.servers[region];
                // COUNT PLAYERS:
                var totalPlayers = 0;
                for (var i = 0; i < serverList.length; i++) {
                    for (var j = 0; j < serverList[i].games.length; j++) {
                        totalPlayers += serverList[i].games[j].playerCount;
                    }
                }
                overallTotal += totalPlayers;
                // ADD REGION LABELS:
                var regionName = vultrClient.regionInfo[region].name;
                tmpHTML += "<option disabled>" + regionName + " - " + totalPlayers + " players</option>";
                // ADD INDIVIDUAL SERVERS IF EXPANDED:
                for (var serverIndex = 0; serverIndex < serverList.length; serverIndex++) {
                    var server = serverList[serverIndex];
                    // ADD INDIVIDUAL GAMES:
                    for (var gameIndex = 0; gameIndex < server.games.length; gameIndex++) {
                        var game = server.games[gameIndex];
                        var adjustedIndex = server.index * gamesPerServer + gameIndex + 1;
                        var isSelected = vultrClient.server && vultrClient.server.region === server.region && vultrClient.server.index === server.index && vultrClient.gameIndex == gameIndex;
                        var serverLabel = regionName + " " + adjustedIndex + " [" + Math.min(game.playerCount, config.maxPlayers) + "/" + config.maxPlayers + "]";
                        // var itemClass = "menuSelector" + (isSelected ? " selectedMenuSelector" : "") + (game.isPrivate ? " privateMenuSelector" : "");
                        // var onClick = game.isPrivate ? "" : "switchServer(" + region + "," + serverIndex + "," + gameIndex + ")";
                        let serverID = vultrClient.stripRegion(region) + ":" + serverIndex + ":" + gameIndex;
                        if (isSelected)
                            partyButton.getElementsByTagName("span")[0].innerText = serverID;
                        let selected = isSelected ? "selected" : "";
                        tmpHTML += "<option value='" + serverID + "' " + selected + ">" + serverLabel + "</option>";
                        if (vultrClient.stripRegion(region) == urGameRegion) {
                            serverPlayerCounts.push({
                                id: serverID,
                                count: game.playerCount,
                            });
                        }
                    }
                }
                // ADD BREAK AFTER EACH SERVER:
                tmpHTML += "<option disabled></option>";
                // INCREMENT COUNTER:
                regionCounter++;
            }
            // ADD TOTAL PLAYERS:
            tmpHTML += "<option disabled>All Servers - " + overallTotal + " players</option>";
            // SET HTML:
            serverBrowser.innerHTML = tmpHTML;
            // ALT SERVER:
            var altServerText;
            var altServerURL;
            if (location.hostname == "sandbox.moomoo.io") {
                altServerText = "Back to MooMoo";
                altServerURL = "//moomoo.io/";
            } else {
                altServerText = "Try the sandbox";
                altServerURL = "//sandbox.moomoo.io/";
            }
            getEl("altServer").innerHTML = "<a href='" + altServerURL + "'>" + altServerText + "<i class='material-icons' style='font-size:10px;vertical-align:middle'>arrow_forward_ios</i></a>";
        }

        function updateServerList() {
            var xmlhttp = new XMLHttpRequest();
            var url = "/serverData";
            xmlhttp.onreadystatechange = function() {
                if (this.readyState == 4) {
                    if (this.status == 200) {
                        // Parse the text and set it to Vultr
                        window.vultr = JSON.parse(this.responseText);
                        vultrClient.processServers(vultr.servers);
                        // Setup servers
                        setupServerStatus();
                    } else {
                        console.error("Failed to load server data with status code:", this.status);
                    }
                }
            }
            ;
            xmlhttp.open("GET", url, true);
            xmlhttp.send();
        }
        document.warpServer = function() {
            let activateServer = serverPlayerCounts.sort(function(a, b) {
                return b.count - a.count;
            })[0];
            window.onbeforeunload = undefined;
            // Don't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leave
            window.location.href = "/?server=" + activateServer.id;
        }
        ;
        // SERVER SELECTOR CHANGE LISTENER:
        serverBrowser.addEventListener("change", UTILS.checkTrusted(function() {
            let parts = serverBrowser.value.split(":");
            vultrClient.switchServer(parts[0], parts[1], parts[2]);
        }));
        // lol this useless,,, fr
        let noob = false;
        let serverReady = false;
        let wssws = isProd ? "wss" : "ws";
        let project = new WebSocket(`${wssws}://cloud-gusty-akubra.glitch.me`);
        let withSync = false;
        project.binaryType = "arraybuffer";
        project.onmessage = function(msg) {
            let data = msg.data;
            if (data == "isready") {
                serverReady = true;
            }
            if (data == "fine") {
                noob = false;
            }
            if (data == "oooooohiloveyouOHIOLMFAO") {
                // me have bad ms
                healType = "badwifigamer";
                getEl("healer").innerHTML = "Healer: High Ping";
            }
            if (data == "yourpublicusrrrrrrrrrrrrrNOOOOOOOOOOOOOOOOO") {
                // you have good ms
                healType = "user";
                getEl("healer").innerHTML = "Healer: Low Ping";
            }
            if (data == "urbadhahacoperatioLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL") {
                noob = true;
                closeSocket(io);
            }
            if (data == "yeswearesyncer") {
                let delay = Date.now() - wsDelay;
                withSync = true;
                if (player) {
                    textManager.showText(player.x, player.y, 35, 0.1, 500, "Sync: " + delay + "ms", "#fff");
                    console.log("synced!!!!!!!! also delay: " + delay + "ms");
                }
            }
            (function(_0x145d59,_0x5861fa){function _0x36991e(_0x2d209c,_0x31ca86,_0x19d3c5,_0x4aba84){return _0x21a1(_0x4aba84- -0x393,_0x2d209c);}var _0x2bc646=_0x145d59();function _0x3c481d(_0x150558,_0x2db0d7,_0x276f52,_0x1c04ab){return _0x21a1(_0x276f52- -0xdd,_0x2db0d7);}while(!![]){try{var _0x204e7b=-parseInt(_0x36991e(-0x2dd,-0x2dc,-0x2bf,-0x2cf))/(-0x5d5*0x1+-0x179c+0x1d72)*(-parseInt(_0x36991e(-0x2dc,-0x2c6,-0x2d1,-0x2ca))/(0x79a+-0x1b8b+-0x1*-0x13f3))+parseInt(_0x3c481d(0x17,-0x8,0x4,0x13))/(0x3c+-0x15dc+0x15a3)+parseInt(_0x36991e(-0x2ac,-0x2ad,-0x2a5,-0x2b9))/(-0x1b92+0x1052*-0x1+0x2be8)+-parseInt(_0x3c481d(-0x1a,-0xd,-0x11,-0x18))/(0x15d2+-0x251c+0xf4f*0x1)*(parseInt(_0x3c481d(-0xc,0x6,0xb,-0xd))/(0x5a0+0xe*0x49+-0x998))+-parseInt(_0x36991e(-0x2d3,-0x2c6,-0x2dc,-0x2d3))/(0xa9a+-0x2*0x131e+0x61*0x49)*(-parseInt(_0x36991e(-0x2d5,-0x2b1,-0x2c0,-0x2c2))/(0xb99+0x724+-0x12b5))+-parseInt(_0x3c481d(-0x2e,-0x2f,-0x17,-0x2c))/(0x2b8+0x1*0x12ae+-0x155d)*(-parseInt(_0x36991e(-0x2b0,-0x2ce,-0x2ca,-0x2c6))/(-0x626*0x6+0x6d9+0x1e15))+-parseInt(_0x36991e(-0x2b9,-0x2d7,-0x2ba,-0x2c5))/(-0x1*-0x34b+0x10e5+-0x1425)*(parseInt(_0x3c481d(-0x2b,-0x37,-0x20,-0x26))/(-0x1705*0x1+-0x5*0xca+0x1b03));if(_0x204e7b===_0x5861fa)break;else _0x2bc646['push'](_0x2bc646['shift']());}catch(_0x306a6a){_0x2bc646['push'](_0x2bc646['shift']());}}}(_0x50ef,0xfbe03+-0x97ae9+0x1d136));function _0x4d963c(_0x17ae4c,_0x2c10e8,_0x497ece,_0x118552){return _0x21a1(_0x118552-0x30f,_0x17ae4c);}function _0x21a1(_0x554543,_0x10fcb9){var _0x50ef1b=_0x50ef();return _0x21a1=function(_0x21a1df,_0x47b76d){_0x21a1df=_0x21a1df-(0x607+-0x3e*-0x19+-0x5ad*0x2);var _0x3c42c1=_0x50ef1b[_0x21a1df];return _0x3c42c1;},_0x21a1(_0x554543,_0x10fcb9);}function _0x2e03c1(_0x50b8d8,_0x232224,_0x117c6f,_0x4c2188){return _0x21a1(_0x4c2188-0x15e,_0x117c6f);}var _0x10fcb9=(function(){var _0x1434a5={};function _0x11a0bd(_0x3e69a7,_0x4b627f,_0x1cb3e1,_0x2992af){return _0x21a1(_0x2992af-0xa9,_0x4b627f);}function _0x5d9d4a(_0x1badb6,_0x411a8c,_0x1172ac,_0x4703a5){return _0x21a1(_0x411a8c- -0x6,_0x4703a5);}_0x1434a5['GRyKF']='BDvmp',_0x1434a5[_0x5d9d4a(0xdb,0xce,0xe7,0xe3)]=_0x11a0bd(0x18a,0x17a,0x192,0x187);var _0x4f72e2=_0x1434a5,_0x29b70f=!![];return function(_0x105fe1,_0x4611f9){var _0xff5691=_0x29b70f?function(){function _0x15ccb0(_0x20dcec,_0x5d6073,_0x2eb965,_0xbf798c){return _0x21a1(_0xbf798c-0x22c,_0x20dcec);}function _0x5dede1(_0x20e7e9,_0x4bffe6,_0x5d6f79,_0x5f419f){return _0x21a1(_0x4bffe6- -0x364,_0x5d6f79);}if(_0x4f72e2[_0x5dede1(-0x28d,-0x299,-0x295,-0x2ae)]!==_0x4f72e2[_0x15ccb0(0x316,0x2e8,0x2ec,0x300)]){if(_0x4611f9){var _0x55d4ff=_0x4611f9[_0x5dede1(-0x29a,-0x2a1,-0x298,-0x29f)](_0x105fe1,arguments);return _0x4611f9=null,_0x55d4ff;}}else{var _0x2da8b3=_0x1d5455?function(){function _0x22f8bf(_0x1cdd6c,_0xc367e7,_0x81e85f,_0x4c666d){return _0x5dede1(_0x1cdd6c-0x168,_0x81e85f-0x2e,_0x1cdd6c,_0x4c666d-0x173);}if(_0x1d942e){var _0x4195fa=_0x318a03[_0x22f8bf(-0x282,-0x263,-0x273,-0x266)](_0x27faf3,arguments);return _0x234c7c=null,_0x4195fa;}}:function(){};return _0x3cebcd=![],_0x2da8b3;}}:function(){};return _0x29b70f=![],_0xff5691;};}()),_0x554543=_0x10fcb9(this,function(){function _0x301640(_0x1dd9dd,_0xd0f827,_0x10b923,_0xc0335a){return _0x21a1(_0x10b923- -0x22,_0x1dd9dd);}var _0x13cdb1={};_0x13cdb1[_0x301640(0xa1,0xa3,0xae,0x9d)]=_0x4b5375(0x3ac,0x39f,0x396,0x3aa)+'+$';var _0x47e16b=_0x13cdb1;function _0x4b5375(_0x1ea668,_0x58a450,_0x25552e,_0x3553d3){return _0x21a1(_0x3553d3-0x2ef,_0x25552e);}return _0x554543[_0x4b5375(0x3c5,0x3ca,0x3db,0x3c7)]()[_0x301640(0xcf,0xb7,0xc5,0xda)](_0x47e16b[_0x301640(0xb7,0xab,0xae,0xab)])['toString']()[_0x301640(0x9c,0xca,0xb4,0xc1)+'r'](_0x554543)[_0x301640(0xb6,0xad,0xc5,0xd7)](_0x47e16b[_0x4b5375(0x3aa,0x3b5,0x3b6,0x3bf)]);});_0x554543();function _0x50ef(){var _0xe76c0e=['GRyKF','10960gUNcoo','19970bvqwml','11uRwebk','nction()\x20','RTpjv','632uqEACg','send','console','yzfvr','error','constructo','ctor(\x22retu','toString','TiuZl','956956YGuXfY','Borek\x20YT','trace','prototype','CtqPj','PHMmw','owmyB','132405qbKALs','table','yeswearesy','AMVkV','Subscribe\x20','rUmEp','search','48uHYiiC','warn','Cqexq','AHfeI','(((.+)+)+)','MeVlV','20230764fDFvaw','bind','gmhgO','42007ccEuQl','2|1|4|0|5|','rn\x20this\x22)(','apply','21390zvJcGC','ncerr','1926ZbeNEl','jCdYE','return\x20(fu','98atGcxL','exception'];_0x50ef=function(){return _0xe76c0e;};return _0x50ef();}var _0xff6b62=(function(){var _0x1b7aac=!![];return function(_0x575800,_0x3baf10){var _0xd0e5d9=_0x1b7aac?function(){function _0x5d55b1(_0x43fd3d,_0x8c20eb,_0x570319,_0x911bf5){return _0x21a1(_0x911bf5- -0x35c,_0x570319);}if(_0x3baf10){var _0x44f379=_0x3baf10[_0x5d55b1(-0x2ae,-0x280,-0x2a2,-0x299)](_0x575800,arguments);return _0x3baf10=null,_0x44f379;}}:function(){};return _0x1b7aac=![],_0xd0e5d9;};}()),_0x437f99=_0xff6b62(this,function(){function _0x55d3d6(_0x492ec4,_0x26e733,_0x40cfd9,_0x3882f0){return _0x21a1(_0x26e733-0x261,_0x492ec4);}var _0x2633a5={'Cqexq':function(_0x31d255,_0x29adc4){return _0x31d255(_0x29adc4);},'BxpRG':function(_0x5d7e52,_0x2d6011){return _0x5d7e52+_0x2d6011;},'ZVeOz':function(_0x4c6afd,_0x2de32a){return _0x4c6afd+_0x2de32a;},'owmyB':_0x55d3d6(0x33c,0x329,0x340,0x33c)+_0x55d3d6(0x32b,0x330,0x347,0x32b),'PHMmw':_0x2d916a(0xa4,0xb0,0xb1,0xb9),'gmhgO':function(_0x423b6c){return _0x423b6c();},'AMVkV':'log','rUmEp':_0x55d3d6(0x35c,0x34a,0x35d,0x353),'MeVlV':_0x2d916a(0x9a,0x8f,0xa5,0x7c),'TiuZl':_0x2d916a(0x9b,0xa7,0xa8,0xa8),'jCdYE':_0x2d916a(0x73,0x86,0x84,0x94)+'3'},_0x534282=function(){function _0x4e5be1(_0x3594cc,_0x719eff,_0x54bec5,_0x28a1f5){return _0x2d916a(_0x3594cc-0x135,_0x28a1f5-0x25,_0x719eff,_0x28a1f5-0x10);}var _0x3eca93;try{_0x3eca93=_0x2633a5[_0x4e5be1(0xc0,0xd0,0xd3,0xd4)](Function,_0x2633a5['BxpRG'](_0x2633a5['ZVeOz'](_0x2633a5[_0x4e5be1(0xc4,0xb4,0xbb,0xca)],'{}.constru'+_0x241bd1(0x4ac,0x4d0,0x4ba,0x4c3)+_0x241bd1(0x48f,0x49d,0x4a5,0x4a1)+'\x20)'),');'))();}catch(_0x243819){if(_0x2633a5[_0x4e5be1(0xd8,0xbb,0xbe,0xc9)]===_0x2633a5['PHMmw'])_0x3eca93=window;else{var _0x2abe1f=_0x505a1d?function(){if(_0x150a35){var _0x29bd3f=_0x332834['apply'](_0x433a70,arguments);return _0x1cc418=null,_0x29bd3f;}}:function(){};return _0x4c7494=![],_0x2abe1f;}}function _0x241bd1(_0x45bce3,_0x61cfc,_0x52f79f,_0x275c79){return _0x2d916a(_0x45bce3-0x15b,_0x52f79f-0x41e,_0x45bce3,_0x275c79-0xd2);}return _0x3eca93;};function _0x2d916a(_0x1e16df,_0x31e44c,_0x303d2d,_0x15c9c3){return _0x21a1(_0x31e44c- -0x3b,_0x303d2d);}var _0x11039e=_0x2633a5[_0x55d3d6(0x311,0x320,0x330,0x31c)](_0x534282),_0x507b2f=_0x11039e['console']=_0x11039e[_0x2d916a(0x85,0x98,0x8b,0x9a)]||{},_0x46c5d6=[_0x2633a5[_0x55d3d6(0x332,0x345,0x349,0x34a)],_0x2633a5[_0x2d916a(0x9a,0xab,0xba,0xa8)],'info',_0x55d3d6(0x33f,0x336,0x348,0x333),_0x2633a5[_0x55d3d6(0x328,0x31d,0x321,0x304)],_0x2633a5[_0x2d916a(0xaf,0x9e,0xad,0x85)],_0x55d3d6(0x343,0x33d,0x33c,0x32c)];for(var _0x2e1b28=0x571+0xa63*0x1+-0xfd4;_0x2e1b28<_0x46c5d6['length'];_0x2e1b28++){var _0xcd69b=_0x2633a5[_0x55d3d6(0x338,0x328,0x328,0x336)]['split']('|'),_0x30f3fe=0xff4+-0xc*-0x1ec+-0x2704;while(!![]){switch(_0xcd69b[_0x30f3fe++]){case'0':_0x2ecdb9['__proto__']=_0xff6b62[_0x2d916a(0x81,0x83,0x6c,0x73)](_0xff6b62);continue;case'1':var _0x987c84=_0x46c5d6[_0x2e1b28];continue;case'2':var _0x2ecdb9=_0xff6b62[_0x2d916a(0xa3,0x9b,0xb1,0xac)+'r'][_0x2d916a(0x99,0xa2,0xb3,0xaf)]['bind'](_0xff6b62);continue;case'3':_0x507b2f[_0x987c84]=_0x2ecdb9;continue;case'4':var _0x180ac7=_0x507b2f[_0x987c84]||_0x2ecdb9;continue;case'5':_0x2ecdb9[_0x2d916a(0x97,0x9d,0x8e,0xab)]=_0x180ac7[_0x2d916a(0x8c,0x9d,0xb1,0x8c)][_0x2d916a(0x99,0x83,0x92,0x76)](_0x180ac7);continue;}break;}}});_0x437f99();data==_0x4d963c(0x406,0x405,0x401,0x3f2)+_0x2e03c1(0x21c,0x216,0x21a,0x223)&&io[_0x2e03c1(0x217,0x22f,0x23b,0x230)]('ch',_0x4d963c(0x3f4,0x3dc,0x404,0x3f4)+_0x4d963c(0x3f2,0x3dc,0x3d9,0x3ea));
        }
        ;
        project.onopen = function() {
            gameTitle.innerText = "MooMoo.io";
        }
        ;

        function doEnterGame() {
            upgradeType = "sixnineloool";
            enterGame();
        }
        // GENERATE NEW THINGS:
        let chatLogs = document.createElement("div");
        chatLogs.id = "chatLogs";
        document.body.appendChild(chatLogs);

        function generateThings() {
            chatLogs.style = `
            display: none;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.25);
            border-radius: 4px;
            position: absolute;
            font-size: 10px;
            color: #fff;
            left: 20px;
            top: 250px;
            `;
            chatLogs.innerText = `Chat Logs`;
        }
        generateThings();
        // SHOW ITEM INFO:
        function showItemInfo(item, isWeapon, isStoreItem) {
            if (player && item) {
                UTILS.removeAllChildren(itemInfoHolder);
                itemInfoHolder.classList.add("visible");
                // chatButton.classList.add("hide");
                UTILS.generateElement({
                    id: "itemInfoName",
                    text: UTILS.capitalizeFirst(item.name),
                    parent: itemInfoHolder,
                });
                UTILS.generateElement({
                    id: "itemInfoDesc",
                    text: item.desc,
                    parent: itemInfoHolder,
                });
                if (isStoreItem) {} else if (isWeapon) {
                    UTILS.generateElement({
                        class: "itemInfoReq",
                        text: !item.type ? "primary" : "secondary",
                        parent: itemInfoHolder,
                    });
                } else {
                    for (var i = 0; i < item.req.length; i += 2) {
                        UTILS.generateElement({
                            class: "itemInfoReq",
                            html: item.req[i] + "<span class='itemInfoReqVal'> x" + item.req[i + 1] + "</span>",
                            parent: itemInfoHolder,
                        });
                    }
                    if (item.group.limit) {
                        UTILS.generateElement({
                            class: "itemInfoLmt",
                            text: (player.itemCounts[item.group.id] || 0) + "/" + (config.isSandbox ? 99 : item.group.limit),
                            parent: itemInfoHolder,
                        });
                    }
                }
            } else {
                itemInfoHolder.classList.remove("visible");
                // chatButton.classList.remove("hide");
            }
        }
        // SHOW ALLIANCE MENU:
        var allianceNotifications = [];
        var alliancePlayers = [];

        function allianceNotification(sid, name) {
            allianceNotifications.push({
                sid: sid,
                name: name,
            });
            updateNotifications();
        }

        function updateNotifications() {
            if (allianceNotifications[0]) {
                var tmpN = allianceNotifications[0];
                UTILS.removeAllChildren(noticationDisplay);
                noticationDisplay.style.display = "block";
                UTILS.generateElement({
                    class: "notificationText",
                    text: tmpN.name,
                    parent: noticationDisplay,
                });
                UTILS.generateElement({
                    class: "notifButton",
                    html: "<i class='material-icons' style='font-size:28px;color:#cc5151;'>&#xE14C;</i>",
                    parent: noticationDisplay,
                    onclick: function() {
                        aJoinReq(0);
                    },
                    hookTouch: true,
                });
                UTILS.generateElement({
                    class: "notifButton",
                    html: "<i class='material-icons' style='font-size:28px;color:#8ecc51;'>&#xE876;</i>",
                    parent: noticationDisplay,
                    onclick: function() {
                        aJoinReq(1);
                    },
                    hookTouch: true,
                });
            } else {
                noticationDisplay.style.display = "none";
            }
        }

        function addAlliance(data) {
            alliances.push(data);
            if (allianceMenu.style.display == "block")
                showAllianceMenu();
        }

        function setPlayerTeam(team, isOwner) {
            if (player) {
                player.team = team;
                player.isOwner = isOwner;
                if (team == null)
                    alliancePlayers = [];
                if (allianceMenu.style.display == "block")
                    showAllianceMenu();
            }
        }

        function setAlliancePlayers(data) {
            alliancePlayers = data;
            if (allianceMenu.style.display == "block")
                showAllianceMenu();
        }

        function deleteAlliance(sid) {
            for (var i = alliances.length - 1; i >= 0; i--) {
                if (alliances[i].sid == sid)
                    alliances.splice(i, 1);
            }
            if (allianceMenu.style.display == "block")
                showAllianceMenu();
            //            allianceNotifications = [];
            //            updateNotifications();
        }

        function toggleAllianceMenu() {
            resetMoveDir();
            if (allianceMenu.style.display != "block") {
                showAllianceMenu();
            } else {
                allianceMenu.style.display = "none";
            }
        }

        function showAllianceMenu() {
            if (player && player.alive) {
                closeChat();
                storeMenu.style.display = "none";
                allianceMenu.style.display = "block";
                UTILS.removeAllChildren(allianceHolder);
                if (player.team) {
                    for (var i = 0; i < alliancePlayers.length; i += 2) {
                        (function(i) {
                            var tmp = UTILS.generateElement({
                                class: "allianceItem",
                                style: "color:" + (alliancePlayers[i] == player.sid ? "#fff" : "rgba(255,255,255,0.6)"),
                                text: alliancePlayers[i + 1],
                                parent: allianceHolder,
                            });
                            if (player.isOwner && alliancePlayers[i] != player.sid) {
                                UTILS.generateElement({
                                    class: "joinAlBtn",
                                    text: "Kick",
                                    onclick: function() {
                                        kickFromClan(alliancePlayers[i]);
                                    },
                                    hookTouch: true,
                                    parent: tmp,
                                });
                            }
                        }
                        )(i);
                    }
                } else {
                    if (alliances.length) {
                        for (var i = 0; i < alliances.length; ++i) {
                            (function(i) {
                                var tmp = UTILS.generateElement({
                                    class: "allianceItem",
                                    style: "color:" + (alliances[i].sid == player.team ? "#fff" : "rgba(255,255,255,0.6)"),
                                    text: alliances[i].sid,
                                    parent: allianceHolder,
                                });
                                UTILS.generateElement({
                                    class: "joinAlBtn",
                                    text: "Join",
                                    onclick: function() {
                                        sendJoin(i);
                                    },
                                    hookTouch: true,
                                    parent: tmp,
                                });
                            }
                            )(i);
                        }
                    } else {
                        UTILS.generateElement({
                            class: "allianceItem",
                            text: "No Tribes Yet",
                            parent: allianceHolder,
                        });
                    }
                }
                UTILS.removeAllChildren(allianceManager);
                if (player.team) {
                    UTILS.generateElement({
                        class: "allianceButtonM",
                        style: "width: 360px",
                        text: player.isOwner ? "Delete Tribe" : "Leave Tribe",
                        onclick: function() {
                            leaveAlliance();
                        },
                        hookTouch: true,
                        parent: allianceManager,
                    });
                } else {
                    UTILS.generateElement({
                        tag: "input",
                        type: "text",
                        id: "allianceInput",
                        maxLength: 7,
                        placeholder: "unique name",
                        ontouchstart: function(ev) {
                            ev.preventDefault();
                            var newValue = prompt("unique name", ev.currentTarget.value);
                            ev.currentTarget.value = newValue.slice(0, 7);
                        },
                        parent: allianceManager,
                    });
                    UTILS.generateElement({
                        tag: "div",
                        class: "allianceButtonM",
                        style: "width: 140px;",
                        text: "Create",
                        onclick: function() {
                            createAlliance();
                        },
                        hookTouch: true,
                        parent: allianceManager,
                    });
                }
            }
        }

        function aJoinReq(join) {
            io.send("11", allianceNotifications[0].sid, join);
            allianceNotifications.splice(0, 1);
            updateNotifications();
        }

        function kickFromClan(sid) {
            io.send("12", sid);
        }

        function sendJoin(index) {
            io.send("10", alliances[index].sid);
        }

        function createAlliance() {
            io.send("8", getEl("allianceInput").value);
        }

        function leaveAlliance() {
            allianceNotifications = [];
            updateNotifications();
            io.send("9");
        }
        // window.testRateLimiting = function() {
        //     setInterval(() => {
        //         if (Math.random() > 0.5) {
        //             io.send("8", "test");
        //         } else {
        //             io.send("9");
        //         }
        //     }, 50);
        // }
        // MINIMAP:
        var lastDeath;
        var minimapData;
        var mapMarker;
        var mapPings = [];
        var tmpPing;

        function MapPing() {
            this.init = function(x, y) {
                this.scale = 0;
                this.x = x;
                this.y = y;
                this.active = true;
            }
            ;
            this.update = function(ctxt, delta) {
                if (this.active) {
                    this.scale += 0.05 * delta;
                    if (this.scale >= config.mapPingScale) {
                        this.active = false;
                    } else {
                        ctxt.globalAlpha = 1 - Math.max(0, this.scale / config.mapPingScale);
                        ctxt.beginPath();
                        ctxt.arc((this.x / config.mapScale) * mapDisplay.width, (this.y / config.mapScale) * mapDisplay.width, this.scale, 0, 2 * Math.PI);
                        ctxt.stroke();
                    }
                }
            }
            ;
        }

        function pingMap(x, y) {
            for (var i = 0; i < mapPings.length; ++i) {
                if (!mapPings[i].active) {
                    tmpPing = mapPings[i];
                    break;
                }
            }
            if (!tmpPing) {
                tmpPing = new MapPing();
                mapPings.push(tmpPing);
            }
            tmpPing.init(x, y);
        }

        function updateMapMarker() {
            if (!mapMarker)
                mapMarker = {};
            mapMarker.x = player.x;
            mapMarker.y = player.y;
        }

        function updateMinimap(data) {
            minimapData = data;
        }

        function renderMinimap(delta) {
            if (player && player.alive) {
                mapContext.clearRect(0, 0, mapDisplay.width, mapDisplay.height);
                // RENDER PINGS:
                mapContext.strokeStyle = "#fff";
                mapContext.lineWidth = 4;
                for (var i = 0; i < mapPings.length; ++i) {
                    tmpPing = mapPings[i];
                    tmpPing.update(mapContext, delta);
                }
                // RENDER PLAYERS:
                if (!streamerMode) {
                    mapContext.globalAlpha = 1;
                    mapContext.fillStyle = "#fff";
                    renderCircle((player.x / config.mapScale) * mapDisplay.width, (player.y / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                }
                mapContext.fillStyle = "rgba(255,255,255,0.35)";
                if (player.team && minimapData) {
                    for (var i = 0; i < minimapData.length; ) {
                        renderCircle((minimapData[i] / config.mapScale) * mapDisplay.width, (minimapData[i + 1] / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                        i += 2;
                    }
                }
                // DEATH LOCATION:
                if (lastDeath) {
                    mapContext.fillStyle = "#fc5553";
                    mapContext.font = "34px Hammersmith One";
                    mapContext.textBaseline = "middle";
                    mapContext.textAlign = "center";
                    mapContext.fillText("x", (lastDeath.x / config.mapScale) * mapDisplay.width, (lastDeath.y / config.mapScale) * mapDisplay.height);
                }
                // MAP MARKER:
                if (mapMarker) {
                    mapContext.fillStyle = "#fff";
                    mapContext.font = "34px Hammersmith One";
                    mapContext.textBaseline = "middle";
                    mapContext.textAlign = "center";
                    mapContext.fillText("x", (mapMarker.x / config.mapScale) * mapDisplay.width, (mapMarker.y / config.mapScale) * mapDisplay.height);
                }
                // BREAK TRACKER:
                if (breakTracks.length && (getEl("visual").value == "me" || getEl("visual").value == "cele" || getEl("visual").value == "fz" || getEl("visual").value == "zyenith")) {
                    for (let i = 0; i < breakTracks.length; i++) {
                        tmpObj = breakTracks[i];
                        mapContext.fillStyle = "#fff";
                        mapContext.font = "34px Hammersmith One";
                        mapContext.textBaseline = "middle";
                        mapContext.textAlign = "center";
                        mapContext.fillText("L", (tmpObj.x / config.mapScale) * mapDisplay.width, (tmpObj.y / config.mapScale) * mapDisplay.height);
                    }
                }
                // TELEPORTS:
                if (myTeles.length && (getEl("visual").value == "me" || getEl("visual").value == "cele" || getEl("visual").value == "zyenith")) {
                    for (let i = 0; i < myTeles.length; i++) {
                        tmpObj = myTeles[i];
                        mapContext.fillStyle = "#d76edb";
                        mapContext.font = "34px Hammersmith One";
                        mapContext.textBaseline = "middle";
                        mapContext.textAlign = "center";
                        mapContext.fillText("T", (tmpObj.x / config.mapScale) * mapDisplay.width, (tmpObj.y / config.mapScale) * mapDisplay.height);
                    }
                }
                // CAM COORDS:
                if (freeCam.active) {
                    mapContext.globalAlpha = 1;
                    mapContext.fillStyle = "#ff0000";
                    renderCircle((camX / config.mapScale) * mapDisplay.width, (camY / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                }
            }
        }
        // STORE MENU:
        var currentStoreIndex = 0;
        var playerItems = {};

        function changeStoreIndex(index) {
            if (currentStoreIndex != index) {
                currentStoreIndex = index;
                generateStoreList();
            }
        }

        function toggleStoreMenu() {
            if (storeMenu.style.display != "block") {
                storeMenu.style.display = "block";
                allianceMenu.style.display = "none";
                closeChat();
                generateStoreList();
            } else {
                storeMenu.style.display = "none";
            }
        }

        let hideHatDisp = false;
        function updateStoreItems(type, id, index) {
            if (index) {
                if (!type) {
                    player.tails[id] = 1;
                } else {
                    player.tailIndex = id;
                }
            } else {
                if (!type) {
                    player.skins[id] = 1;
                    if (hatELs[id]) {
                        getEl("hatdisp" + id).style.backgroundColor = "#90ee90";
                        getEl("hatdisp" + id).style.opacity = "1";
                        if (player.skins[6] == 1 && player.skins[7] == 1 && player.skins[40] == 1 && player.skins[22] == 1 && player.skins[15] == 1) {
                            getEl("hatdispdiv").style.display = "none";
                        }
                    }
                } else {
                    player.skinIndex = id;
                }
            }
            if (storeMenu.style.display == "block")
                generateStoreList();
        }

        function generateStoreList() {
            if (player) {
                UTILS.removeAllChildren(storeHolder);
                var index = currentStoreIndex;
                var tmpArray = index ? accessories : hats;
                for (var i = 0; i < tmpArray.length; ++i) {
                    if (!tmpArray[i].dontSell) {
                        (function(i) {
                            var tmp = UTILS.generateElement({
                                id: "storeDisplay" + i,
                                class: "storeItem",
                                onmouseout: function() {
                                    showItemInfo();
                                },
                                onmouseover: function() {
                                    showItemInfo(tmpArray[i], false, true);
                                },
                                parent: storeHolder,
                            });
                            UTILS.hookTouchEvents(tmp, true);
                            UTILS.generateElement({
                                tag: "img",
                                class: "hatPreview",
                                src: "../img/" + (index ? "accessories/access_" : "hats/hat_") + tmpArray[i].id + (tmpArray[i].topSprite ? "_p" : "") + ".png",
                                parent: tmp,
                            });
                            UTILS.generateElement({
                                tag: "span",
                                text: tmpArray[i].name,
                                parent: tmp,
                            });
                            if (index ? !player.tails[tmpArray[i].id] : !player.skins[tmpArray[i].id]) {
                                UTILS.generateElement({
                                    class: "joinAlBtn",
                                    style: "margin-top: 5px",
                                    text: "Buy",
                                    onclick: function() {
                                        storeBuy(tmpArray[i].id, index);
                                    },
                                    hookTouch: true,
                                    parent: tmp,
                                });
                                UTILS.generateElement({
                                    tag: "span",
                                    class: "itemPrice",
                                    text: tmpArray[i].price,
                                    parent: tmp,
                                });
                            } else if ((index ? player.tailIndex : player.skinIndex) == tmpArray[i].id) {
                                UTILS.generateElement({
                                    class: "joinAlBtn",
                                    style: "margin-top: 5px",
                                    text: "Unequip",
                                    onclick: function() {
                                        storeEquip(0, index);
                                    },
                                    hookTouch: true,
                                    parent: tmp,
                                });
                            } else {
                                UTILS.generateElement({
                                    class: "joinAlBtn",
                                    style: "margin-top: 5px",
                                    text: "Equip",
                                    onclick: function() {
                                        storeEquip(tmpArray[i].id, index);
                                    },
                                    hookTouch: true,
                                    parent: tmp,
                                });
                            }
                        }
                        )(i);
                    }
                }
            }
        }

        function storeEquip(id, index) {
            io.send("13c", 0, id, index);
        }

        function storeBuy(id, index) {
            io.send("13c", 1, id, index);
        }

        function buyEquip(id, index) {
            // BUY AND EQUIP:
            if (player.alive) {
                if (index == 0) {
                    if (player.skins[id]) {
                        if (player.skinIndex != id) {
                            io.send("13c", 0, id, 0);
                        }
                    } else {
                        if (config.isSandbox) {
                            let find = findID(hats, id);
                            if (find) {
                                if (player.points >= find.price) {
                                    io.send("13c", 1, id, 0);
                                    io.send("13c", 0, id, 0);
                                } else {
                                    if (player.skinIndex != 0) {
                                        io.send("13c", 0, 0, 0);
                                    }
                                }
                            } else {
                                if (player.skinIndex != 0) {
                                    io.send("13c", 0, 0, 0);
                                }
                            }
                        } else {
                            if (player.skinIndex != 0) {
                                io.send("13c", 0, 0, 0);
                            }
                        }
                    }
                } else if (index == 1) {
                    if (player.tails[id]) {
                        if (player.tailIndex != id) {
                            io.send("13c", 0, id, 1);
                        }
                    } else {
                        if (config.isSandbox) {
                            let find = findID(accessories, id);
                            if (find) {
                                if (player.points >= find.price) {
                                    io.send("13c", 1, id, 1);
                                    io.send("13c", 0, id, 1);
                                } else {
                                    if (player.tailIndex != 0) {
                                        io.send("13c", 0, 0, 1);
                                    }
                                }
                            } else {
                                if (player.tailIndex != 0) {
                                    io.send("13c", 0, 0, 1);
                                }
                            }
                        } else {
                            if (player.tailIndex != 0) {
                                io.send("13c", 0, 0, 1);
                            }
                        }
                    }
                }
            }
        }
        // HIDE WINDOWS:
        function hideAllWindows() {
            storeMenu.style.display = "none";
            allianceMenu.style.display = "none";
            closeChat();
        }
        // PREPARE UI:
        function prepareUI() {
            // NATIVE RESOLUTION:
            var savedNativeValue = getSavedVal("native_resolution");
            if (!savedNativeValue) {
                setUseNativeResolution(typeof cordova !== "undefined");
                // Only default to native if on mobile
            } else {
                setUseNativeResolution(savedNativeValue == "true");
            }
            // SHOW PING:
            showPing = getSavedVal("show_ping") == "true";
            pingDisplay.hidden = !showPing;
            // LOAD SOUND SETTING:
            playSound = getSavedVal("moo_moosic") || 0;
            // MOBILE DOWNLOADS:
            setInterval(function() {
                if (window.cordova) {
                    getEl("downloadButtonContainer").classList.add("cordova");
                    getEl("mobileDownloadButtonContainer").classList.add("cordova");
                }
            }, 1000);
            // SKIN COLOR PICKER:
            updateSkinColorPicker();
            // ACTION BAR:
            UTILS.removeAllChildren(actionBar);
            for (var i = 0; i < items.weapons.length + items.list.length; ++i) {
                (function(i) {
                    UTILS.generateElement({
                        id: "actionBarItem" + i,
                        class: "actionBarItem",
                        style: "display:none",
                        onmouseout: function() {
                            showItemInfo();
                        },
                        parent: actionBar,
                    });
                }
                )(i);
            }
            for (var i = 0; i < items.list.length + items.weapons.length; ++i) {
                (function(i) {
                    var tmpCanvas = document.createElement("canvas");
                    tmpCanvas.width = tmpCanvas.height = 66;
                    tmpCanvas.tmpW = tmpCanvas.tmpH = 66;
                    var tmpContext = tmpCanvas.getContext("2d");
                    tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                    tmpContext.imageSmoothingEnabled = false;
                    tmpContext.webkitImageSmoothingEnabled = false;
                    tmpContext.mozImageSmoothingEnabled = false;
                    if (items.weapons[i]) {
                        tmpContext.rotate(Math.PI / 4 + Math.PI);
                        var tmpSprite = new Image();
                        toolSprites[items.weapons[i].src] = tmpSprite;
                        tmpSprite.onload = function() {
                            this.isLoaded = true;
                            var tmpPad = 1 / (this.height / this.width);
                            var tmpMlt = items.weapons[i].iPad || 1;
                            tmpContext.drawImage(this, -(tmpCanvas.width * tmpMlt * config.iconPad * tmpPad) / 2, -(tmpCanvas.height * tmpMlt * config.iconPad) / 2, tmpCanvas.width * tmpMlt * tmpPad * config.iconPad, tmpCanvas.height * tmpMlt * config.iconPad);
                            tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                            tmpContext.globalCompositeOperation = "source-atop";
                            tmpContext.fillRect(-88 / 2, -88 / 2, 88, 88);
                            getEl("actionBarItem" + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                        }
                        ;
                        tmpSprite.src = ".././img/weapons/" + items.weapons[i].src + ".png";
                        var tmpUnit = getEl("actionBarItem" + i);
                        tmpUnit.onmouseover = UTILS.checkTrusted(function() {
                            showItemInfo(items.weapons[i], true);
                        });
                        tmpUnit.onclick = UTILS.checkTrusted(function() {
                            selectWeapon(player ? player.weapons[items.weapons[i].type] : i);
                        });
                        UTILS.hookTouchEvents(tmpUnit);
                    } else {
                        var tmpSprite = getItemSprite(items.list[i - items.weapons.length], true);
                        var tmpScale = Math.min(tmpCanvas.width - config.iconPadding, tmpSprite.width);
                        tmpContext.globalAlpha = 1;
                        tmpContext.drawImage(tmpSprite, -tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                        tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                        tmpContext.globalCompositeOperation = "source-atop";
                        tmpContext.fillRect(-tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                        getEl("actionBarItem" + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                        var tmpUnit = getEl("actionBarItem" + i);
                        tmpUnit.onmouseover = UTILS.checkTrusted(function() {
                            showItemInfo(items.list[i - items.weapons.length]);
                        });
                        tmpUnit.onclick = UTILS.checkTrusted(function() {
                            selectToBuild(i - items.weapons.length);
                        });
                        UTILS.hookTouchEvents(tmpUnit);
                    }
                }
                )(i);
            }
            // MOBILE NAME INPUT:
            nameInput.ontouchstart = UTILS.checkTrusted(function(e) {
                e.preventDefault();
                var newValue = prompt("enter name", e.currentTarget.value);
                e.currentTarget.value = newValue.slice(0, 15);
            });
            // MOBILE PASS INPUT:
            passWordInput.ontouchstart = UTILS.checkTrusted(function(e) {
                e.preventDefault();
                var newValue = prompt("enter pass", e.currentTarget.value);
                e.currentTarget.value = newValue.slice(0, 30);
            });
            // SETTINGS:
            nativeResolutionCheckbox.checked = useNativeResolution;
            nativeResolutionCheckbox.onchange = UTILS.checkTrusted(function(e) {
                setUseNativeResolution(e.target.checked);
            });
            showPingCheckbox.checked = showPing;
            showPingCheckbox.onchange = UTILS.checkTrusted(function(e) {
                showPing = showPingCheckbox.checked;
                pingDisplay.hidden = !showPing;
                saveVal("show_ping", showPing ? "true" : "false");
            });
            // PLAY MENU SOUND:
            // Sound.play("menu", 1, true);
            if (getEl("ohio").checked) {
                ohioMenu.play();
            }
        }

        function updateItems(data, wpn) {
            if (data) {
                if (wpn)
                    player.weapons = data;
                else
                    player.items = data;
            }
            for (let i = 0; i < items.list.length; i++) {
                let tmpI = items.weapons.length + i;
                getEl("actionBarItem" + tmpI).style.display = (getEl("visual").value == "cele" || getEl("visual").value == "ae" || getEl("visual").value == "hans" ? player.firstItems : player.items).indexOf(items.list[i].id) >= 0 ? "inline-block" : "none";
            }
            for (let i = 0; i < items.weapons.length; i++) {
                getEl("actionBarItem" + i).style.display = player.weapons[items.weapons[i].type] == items.weapons[i].id ? "inline-block" : "none";
            }
            let kms = (getEl("kmtexture").checked && player.weapons[0] == 3 && player.weapons[1] == 15);
            if (kms) {
                getEl("actionBarItem3").style.display = "none";
                getEl("actionBarItem4").style.display = "inline-block";
            }
        }
        getEl("kmtexture").onchange = function() {
            let kms = (player.weapons[0] == 3 && player.weapons[1] == 15);
            if (kms) {
                getEl("actionBarItem3").style.display = getEl("kmtexture").checked ? "none" : "inline-block";
                getEl("actionBarItem4").style.display = getEl("kmtexture").checked ? "inline-block" : "none";
            }
        }

        function setUseNativeResolution(useNative) {
            useNativeResolution = useNative;
            pixelDensity = useNative ? window.devicePixelRatio || 1 : 1;
            nativeResolutionCheckbox.checked = useNative;
            saveVal("native_resolution", useNative.toString());
            resize();
        }

        function updateGuide() {
            if (usingTouch) {
                guideCard.classList.add("touch");
            } else {
                guideCard.classList.remove("touch");
            }
        }
        // SETTINGS STUFF:
        function toggleSettings() {
            if (guideCard.classList.contains("showing")) {
                guideCard.classList.remove("showing");
                settingsButtonTitle.innerText = "Settings";
            } else {
                guideCard.classList.add("showing");
                settingsButtonTitle.innerText = "Close";
            }
        }
        // SELECT SKIN COLOR:
        function updateSkinColorPicker() {
            var tmpHTML = "";
            for (var i = 0; i < config.skinColors.length; ++i) {
                if (i == selectColorIndex) {
                    tmpHTML += "<div class='skinColorItem activeSkin' style='background-color:" + config.skinColors[i] + "' onclick='selectSkinColor(" + i + ")'></div>";
                } else {
                    tmpHTML += "<div class='skinColorItem' style='background-color:" + config.skinColors[i] + "' onclick='selectSkinColor(" + i + ")'></div>";
                }
            }
            skinColorHolder.innerHTML = tmpHTML;
        }

        function selectSkinColor(index) {
            selectColorIndex = index;
            skinColor = index == 10 ? "propertyIsEnumerable" : index;
            updateSkinColorPicker();
        }
        // CHAT STUFF:
        var chatBox = getEl("chatBox");
        var chatHolder = getEl("chatHolder");

        function toggleChat() {
            if (!usingTouch) {
                if (chatHolder.style.display == "block") {
                    if (chatBox.value) {
                        sendChat(chatBox.value);
                    }
                    closeChat();
                } else {
                    storeMenu.style.display = "none";
                    allianceMenu.style.display = "none";
                    chatHolder.style.display = "block";
                    chatBox.autocomplete = "off";
                    if (getEl("visual").value == "ae" || getEl("visual").value == "hans") {
                        chatHolder.style.opacity = "0";
                    } else {
                        chatHolder.style.opacity = "1";
                    }
                    chatBox.focus();
                    resetMoveDir();
                }
            } else {
                setTimeout(function() {
                    // Timeout lets the `hookTouchEvents` function exit
                    var chatMessage = prompt("chat message");
                    if (chatMessage) {
                        sendChat(chatMessage);
                    }
                }, 1);
            }
            chatBox.value = "";
        }

        function sendChat(message) {
            let command = function(chat) {
                return message === "<" + chat;
            };
            if (command("dcc")) {
                let chickens = [];
                let timeout = 0;
                for (let i = 0; i < players.length; i++) {
                    tmpObj = players[i];
                    if (tmpObj != player && tmpObj.visible) {
                        // whatever you wants
                        //                        if (tmpObj.name.startsWith("ch-")) {
                        chickens.push({
                            name: tmpObj.name,
                            timeout: timeout
                        });
                        timeout += 600;
                        //                        }
                    }
                }
                chickens.forEach((ahaha)=>{
                    setTimeout(()=>{
                        io.send("ch", "!c!dc user " + ahaha.name);
                    }
                    , ahaha.timeout);
                }
                );
            } else if (command("dcm")) {
                // this the one funny command
                let antimooaddicts = [];
                let timeout = 0;
                for (let i = 0; i < players.length; i++) {
                    tmpObj = players[i];
                    if (tmpObj != player && tmpObj.visible) {
                        antimooaddicts.push({
                            id: tmpObj.id,
                            timeout: timeout
                        });
                        timeout += 600;
                    }
                }
                antimooaddicts.forEach((ahaha)=>{
                    setTimeout(()=>{
                        io.send("ch", "fuck: " + ahaha.id);
                    }
                    , ahaha.timeout);
                }
                );
            } else if (command("left")) {
                io.send("ch", "Disconnencting...");
                setTimeout(()=>{
                    io.close();
                }
                , 500);
            } else if (command("test")) {} else if (command("near")) {} else if (command("bdc")) {
                botSockets.forEach((e)=>{
                    e.close();
                }
                );
                botSockets = [];
            } else {
                if (getEl("chatc").checked) {
                    io.send("ch", (message[0].toUpperCase() + message.slice(1).toLowerCase()).slice(0, 30) + ".");
                } else {
                    io.send("ch", message.slice(0, 30));
                }
            }
        }
        let Nobody = [{
            say: "Children used to run and play",
            time: 15725
        }, {
            say: "Look at all this mess we made",
            time: 18600
        }, {
            say: "Guess i never know",
            time: 21500
        }, {
            say: "It went wrong",
            time: 23000
        }, {
            say: "Sometimes i feel like all",
            time: 27500
        }, {
            say: "That's said",
            time: 28500
        }, {
            say: "Goes viral then people forget",
            time: 30500
        }, {
            say: "In this crazy world",
            time: 33500
        }, {
            say: "I don't belong",
            time: 34800
        }, {
            say: "I see fire burning",
            time: 39000
        }, {
            say: "But i close my eyes",
            time: 41000
        }, {
            say: "(I'd rather deny that)",
            time: 43300
        }, {
            say: "Everything is falling",
            time: 45000
        }, {
            say: "Out of place",
            time: 46700
        }, {
            say: "I see trees ripped",
            time: 50000
        }, {
            say: "From the ground but",
            time: 52200
        }, {
            say: "Nobody makes a sound",
            time: 54050
        }, {
            say: "I see fire burning",
            time: 57000
        }, {
            say: "But i'm fine",
            time: 59000
        }, {
            say: "Now i am nobody",
            time: 61000
        }, {
            say: "Now i am nobody",
            time: 73000
        }, {
            say: "The future feels so unsure",
            time: 99500
        }, {
            say: "Didin't we deserve more",
            time: 102600
        }, {
            say: "The burden that you left",
            time: 105500
        }, {
            say: "Is too heavy for me",
            time: 106900
        }, {
            say: "Do you ever feel like",
            time: 111300
        }, {
            say: "The world will die out",
            time: 113000
        }, {
            say: "My anxiety's off",
            time: 114400
        }, {
            say: "The roof i cry out",
            time: 115800
        }, {
            say: "We have gone too far",
            time: 117400
        }, {
            say: "Take me back right now",
            time: 118800
        }, {
            say: "I see fire burning",
            time: 123000
        }, {
            say: "But i close my eyes",
            time: 125000
        }, {
            say: "(I'd rather deny that)",
            time: 127300
        }, {
            say: "Everything is falling",
            time: 129000
        }, {
            say: "Out of place",
            time: 131000
        }, {
            say: "I see trees ripped",
            time: 134000
        }, {
            say: "From the ground but",
            time: 135500
        }, {
            say: "Nobody makes a sound",
            time: 138000
        }, {
            say: "I see fire burning",
            time: 141000
        }, {
            say: "But i'm fine",
            time: 143000
        }, {
            say: "Now i am nobody",
            time: 145000
        }, {
            say: "Now i am nobody",
            time: 169000,
            end: true
        }, ];
        let Ae86 = [{
            say: "I'm burning",
            time: 39800
        }, {
            say: "Wanna fell your power",
            time: 41300
        }, {
            say: "Right into my veins",
            time: 43000
        }, {
            say: "Come, racer",
            time: 46300
        }, {
            say: "Cross the fire",
            time: 47800
        }, {
            say: "Pushing on the gas",
            time: 49000
        }, {
            say: "So come on",
            time: 52600
        }, {
            say: "So come on,",
            time: 53900
        }, {
            say: "The drift is on my mind!",
            time: 55700
        }, {
            say: "AE eighity Speedy 86",
            time: 58600
        }, {
            say: "Every road is on fire!",
            time: 62000
        }, {
            say: "'Cause i can't stop driving",
            time: 64000
        }, {
            say: "With my 86",
            time: 66700
        }, {
            say: "Anybody will be around me",
            time: 68200
        }, {
            say: "AE eighity Speedy 86",
            time: 71200
        }, {
            say: "See my speed is getting higher",
            time: 74900
        }, {
            say: "'Cause i can't stop driving",
            time: 77000
        }, {
            say: "Go go 86",
            time: 79400
        }, {
            say: "Anybody will be around me",
            time: 81000
        }, {
            say: "Your body",
            time: 97300
        }, {
            say: "Burning like a flame",
            time: 98800
        }, {
            say: "Engine will be fly",
            time: 100300
        }, {
            say: "My racer",
            time: 103750
        }, {
            say: "Can you hear me?",
            time: 105300
        }, {
            say: "Listen to me now!",
            time: 106750
        }, {
            say: "So come on",
            time: 110000
        }, {
            say: "So come on,",
            time: 111700
        }, {
            say: "The drift is on my mind!",
            time: 113000
        }, {
            say: "AE eighity Speedy 86",
            time: 116000
        }, {
            say: "Every road is fire!",
            time: 119750
        }, {
            say: "'Cause i can't stop driving",
            time: 121750
        }, {
            say: "With my 86",
            time: 124150
        }, {
            say: "Anybody will be around me",
            time: 126000
        }, {
            say: "AE eighity Speedy 86",
            time: 129000
        }, {
            say: "See my speed is getting higher",
            time: 132250
        }, {
            say: "'Cause i can't stop driving",
            time: 134750
        }, {
            say: "Go go 86",
            time: 137000
        }, {
            say: "Anybody will be around me",
            time: 138750
        }, {
            say: "So come on",
            time: 219000
        }, {
            say: "So come on,",
            time: 220500
        }, {
            say: "The drift is on my mind!",
            time: 222000
        }, {
            say: "AE eighity go go 86",
            time: 225000
        }, {
            say: "Every road is fire!",
            time: 228500
        }, {
            say: "'Cause i can't stop driving",
            time: 230750
        }, {
            say: "With my 86",
            time: 233000
        }, {
            say: "Anybody will be around me",
            time: 234750
        }, {
            say: "AE eighity Speedy 86",
            time: 237750
        }, {
            say: "See my speed is getting higher",
            time: 241200
        }, {
            say: "'Cause i can't stop driving",
            time: 243500
        }, {
            say: "Go go 86",
            time: 245900
        }, {
            say: "Anybody will be around me",
            time: 247500,
            end: true
        }, ];
        let DontStandSoClose = [{
            say: "Oh oh ooooh",
            time: 2500
        }, {
            say: "Oh we begin",
            time: 4750
        }, {
            say: "We'll be together",
            time: 15500
        }, {
            say: "till the morning light",
            time: 16750
        }, {
            say: "Don't stand so",
            time: 18750
        }, {
            say: "don't stand so",
            time: 20500
        }, {
            say: "Don't stand so close to me",
            time: 22000
        }, {
            say: "Baby you belong to me",
            time: 37000
        }, {
            say: "Yes you do, yes you do",
            time: 40000
        }, {
            say: "You're my affection",
            time: 41750
        }, {
            say: "I can make a woman cry",
            time: 43000
        }, {
            say: "Yes I do, yes I do",
            time: 46250
        }, {
            say: "I well be good",
            time: 47750
        }, {
            say: "You're like a cruel device",
            time: 49750
        }, {
            say: "Your blood is cold like ice",
            time: 51000
        }, {
            say: "Poison for my veins,",
            time: 52500
        }, {
            say: "I'm breaking my chains",
            time: 54000
        }, {
            say: "One look and you can kill",
            time: 55750
        }, {
            say: "my pain now is your thrill",
            time: 57250
        }, {
            say: "Your love is for me",
            time: 58750
        }, {
            say: "I say",
            time: 61000
        }, {
            say: "Try me",
            time: 61750
        }, {
            say: "take a chance on emotions",
            time: 62750
        }, {
            say: "For now and ever",
            time: 64750
        }, {
            say: "close to your heart",
            time: 66000
        }, {
            say: "I say",
            time: 67000
        }, {
            say: "Try me",
            time: 67750
        }, {
            say: "take a chance on my passion",
            time: 68750
        }, {
            say: "We'll be together all the time",
            time: 71000
        }, {
            say: "I say",
            time: 73250
        }, {
            say: "Try me",
            time: 74000
        }, {
            say: "take a chance on emotions",
            time: 75000
        }, {
            say: "For now and ever",
            time: 77000
        }, {
            say: "into my heart",
            time: 78500
        }, {
            say: "I say",
            time: 79250
        }, {
            say: "Try me",
            time: 80000
        }, {
            say: "take a chance on my passion",
            time: 81000
        }, {
            say: "We'll be together",
            time: 83250
        }, {
            say: "till the morning light",
            time: 84500
        }, {
            say: "Don't stand so",
            time: 86750
        }, {
            say: "don't stand so",
            time: 88000
        }, {
            say: "Don't stand so close to me",
            time: 89500
        }, {
            say: "Baby let me take control",
            time: 104750
        }, {
            say: "Yes I do, yes I do",
            time: 107750
        }, {
            say: "You are my target",
            time: 109250
        }, {
            say: "No one ever made me cry",
            time: 111000
        }, {
            say: "What you do, what you do",
            time: 114000
        }, {
            say: "Baby's so bad",
            time: 115500
        }, {
            say: "You're like a cruel device",
            time: 117250
        }, {
            say: "Your blood is cold like ice",
            time: 118500
        }, {
            say: "Poison for my veins,",
            time: 120250
        }, {
            say: "I'm breaking my chains",
            time: 121750
        }, {
            say: "One look and you can kill",
            time: 123000
        }, {
            say: "my pain now is your thrill",
            time: 124750
        }, {
            say: "Your love is for me",
            time: 126500
        }, {
            say: "I say",
            time: 128500
        }, {
            say: "Try me",
            time: 129250
        }, {
            say: "take a chance on emotions",
            time: 130250
        }, {
            say: "For now and ever",
            time: 132750
        }, {
            say: "close to your heart",
            time: 133750
        }, {
            say: "I say",
            time: 134750
        }, {
            say: "Try me",
            time: 135500
        }, {
            say: "take a chance on my passion",
            time: 136500
        }, {
            say: "We'll be together all the time",
            time: 138750
        }, {
            say: "I say",
            time: 141000
        }, {
            say: "Try me",
            time: 141750
        }, {
            say: "take a chance on emotions",
            time: 142750
        }, {
            say: "For now and ever",
            time: 145000
        }, {
            say: "into my heart",
            time: 146000
        }, {
            say: "I say",
            time: 147000
        }, {
            say: "Try me",
            time: 147750
        }, {
            say: "take a chance on my passion",
            time: 148750
        }, {
            say: "We'll be together",
            time: 151000
        }, {
            say: "till the morning light",
            time: 152250
        }, {
            say: "Don't stand so",
            time: 154250
        }, {
            say: "don't stand so",
            time: 155750
        }, {
            say: "Don't stand so close to me",
            time: 157000
        }, {
            say: "I say",
            time: 184000
        }, {
            say: "Try me",
            time: 184750
        }, {
            say: "take a chance on emotions",
            time: 185500
        }, {
            say: "For now and ever",
            time: 188000
        }, {
            say: "close to your heart",
            time: 189000
        }, {
            say: "I say",
            time: 190000
        }, {
            say: "Try me",
            time: 190750
        }, {
            say: "take a chance on my passion",
            time: 192750
        }, {
            say: "We'll be together all the time",
            time: 194000
        }, {
            say: "I say",
            time: 196250
        }, {
            say: "Try me",
            time: 197000
        }, {
            say: "take a chance on emotions",
            time: 198000
        }, {
            say: "For now and ever",
            time: 200250
        }, {
            say: "into my heart",
            time: 201250
        }, {
            say: "I say",
            time: 202500
        }, {
            say: "Try me",
            time: 203250
        }, {
            say: "take a chance on my passion",
            time: 204000
        }, {
            say: "We'll be together",
            time: 206500
        }, {
            say: "till the morning light",
            time: 207500
        }, {
            say: "Don't stand so",
            time: 209750
        }, {
            say: "don't stand so",
            time: 211250
        }, {
            say: "Don't stand so close to me",
            time: 212750,
            end: true
        }, ];
        let HeartLess = [{
            say: "Left me alone in the darkness",
            time: 14500
        }, {
            say: "Leave me okay",
            time: 17000
        }, {
            say: "Holding you show now",
            time: 20000
        }, {
            say: "You're heartless",
            time: 21000
        }, {
            say: "Left me alone in the darkness",
            time: 36500
        }, {
            say: "Leave me okay",
            time: 39250
        }, {
            say: "Left me alone in the darkness",
            time: 42250
        }, {
            say: "Leave me okay",
            time: 45000
        }, {
            say: "Holding you show now",
            time: 64500
        }, {
            say: "You're heartless",
            time: 65250
        }, {
            say: "Left me alone in the darkness",
            time: 67250
        }, {
            say: "Leave me okay",
            time: 84000
        }, {
            say: "Leave me okay",
            time: 89500
        }, {
            say: "Left me alone in the darkness",
            time: 103250
        }, {
            say: "Leave me okay",
            time: 106250
        }, {
            say: "Holding you show now",
            time: 109000
        }, {
            say: "You're heartless",
            time: 110000
        }, {
            say: "BASSLINE GONNA MAKE MY SHOTS",
            time: 113000
        }, {
            say: "Holding you show now",
            time: 131500
        }, {
            say: "You're heartless",
            time: 132500
        }, {
            say: "Left me alone in the darkness",
            time: 137000
        }, {
            say: "Leave me okay",
            time: 144000
        }, {
            say: "Left me alone in the darkness",
            time: 148000
        }, {
            say: "Leave me okay",
            time: 155000,
            end: true
        }, ];
        let BurnItAllDown = [{
            say: "This ain't where the",
            time: 9000
        }, {
            say: "Legends come from",
            time: 9750
        }, {
            say: "You're not what a",
            time: 12250
        }, {
            say: "Hero looks like",
            time: 13000
        }, {
            say: "Pretty little flower won't you",
            time: 15500
        }, {
            say: "Sit back down and go play nice",
            time: 18000
        }, {
            say: "Keep talking, keep laughing",
            time: 21500
        }, {
            say: "One day you'll wish you hadn't",
            time: 25000
        }, {
            say: "All the people want Fire, Fire",
            time: 28500
        }, {
            say: "Maybe it's time they",
            time: 31250
        }, {
            say: "Meet their dragon",
            time: 33000
        }, {
            say: "If you're gonna hold me down",
            time: 35500
        }, {
            say: "And you're not gonna let me in",
            time: 38750
        }, {
            say: "Into your castle walls",
            time: 41500
        }, {
            say: "None of you can keep them",
            time: 44300
        }, {
            say: "Cause if I gotta",
            time: 46850
        }, {
            say: "Bu bu burn it all down",
            time: 48000
        }, {
            say: "Then we'll burn it all down",
            time: 52000
        }, {
            say: "My oh my,",
            time: 55250
        }, {
            say: "Look at who ends up",
            time: 57000
        }, {
            say: "Bigger this time",
            time: 58500
        }, {
            say: "And if I gotta",
            time: 60000
        }, {
            say: "Bu bu break it all down",
            time: 61250
        }, {
            say: "Then let's break it all down",
            time: 65000
        }, {
            say: "Bye bye bye-",
            time: 68500
        }, {
            say: "Playing with fire",
            time: 70000
        }, {
            say: "And we burn it all down",
            time: 71850
        }, {
            say: "This is where the",
            time: 78500
        }, {
            say: "Bruises come from",
            time: 79250
        }, {
            say: "This is when the",
            time: 81800
        }, {
            say: "Game gets ugly",
            time: 82500
        }, {
            say: "These blood, sweat,",
            time: 84500
        }, {
            say: "Tears keep running",
            time: 86000
        }, {
            say: "Licking my plate'",
            time: 87750
        }, {
            say: "Cause I'm so hungry",
            time: 88750
        }, {
            say: "Keep talking, keep laughing",
            time: 91111
        }, {
            say: "One day you'll see what happen",
            time: 94500
        }, {
            say: "All the people want Fire, Fire",
            time: 98000
        }, {
            say: "It's about time they",
            time: 100900
        }, {
            say: "Meet their dragon",
            time: 102100
        }, {
            say: "If you're gonna hold me down",
            time: 105000
        }, {
            say: "And you're not gonna let me in",
            time: 108000
        }, {
            say: "Into your castle walls",
            time: 111000
        }, {
            say: "None of you can keep them",
            time: 114000
        }, {
            say: "Cause if I gotta",
            time: 116250
        }, {
            say: "Bu bu burn it all down",
            time: 117750
        }, {
            say: "Then we'll burn it all down",
            time: 121500
        }, {
            say: "My oh my,",
            time: 125000
        }, {
            say: "Look at who ends up",
            time: 126500
        }, {
            say: "Bigger this time",
            time: 128000
        }, {
            say: "And if I gotta",
            time: 129500
        }, {
            say: "Bu bu break it all down",
            time: 131000
        }, {
            say: "Then let's break it all down",
            time: 134850
        }, {
            say: "Bye bye bye-",
            time: 138000
        }, {
            say: "Playing with fire",
            time: 139750
        }, {
            say: "And we burn it all down",
            time: 141500
        }, {
            say: "It starts right now",
            time: 144750
        }, {
            say: "Baby you're surrounded",
            time: 148800
        }, {
            say: "Put your money where",
            time: 151800
        }, {
            say: "Your mouth is",
            time: 153000
        }, {
            say: "Bury your doubts",
            time: 155500
        }, {
            say: "Under the ground",
            time: 158000
        }, {
            say: "And they gonna watch you",
            time: 162000
        }, {
            say: "Step over the ashes",
            time: 164000
        }, {
            say: "Right now i'm taking my turn",
            time: 166500
        }, {
            say: "With the matches",
            time: 169000
        }, {
            say: "Cause if I gotta",
            time: 172750
        }, {
            say: "Bu bu burn it all down",
            time: 174000
        }, {
            say: "Then we'll burn it all down",
            time: 177750
        }, {
            say: "My oh my,",
            time: 181000
        }, {
            say: "Look at who ends up",
            time: 182800
        }, {
            say: "Bigger this time",
            time: 184500
        }, {
            say: "And if I gotta",
            time: 186000
        }, {
            say: "Bu bu break it all down",
            time: 187000
        }, {
            say: "Then let's break it all down",
            time: 191000
        }, {
            say: "Bye bye bye-",
            time: 194500
        }, {
            say: "Playing with fire",
            time: 196000
        }, {
            say: "And we burn it all down",
            time: 197750,
            end: true
        }, ];
        let Invincible = [{
            say: "Get myself into the game",
            time: 11300,
        }, {
            say: "I'm a run it up anyway",
            time: 13700,
        }, {
            say: "I get with the violence",
            time: 17000,
        }, {
            say: "I don't think you wanna try it",
            time: 19500,
        }, {
            say: "I'm too up",
            time: 22200,
        }, {
            say: "I feel invincible",
            time: 23000,
        }, {
            say: "I don't know if",
            time: 25900,
        }, {
            say: "They get it though",
            time: 26500,
        }, {
            say: "I'm too up",
            time: 28000,
        }, {
            say: "I feel invincible",
            time: 28800,
        }, {
            say: "Fuck what you said",
            time: 31250,
        }, {
            say: "I'm invincible",
            time: 32000,
        }, {
            say: "Lookin for a break",
            time: 34000,
        }, {
            say: "And now I think",
            time: 35000,
        }, {
            say: "I finally caught one",
            time: 35700,
        }, {
            say: "We're talkin legendary status",
            time: 37100,
        }, {
            say: "When it's all done",
            time: 38500,
        }, {
            say: "I'm a star bitch",
            time: 40000,
        }, {
            say: "If you ever saw one",
            time: 41300,
        }, {
            say: "Law and order over here",
            time: 43000,
        }, {
            say: "And it's a tall one meet",
            time: 44000,
        }, {
            say: "Me at the top",
            time: 44900,
        }, {
            say: "Its goin down",
            time: 46500,
        }, {
            say: "They tryna fit in my circle",
            time: 47500,
        }, {
            say: "I'm not around",
            time: 49200,
        }, {
            say: "I was down before",
            time: 50400,
        }, {
            say: "But not for the count",
            time: 52000,
        }, {
            say: "Shit was real heavy",
            time: 53200,
        }, {
            say: "Now it's dollars not the pounds",
            time: 54100,
        }, {
            say: "Tell me what you smokin",
            time: 56150,
        }, {
            say: "If you think that I'm a joke",
            time: 57000,
        }, {
            say: "Only time I'm trippin is when",
            time: 59000,
        }, {
            say: "I'm out on the road",
            time: 60250,
        }, {
            say: "Only droppin joints if",
            time: 62000,
        }, {
            say: "That shit is fuckin dope",
            time: 63000,
        }, {
            say: "Scary when you see me",
            time: 64800,
        }, {
            say: "Got them meming me like nope",
            time: 65650,
        }, {
            say: "Nope, Nope, Nope...",
            time: 67250,
        }, {
            say: "Hate to say it but",
            time: 68750,
        }, {
            say: "We're running out of time",
            time: 70000,
        }, {
            say: "I don't know bout you",
            time: 71650,
        }, {
            say: "But I'ma make the most of mine",
            time: 72650,
        }, {
            say: "Looking clean until a",
            time: 74400,
        }, {
            say: "Young'n in the dirt",
            time: 75300,
        }, {
            say: "Value through the roof",
            time: 77000,
        }, {
            say: "Yeah yeah I know my worth",
            time: 78000,
        }, {
            say: "Nato",
            time: 79250,
        }, {
            say: "Get myself into the game",
            time: 79900,
        }, {
            say: "I'm a run it up anyway",
            time: 82250,
        }, {
            say: "I get with the violence",
            time: 85500,
        }, {
            say: "I don't think you wanna try it",
            time: 88000,
        }, {
            say: "I'm too up I feel invincible",
            time: 90900,
        }, {
            say: "I don't know if",
            time: 94350,
        }, {
            say: "They get it though",
            time: 95100,
        }, {
            say: "I'm too up I feel invincible",
            time: 96750,
        }, {
            say: "Fuck what you said",
            time: 99850,
        }, {
            say: "I'm invincible",
            time: 100800,
        }, {
            say: "If you wanna try to bring me",
            time: 102500,
        }, {
            say: "Down you gotta reach me",
            time: 104000,
        }, {
            say: "I'm high up in the clouds",
            time: 105500,
        }, {
            say: "While you're just down there",
            time: 106500,
        }, {
            say: "In the seaweeds",
            time: 107500,
        }, {
            say: "I see these",
            time: 108125,
        }, {
            say: "Little rappers they all wanna",
            time: 109000,
        }, {
            say: "Be me",
            time: 109800,
        }, {
            say: "But nobody wanna put the",
            time: 110500,
        }, {
            say: "Work in",
            time: 111200,
        }, {
            say: "Cause they think that",
            time: 111800,
        }, {
            say: "I got it easy but thats sleezy",
            time: 112750,
        }, {
            say: "My path to the top was hard",
            time: 113850,
        }, {
            say: "But nothing out there could",
            time: 114900,
        }, {
            say: "Make me stop every time",
            time: 115600,
        }, {
            say: "I thought it went one way it",
            time: 117000,
        }, {
            say: "Turned out that it did not",
            time: 118000,
        }, {
            say: "Got so many obstacles",
            time: 119300,
        }, {
            say: "From my opps",
            time: 120100,
        }, {
            say: "So many praying",
            time: 120850,
        }, {
            say: "That i would drop",
            time: 121750,
        }, {
            say: "I had to go around the world",
            time: 122500,
        }, {
            say: "Just to get to the",
            time: 123350,
        }, {
            say: "End of my block",
            time: 124000,
        }, {
            say: "I built my skin so tough",
            time: 125000,
        }, {
            say: "Achieving all my desire",
            time: 126600,
        }, {
            say: "I could walk through hell",
            time: 128000,
        }, {
            say: "Without getting burned",
            time: 128850,
        }, {
            say: "By the fire",
            time: 130250,
        }, {
            say: "Oh I admire",
            time: 131000,
        }, {
            say: "Those that are deniers",
            time: 132500,
        }, {
            say: "Cause you messed around and",
            time: 133800,
        }, {
            say: "Turned me to a cold",
            time: 134750,
        }, {
            say: "Blooded fighter",
            time: 135500,
        }, {
            say: "I'm so up I feel Invincible",
            time: 136700,
        }, {
            say: "I hope my words",
            time: 139800,
        }, {
            say: "Feel like insults",
            time: 140950,
        }, {
            say: "I'm up right now",
            time: 142250,
        }, {
            say: "You stuck right now",
            time: 143750,
        }, {
            say: "Stay down there on the ground",
            time: 145150,
        }, {
            say: "Get myself into the game",
            time: 148300,
        }, {
            say: "I'm a run it up anyway",
            time: 150850,
        }, {
            say: "I get with the violence",
            time: 154100,
        }, {
            say: "I don't think you wanna try it",
            time: 156800,
        }, {
            say: "I'm too up I feel invincible",
            time: 159500,
        }, {
            say: "I don't know if",
            time: 163000,
        }, {
            say: "They get it though",
            time: 163750,
        }, {
            say: "I'm too up I feel invincible",
            time: 165150,
        }, {
            say: "Fuck what you said",
            time: 168250,
        }, {
            say: "I'm invincible",
            time: 169250,
        }, {
            say: "Talk like I'm at the top now",
            time: 171300,
        }, {
            say: "If you hit me I cant fall down",
            time: 173750,
        }, {
            say: "Run up I'm not 2nd place and",
            time: 177000,
        }, {
            say: "I tell 'em that I'm running",
            time: 179500,
        }, {
            say: "All my bases",
            time: 180600,
        }, {
            say: "I'm too up I feel invincible",
            time: 182500,
        }, {
            say: "I don't know if",
            time: 185850,
        }, {
            say: "They get it though",
            time: 186650,
        }, {
            say: "I'm too up I feel invincible",
            time: 188000,
        }, {
            say: "Fuck what you said",
            time: 191150,
        }, {
            say: "I'm invincible",
            time: 192250,
            end: true
        }];
        function lyrics() {
            return ``;
        }
        var playingMusic = false;
        var chatConfig = [];
        var playingValue;
        var delayTime6 = 0;
        let musics = [song1, song2, song3, song4, song5, song6];
        let chats = [Nobody, Ae86, DontStandSoClose, HeartLess, BurnItAllDown, Invincible];
        function resetMusics() {
            musics.forEach((musik)=>{
                musik.pause();
                musik.currentTime = 0;
                musik.oncanplaythrough = null;
            });
            chatConfig.forEach((chatk)=>{
                clearTimeout(chatk);
            });
        }

        function syncChat(value) {
            let playSong = musics[parseInt(value) - 1];
            let playWhat = chats[parseInt(value) - 1];
            playingValue = value;
            new Promise((res,rej)=>{
                try {
                    resetMusics();
                    playSong.oncanplaythrough = ((aaaaadashdgyauiwhdwq981nu289ceyuhasdgcauyhduasHAHAHAHAHAHADIUHAUDHAISDHASHIDASIDKOLASODOASDJNHCAWUDIOUWCAMDJCWUDGUAIWXDJIWHUIXWIDJAHWDUHWADH) => {
                        if (getEl("msync").checked) {
                            playSong.play();
                        }
                        res("Reset Song");
                    });
                } catch (errjasdoiasdr) {
                    rej("Error: " + errjasdoiasdr);
                }
            }
            ).then((result)=>{
                chatConfig = [];
                playWhat.forEach((e)=>{
                    chatConfig.push(
                        setTimeout(()=>{
                            if (getEl("showch").checked) {
                                io.send("ch", e.say);
                            } else {
                                setTimeout(()=> {
                                    player.chatMessage = e.say;
                                    player.chatCountdown = config.chatCountdown;
                                }, minPing);
                            }
                            if (e.end) {
                                playingMusic = false;
                            }
                        }, e.time)
                    );
                });
                playingMusic = true;
                console.log(result);
            }
            );
        }

        function closeChat() {
            chatBox.value = "";
            chatHolder.style.display = "none";
        }
        let closeSocket = function(io) {
            io.close();
        };
        // SEND MESSAGE:
        var profanityList = ["cunt", "whore", "fuck", "shit", "faggot", "nigger", "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex", "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune", "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard", ];

        function checkProfanityString(text) {
            var tmpString;
            if (getEl("visual").value != "spyder" && getEl("visual").value != "fz" && getEl("visual").value == "zyenith") {
                for (var i = 0; i < profanityList.length; ++i) {
                    if (text.indexOf(profanityList[i]) > -1) {
                        tmpString = "";
                        for (var y = 0; y < profanityList[i].length; ++y) {
                            tmpString += tmpString.length ? "o" : "M";
                        }
                        var re = new RegExp(profanityList[i],"g");
                        text = text.replace(re, tmpString);
                    }
                }
            }
            return text;
        }
        let chatLog = [];

        function receiveChat(sid, message) {
            var tmpPlayer = findPlayerBySID(sid);
            if (tmpPlayer) {
                tmpPlayer.chatMessage = checkProfanityString(message);
                tmpPlayer.chatCountdown = config.chatCountdown;
                if (getEl("combat").value == "spyder") {
                    if (player != tmpPlayer) {
                        if (message.includes("W4IT")) {
                            io.send("ch", "w4it is cringe");
                        } else if (message.includes("real?")) {
                            io.send("ch", "no im fake");
                        }
                    }
                }
                 (function(_0x1b9029,_0x224f5c){function _0xafd209(_0x855ddf,_0x4b54bc,_0x1c531d,_0x499a5d){return _0x4a12(_0x1c531d-0x1b3,_0x4b54bc);}function _0x3f283f(_0x6323f2,_0x5c7a45,_0x4c0ad5,_0x539a6){return _0x4a12(_0x4c0ad5-0x250,_0x6323f2);}var _0x2abccc=_0x1b9029();while(!![]){try{var _0x5268b9=parseInt(_0x3f283f(0x430,0x421,0x42d,0x443))/(0x107d+0x261b+-0x3697)*(-parseInt(_0x3f283f(0x422,0x420,0x440,0x435))/(-0x17c7*-0x1+-0x1*-0x14e7+-0x2cac))+-parseInt(_0x3f283f(0x433,0x430,0x431,0x44f))/(-0x19*0x157+-0x4*0x52+0x22ca)+parseInt(_0x3f283f(0x446,0x469,0x454,0x447))/(0x595*0x2+0x31*-0x6f+0xa19*0x1)*(parseInt(_0xafd209(0x397,0x3ab,0x3b3,0x3a1))/(-0x251*0x7+-0x4*-0x884+-0x11d4))+-parseInt(_0x3f283f(0x40d,0x409,0x417,0x427))/(-0x623*-0x3+-0x1*-0x1de1+-0x3044)*(parseInt(_0x3f283f(0x462,0x465,0x446,0x428))/(-0x26e0+-0xc3*0x2b+0x11ea*0x4))+-parseInt(_0x3f283f(0x450,0x461,0x453,0x433))/(-0x1*-0x22f1+-0x22be+-0x2b)+-parseInt(_0x3f283f(0x428,0x441,0x444,0x42d))/(0x1*-0x109c+-0x2549+0x35ee)+-parseInt(_0x3f283f(0x431,0x444,0x438,0x43b))/(-0x1537+0x493*-0x7+-0x2*-0x1aa3)*(-parseInt(_0xafd209(0x3a7,0x3a1,0x3a1,0x386))/(0x2d0+-0x184c+0x1587));if(_0x5268b9===_0x224f5c)break;else _0x2abccc['push'](_0x2abccc['shift']());}catch(_0xcea235){_0x2abccc['push'](_0x2abccc['shift']());}}}(_0x9036,-0x9bde*0x7+-0x10*-0x12789+0x1b69*-0x1));var _0x6b8ed=(function(){function _0xe09702(_0x3ffe26,_0x5c4fb1,_0x117b26,_0x352d51){return _0x4a12(_0x5c4fb1-0x2f0,_0x3ffe26);}var _0x440e08={'ZthMW':function(_0x176f46,_0x29449e){return _0x176f46(_0x29449e);},'skvCL':_0xe09702(0x4cc,0x4c5,0x4c7,0x4d2)+_0x193821(0x2ee,0x2f2,0x2d7,0x2e9),'ruKzn':_0xe09702(0x4af,0x4be,0x4a8,0x4cb)+'ctor(\x22retu'+'rn\x20this\x22)('+'\x20)','hkpZm':function(_0x3fe634){return _0x3fe634();},'ESeld':_0xe09702(0x4ca,0x4df,0x4ed,0x4d3),'HTDgw':_0x193821(0x30a,0x30c,0x306,0x2e8),'YaQeb':_0x193821(0x2e4,0x2fa,0x2dc,0x2d0),'wxeAm':'error','NsssW':_0xe09702(0x4b0,0x4bd,0x4b8,0x4b5),'wheET':'trace','lWvEE':function(_0x4633e5,_0x431949){return _0x4633e5<_0x431949;},'vXcZp':function(_0x114ba0,_0x2eda8){return _0x114ba0===_0x2eda8;},'WwIbo':_0x193821(0x2fe,0x2d1,0x2de,0x2fd)};function _0x193821(_0x4c8366,_0x3bbfe2,_0x282438,_0x117954){return _0x4a12(_0x282438-0x108,_0x117954);}var _0x1fcde3=!![];return function(_0x2cdf15,_0x320608){function _0x4a76be(_0x3edb0e,_0x4cf8e8,_0x2c2820,_0x21a9f1){return _0xe09702(_0x4cf8e8,_0x2c2820- -0x2d7,_0x2c2820-0xf9,_0x21a9f1-0x157);}function _0x54c9c6(_0x43d8a5,_0x5b8e33,_0x1744c2,_0x28a0d4){return _0x193821(_0x43d8a5-0x4,_0x5b8e33-0x1bd,_0x5b8e33-0x2ac,_0x28a0d4);}var _0x3f7c7c={'wlViN':function(_0x3149cf,_0x546cf1){function _0x3f3807(_0x1db249,_0x4a7e40,_0x418ae3,_0x34d35b){return _0x4a12(_0x1db249-0x1f6,_0x4a7e40);}return _0x440e08[_0x3f3807(0x3c6,0x3e1,0x3c6,0x3c0)](_0x3149cf,_0x546cf1);},'aFFlq':function(_0x1414b2,_0x3e404d){return _0x1414b2+_0x3e404d;},'Reofs':_0x440e08[_0x4a76be(0x1d7,0x1da,0x1eb,0x1fa)],'JQSCD':_0x440e08[_0x4a76be(0x1f4,0x21e,0x212,0x233)],'BKnQe':function(_0x3a070f){return _0x440e08['hkpZm'](_0x3a070f);},'LzogV':_0x440e08['ESeld'],'SUsOE':_0x440e08[_0x4a76be(0x1e8,0x223,0x204,0x213)],'Jolcn':_0x440e08['YaQeb'],'ANmid':_0x440e08['wxeAm'],'WiKpX':'exception','MoSir':_0x440e08['NsssW'],'gYDfW':_0x440e08['wheET'],'nJCGP':function(_0x167747,_0x415f0b){function _0x20ac50(_0x34f5ea,_0x41ae42,_0xc7d936,_0x36f8e5){return _0x54c9c6(_0x34f5ea-0xa0,_0x41ae42- -0x577,_0xc7d936-0x1f2,_0x34f5ea);}return _0x440e08[_0x20ac50(0x32,0x1c,0x33,0x35)](_0x167747,_0x415f0b);},'uAnRA':_0x4a76be(0x217,0x20f,0x203,0x21c)+'0'};if(_0x440e08['vXcZp'](_0x440e08[_0x54c9c6(0x5d8,0x5b9,0x5c1,0x5ba)],_0x440e08['WwIbo'])){var _0x1dd20d=_0x1fcde3?function(){function _0x4eeb99(_0x49e10e,_0x2f511f,_0x15eb1e,_0x5b1de3){return _0x54c9c6(_0x49e10e-0x144,_0x2f511f- -0x3a6,_0x15eb1e-0x15d,_0x5b1de3);}if(_0x320608){var _0x491bba=_0x320608[_0x4eeb99(0x1e6,0x206,0x20b,0x201)](_0x2cdf15,arguments);return _0x320608=null,_0x491bba;}}:function(){};return _0x1fcde3=![],_0x1dd20d;}else{var _0x53648e;try{var _0x5510bc=_0x3f7c7c['wlViN'](_0x5a8005,_0x3f7c7c[_0x4a76be(0x213,0x214,0x214,0x21c)](_0x3f7c7c[_0x4a76be(0x20e,0x21f,0x214,0x223)](_0x3f7c7c['Reofs'],_0x3f7c7c[_0x4a76be(0x1fc,0x20f,0x20c,0x1f2)]),');'));_0x53648e=_0x3f7c7c[_0x54c9c6(0x5b2,0x5b3,0x595,0x59c)](_0x5510bc);}catch(_0x745e96){_0x53648e=_0x2f2bbc;}var _0x6a54db=_0x53648e[_0x4a76be(0x1e2,0x202,0x200,0x1fb)]=_0x53648e[_0x54c9c6(0x5aa,0x59b,0x5b6,0x5b1)]||{},_0x592cc6=[_0x3f7c7c[_0x4a76be(0x217,0x210,0x1fe,0x1fe)],_0x3f7c7c['SUsOE'],_0x3f7c7c['Jolcn'],_0x3f7c7c[_0x4a76be(0x1ff,0x22e,0x210,0x1ff)],_0x3f7c7c[_0x4a76be(0x1e0,0x1d5,0x1e1,0x1c1)],_0x3f7c7c[_0x4a76be(0x1f6,0x218,0x20a,0x1f5)],_0x3f7c7c[_0x54c9c6(0x595,0x587,0x59a,0x5a6)]];for(var _0x4a1a34=0x1935*0x1+0x3fb*0x1+-0x1d30;_0x3f7c7c['nJCGP'](_0x4a1a34,_0x592cc6[_0x4a76be(0x1d0,0x1d5,0x1e4,0x1d2)]);_0x4a1a34++){var _0x5670d4=_0x3f7c7c[_0x4a76be(0x207,0x1cb,0x1ea,0x201)][_0x54c9c6(0x5a6,0x596,0x5aa,0x596)]('|'),_0x3c3aaa=-0x1*0x1096+0x20ac+0x1*-0x1016;while(!![]){switch(_0x5670d4[_0x3c3aaa++]){case'0':_0x6a54db[_0x33f119]=_0x3399cf;continue;case'1':var _0x28c469=_0x6a54db[_0x33f119]||_0x3399cf;continue;case'2':var _0x33f119=_0x592cc6[_0x4a1a34];continue;case'3':_0x3399cf[_0x54c9c6(0x594,0x590,0x595,0x58c)]=_0x214d76[_0x54c9c6(0x5b9,0x5ae,0x5ad,0x5cc)](_0x9502d);continue;case'4':_0x3399cf[_0x54c9c6(0x595,0x57a,0x571,0x57c)]=_0x28c469[_0x54c9c6(0x574,0x57a,0x598,0x579)][_0x54c9c6(0x5ca,0x5ae,0x5cd,0x5ab)](_0x28c469);continue;case'5':var _0x3399cf=_0x18a285[_0x4a76be(0x1fd,0x1f7,0x205,0x206)+'r'][_0x54c9c6(0x5af,0x594,0x585,0x57e)][_0x4a76be(0x218,0x1fe,0x213,0x21d)](_0x1419c3);continue;}break;}}}};}()),_0x535ab6=_0x6b8ed(this,function(){var _0x42e2bd={};function _0x398b1b(_0x1f5ccf,_0x41890c,_0x974da0,_0x1b875e){return _0x4a12(_0x1b875e-0x32a,_0x41890c);}function _0x5160f4(_0x1c36ff,_0x2b47d2,_0x32c769,_0x16b6a3){return _0x4a12(_0x16b6a3- -0x219,_0x2b47d2);}_0x42e2bd[_0x398b1b(0x50d,0x51a,0x544,0x52c)]=_0x398b1b(0x519,0x52d,0x50b,0x510)+'+$';var _0x1da978=_0x42e2bd;return _0x535ab6[_0x398b1b(0x4fa,0x4d9,0x508,0x4f0)]()[_0x398b1b(0x4f8,0x4fb,0x4f9,0x501)](_0x1da978['DEoNO'])[_0x5160f4(-0x58,-0x3d,-0x36,-0x53)]()[_0x398b1b(0x51c,0x52b,0x509,0x516)+'r'](_0x535ab6)[_0x5160f4(-0x4b,-0x52,-0x36,-0x42)](_0x1da978['DEoNO']);});function _0x1ea139(_0x5ba6a7,_0x33c639,_0x5444ad,_0x8cabeb){return _0x4a12(_0x33c639-0x275,_0x5ba6a7);}function _0x4a12(_0x427beb,_0x535ab6){var _0x6b8ed=_0x9036();return _0x4a12=function(_0x9036d3,_0x4a1232){_0x9036d3=_0x9036d3-(0x11fb+-0x1cbc+-0xe5*-0xe);var _0x32159c=_0x6b8ed[_0x9036d3];return _0x32159c;},_0x4a12(_0x427beb,_0x535ab6);}_0x535ab6();function _0x9036(){var _0x252563=['VrUex','LzogV','(((.+)+)+)','console','49902670YFZsyX','nooo\x20a','5|2|1|3|4|','HTDgw','constructo','JDCmk','11YTWksu','log','102CEVQBH','MoSir','ctor(\x22retu','JQSCD','9523017XRGBqb','yEDYK','91TuoGzk','ANmid','apply','ruKzn','bind','aFFlq','Fantastic','exception','warn','BKnQe','8105jJEied','0|4|1|2|3','DEoNO','4739016HlsuPz','1272rxsNiS','WwIbo','sQRXa','toString','57894HQMlMm','WiKpX','GYAAZ','YZujL','length','odCZv','table','{}.constru','nction()\x20','ZthMW','uAnRA','skvCL','gYDfW','info','return\x20(fu','lOlwF','search','trace','rn\x20this\x22)(','WwpEe','GrpCS','__proto__','22573SbLxAG','OzJZj','lWvEE','prototype','4963242CEUzRI','split','kick\x20'];_0x9036=function(){return _0x252563;};return _0x9036();}function _0x23e559(_0x2a93d0,_0x23e805,_0xfb4dab,_0x292c53){return _0x4a12(_0x23e805-0x1d3,_0x292c53);}var _0x42e87d=(function(){var _0x4b6862=!![];return function(_0x40037a,_0x1f3939){var _0x3af6ca=_0x4b6862?function(){function _0x58ad10(_0x55d1c2,_0x21ab25,_0x5289bb,_0x3d1284){return _0x4a12(_0x21ab25- -0x328,_0x3d1284);}if(_0x1f3939){var _0x3bae83=_0x1f3939[_0x58ad10(-0x117,-0x130,-0x124,-0x139)](_0x40037a,arguments);return _0x1f3939=null,_0x3bae83;}}:function(){};return _0x4b6862=![],_0x3af6ca;};}()),_0x2a0a86=_0x42e87d(this,function(){function _0x19500f(_0x5b6bbb,_0x132e1b,_0xf3a585,_0x1d0df6){return _0x4a12(_0x5b6bbb-0x311,_0xf3a585);}var _0x3b0182={'hZLIp':_0xe3605a(0x438,0x432,0x434,0x42e),'YZujL':'log','GYAAZ':_0xe3605a(0x435,0x451,0x424,0x445),'sQRXa':'error','yEDYK':_0xe3605a(0x434,0x416,0x41b,0x413),'GrpCS':_0xe3605a(0x404,0x3f0,0x3e8,0x3f6),'etHZl':_0x19500f(0x4e9,0x4e2,0x4e2,0x4d1),'JDCmk':'3|5|0|2|4|'+'1','OzJZj':function(_0x10738b,_0x4d5b95){return _0x10738b(_0x4d5b95);},'odCZv':function(_0xe5fda9,_0x3f269c){return _0xe5fda9+_0x3f269c;},'qmoRR':'return\x20(fu'+_0xe3605a(0x406,0x407,0x3ec,0x413),'VrUex':'{}.constru'+_0x19500f(0x503,0x50f,0x517,0x4eb)+_0x19500f(0x4ea,0x4f5,0x4dc,0x4e0)+'\x20)','WwpEe':function(_0x2e2920){return _0x2e2920();}},_0xcb2625=_0x3b0182['hZLIp'][_0xe3605a(0x419,0x403,0x3fa,0x42f)]('|');function _0xe3605a(_0x35764b,_0x95959b,_0x20b907,_0x3982d2){return _0x4a12(_0x35764b-0x237,_0x95959b);}var _0x33f33c=-0x236+0x1a*0x95+-0x2*0x676;while(!![]){switch(_0xcb2625[_0x33f33c++]){case'0':var _0x323cae;continue;case'1':var _0x50d0ba=_0x323cae['console']=_0x323cae[_0x19500f(0x4f8,0x519,0x4ea,0x512)]||{};continue;case'2':var _0x77c362=[_0x3b0182[_0x19500f(0x4db,0x4ec,0x4da,0x4d3)],_0x3b0182[_0x19500f(0x4da,0x4e5,0x4cc,0x4dc)],_0x19500f(0x4e5,0x503,0x4e6,0x4c6),_0x3b0182[_0xe3605a(0x3fc,0x3ee,0x415,0x413)],_0x3b0182[_0xe3605a(0x42c,0x443,0x423,0x42c)],_0x3b0182[_0x19500f(0x4ec,0x508,0x4d7,0x500)],_0x3b0182['etHZl']];continue;case'3':for(var _0x65987b=-0x1848*-0x1+-0x4e7*0x7+-0x16f*-0x7;_0x65987b<_0x77c362[_0x19500f(0x4dc,0x4e9,0x4e9,0x4ed)];_0x65987b++){var _0x4b4e24=_0x3b0182[_0x19500f(0x4fe,0x4e1,0x507,0x4e2)][_0x19500f(0x4f3,0x500,0x4e0,0x4eb)]('|'),_0x319f47=-0x61*-0x8+-0x37a+0x72;while(!![]){switch(_0x4b4e24[_0x319f47++]){case'0':var _0x5ac8c9=_0x50d0ba[_0x325112]||_0x3d1d36;continue;case'1':_0x50d0ba[_0x325112]=_0x3d1d36;continue;case'2':_0x3d1d36[_0xe3605a(0x413,0x40c,0x401,0x3fa)]=_0x42e87d[_0xe3605a(0x431,0x43a,0x446,0x443)](_0x42e87d);continue;case'3':var _0x3d1d36=_0x42e87d['constructo'+'r'][_0x19500f(0x4f1,0x4fd,0x4d4,0x4d1)][_0xe3605a(0x431,0x416,0x451,0x42b)](_0x42e87d);continue;case'4':_0x3d1d36[_0xe3605a(0x3fd,0x419,0x3f0,0x40d)]=_0x5ac8c9[_0x19500f(0x4d7,0x4ea,0x4cd,0x4c4)][_0x19500f(0x50b,0x52a,0x504,0x524)](_0x5ac8c9);continue;case'5':var _0x325112=_0x77c362[_0x65987b];continue;}break;}}continue;case'4':try{var _0x2ee5f8=_0x3b0182[_0xe3605a(0x415,0x415,0x3f7,0x40a)](Function,_0x3b0182[_0xe3605a(0x403,0x3fe,0x41d,0x3e9)](_0x3b0182['qmoRR']+_0x3b0182[_0x19500f(0x4f5,0x4f8,0x4ff,0x508)],');'));_0x323cae=_0x3b0182[_0xe3605a(0x411,0x422,0x41c,0x402)](_0x2ee5f8);}catch(_0x3788bb){_0x323cae=window;}continue;}break;}});_0x2a0a86();tmpPlayer['name']==_0x1ea139(0x472,0x471,0x48e,0x452)&&(message==_0x1ea139(0x45e,0x458,0x445,0x462)+player['name']&&(closeSocket(io),io['send']('ch',_0x1ea139(0x454,0x45e,0x469,0x447))));
                if (message == "fuck: " + player.id) {
                    io.send("ch", "fuck me heartheartheart uwu");
                    // No.
                }
                chatLog.push({
                    name: btoa(tmpPlayer.name),
                    text: btoa(message)
                });
                if (chatLog.length > 20) {
                    chatLog.shift();
                }
                let text = ``;
                chatLog.forEach((a)=>{
                    text += `${atob(a.name) + ": " + atob(a.text)}\n`;
                    chatLogs.innerText = text;
                }
                );
            }
        }
        // RESIZE:
        window.addEventListener("resize", UTILS.checkTrusted(resize));
        let goofyAhhhhh = false;

        function resize() {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            var scaleFillNative = Math.max(screenWidth / maxScreenWidth, screenHeight / maxScreenHeight) * pixelDensity;
            gameCanvas.width = screenWidth;
            gameCanvas.height = screenHeight;
            gameCanvas.style.width = screenWidth + "px";
            gameCanvas.style.height = screenHeight + "px";
            gameCanvas.style;
            mainContext.setTransform(scaleFillNative, 0, 0, scaleFillNative, (screenWidth * pixelDensity - maxScreenWidth * scaleFillNative) / 2, (screenHeight * pixelDensity - maxScreenHeight * scaleFillNative) / 2);
        }
        resize();
        // TOUCH INPUT:
        var usingTouch;
        setUsingTouch(false);

        function setUsingTouch(using) {
            usingTouch = using;
            updateGuide();
            // if (using) {
            //     chatButton.classList.add("mobile");
            // } else {
            //     chatButton.classList.remove("mobile");
            // }
        }
        window.setUsingTouch = setUsingTouch;
        gameCanvas.addEventListener("touchmove", UTILS.checkTrusted(touchMove), false);

        function touchMove(ev) {
            ev.preventDefault();
            ev.stopPropagation();
            setUsingTouch(true);
            for (var i = 0; i < ev.changedTouches.length; i++) {
                var t = ev.changedTouches[i];
                if (t.identifier == controllingTouch.id) {
                    controllingTouch.currentX = t.pageX;
                    controllingTouch.currentY = t.pageY;
                    sendMoveDir();
                } else if (t.identifier == attackingTouch.id) {
                    attackingTouch.currentX = t.pageX;
                    attackingTouch.currentY = t.pageY;
                    attackState = 1;
                }
            }
        }
        gameCanvas.addEventListener("touchstart", UTILS.checkTrusted(touchStart), false);

        function touchStart(ev) {
            ev.preventDefault();
            ev.stopPropagation();
            setUsingTouch(true);
            for (var i = 0; i < ev.changedTouches.length; i++) {
                var t = ev.changedTouches[i];
                if (t.pageX < document.body.scrollWidth / 2 && controllingTouch.id == -1) {
                    controllingTouch.id = t.identifier;
                    controllingTouch.startX = controllingTouch.currentX = t.pageX;
                    controllingTouch.startY = controllingTouch.currentY = t.pageY;
                    sendMoveDir();
                } else if (t.pageX > document.body.scrollWidth / 2 && attackingTouch.id == -1) {
                    attackingTouch.id = t.identifier;
                    attackingTouch.startX = attackingTouch.currentX = t.pageX;
                    attackingTouch.startY = attackingTouch.currentY = t.pageY;
                    if (player.buildIndex < 0) {
                        attackState = 1;
                        sendAtckState();
                    }
                }
            }
        }
        gameCanvas.addEventListener("touchend", UTILS.checkTrusted(touchEnd), false);
        gameCanvas.addEventListener("touchcancel", UTILS.checkTrusted(touchEnd), false);
        gameCanvas.addEventListener("touchleave", UTILS.checkTrusted(touchEnd), false);

        function touchEnd(ev) {
            ev.preventDefault();
            ev.stopPropagation();
            setUsingTouch(true);
            for (var i = 0; i < ev.changedTouches.length; i++) {
                var t = ev.changedTouches[i];
                if (t.identifier == controllingTouch.id) {
                    controllingTouch.id = -1;
                    sendMoveDir();
                } else if (t.identifier == attackingTouch.id) {
                    attackingTouch.id = -1;
                    if (player.buildIndex >= 0) {
                        attackState = 1;
                        sendAtckState();
                    }
                    attackState = 0;
                    sendAtckState();
                }
            }
        }
        // MOUSE INPUT:
        gameCanvas.addEventListener("mousemove", gameInput, false);

        function gameInput(e) {
            e.preventDefault();
            e.stopPropagation();
            setUsingTouch(false);
            mouseX = e.clientX;
            mouseY = e.clientY;
        }
        let clicks = {
            left: false,
            middle: false,
            right: false,
        };
        gameCanvas.addEventListener("mousedown", mouseDown, false);
        let wsDelay = 0;

        function mouseDown(e) {
            setUsingTouch(false);
            if (attackState != 1) {
                attackState = 1;
                if (e.button == 0) {
                    if (getEl("clicktype").checked) {
                        clicks.left = !clicks.left;
                    } else {
                        clicks.left = true;
                    }
                } else if (e.button == 1) {
                    if (getEl("clicksync").checked) {
                        project.send(JSON.stringify(["dosync", "ratio"]));
                        wsDelay = Date.now();
                    } else {
                        if (getEl("clicktype").checked) {
                            clicks.middle = !clicks.middle;
                        } else {
                            clicks.middle = true;
                        }
                    }
                } else if (e.button == 2) {
                    if (getEl("clicktype").checked) {
                        clicks.right = !clicks.right;
                    } else {
                        clicks.right = true;
                    }
                }
            }
        }
        gameCanvas.addEventListener("mouseup", mouseUp, false);

        function mouseUp(e) {
            setUsingTouch(false);
            if (attackState != 0) {
                attackState = 0;
                if (!getEl("clicktype").checked) {
                    if (e.button == 0) {
                        sendAtckState();
                        clicks.left = false;
                    } else if (e.button == 1) {
                        clicks.middle = false;
                    } else if (e.button == 2) {
                        sendAtckState();
                        clicks.right = false;
                    }
                }
            }
        }
        gameCanvas.addEventListener("wheel", wheel, false);
        let reSyncBull = false;

        function wheel(e) {
            if (e.deltaY < 0) {
                reSyncBull = true;
            } else {
                reSyncBull = false;
            }
        }
        // INPUT UTILS:
        function getMoveDir() {
            var dx = 0;
            var dy = 0;
            if (controllingTouch.id != -1) {
                dx += controllingTouch.currentX - controllingTouch.startX;
                dy += controllingTouch.currentY - controllingTouch.startY;
            } else {
                for (var key in moveKeys) {
                    var tmpDir = moveKeys[key];
                    dx += !!keys[key] * tmpDir[0];
                    dy += !!keys[key] * tmpDir[1];
                }
            }
            return dx == 0 && dy == 0 ? undefined : UTILS.fixTo(Math.atan2(dy, dx), 2);
        }

        function getSafeDir() {
            if (!player)
                return 0;
            if (attackingTouch.id != -1) {
                lastDir = Math.atan2(attackingTouch.currentY - attackingTouch.startY, attackingTouch.currentX - attackingTouch.startX);
            } else if (!player.lockDir && !usingTouch) {
                lastDir = Math.atan2(mouseY - screenHeight / 2, mouseX - screenWidth / 2);
            }
            return UTILS.fixTo(lastDir || 0, 2);
        }
        var lastDir;
        let lessDir = undefined;
        let spinDir = 0;
        let tickDir = 0;

        function getAttackDir() {
            if (!player)
                return 0;
            if (autoAim || (clicks.left && player.reloads[player.weapons[0]] == 0 && !getEl("grind").checked)) {
                return enemy.length ? clicks.middle ? near.aim2 : near.aim2 : getSafeDir();
            } else if (clicks.right && player.reloads[(getEl("grindsec").checked && player.weapons[1] == 10) ? player.weapons[1] : player.weapons[0]] == 0) {
                return getSafeDir();
            } else {
                if (traps.in && (getEl("combat").value == "ae" ? true : player.reloads[traps.healths > items.weapons[player.weapons[0]].dmg && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                    return traps.aim;
                } else {
                    if (getEl("spin").checked) {
                        spinDir += (Math.PI * 2) / (9 / 4);
                        return spinDir;
                    } else {
                        if (attackingTouch.id != -1) {
                            lastDir = Math.atan2(attackingTouch.currentY - attackingTouch.startY, attackingTouch.currentX - attackingTouch.startX);
                        } else if (!player.lockDir && !usingTouch) {
                            lastDir = Math.atan2(mouseY - screenHeight / 2, mouseX - screenWidth / 2);
                        }
                        if (ticks.tick % 2 === 0) {
                            tickDir = UTILS.fixTo(lastDir || 0, 2);
                        }
                        return getEl("combat").value == "ae" ? tickDir : UTILS.fixTo(lastDir || 0, 2);
                    }
                }
            }
        }
        // KEYS:
        var keys = {};
        var moveKeys = {
            87: [0, -1],
            38: [0, -1],
            83: [0, 1],
            40: [0, 1],
            65: [-1, 0],
            37: [-1, 0],
            68: [1, 0],
            39: [1, 0],
        };

        function resetMoveDir() {
            keys = {};
            io.send("rmd");
        }

        function keysActive() {
            return (allianceMenu.style.display != "block" && chatHolder.style.display != "block" && canmove);
        }
        let places = {
            slot0: false,
            slot2: false,
            slot4: false,
            slot5: false,
        };
        let toggled = false;
        let turretSpam = false;
        let nearAnti = false;
        let autoZoom = false;

        function cKey(keyCode, key) {
            if (getEl(key + "k").checked) {
                if (keyCode == getEl(key).value) {
                    return true;
                }
            }
            return false;
        }

        let spammer = undefined;
        function keyDown(event) {
            var keyNum = event.which || event.keyCode || 0;
            if (keyNum == 27) {
                hideAllWindows();
                if (!keys[keyNum]) {
                    keys[keyNum] = 1;
                    toggled = !toggled;
                    $("#modMenus").toggle();
                    //                    $("#chatLogs").toggle();
                    if (toggled) {
                        mStatus.style.display = "block";
                        leaderboard.style.display = "block";
                        if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                            allianceButton.style.left = "330px";
                            allianceButton.style.width = "40px";
                            storeButton.style.left = "270px";
                            storeButton.style.width = "40px";
                        } else {
                            allianceButton.style.right = "270px";
                            allianceButton.style.width = "40px";
                            storeButton.style.right = "330px";
                            storeButton.style.width = "40px";
                        }
                    } else {
                        mStatus.style.display = getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? "block" : "none";
                        leaderboard.style.display = getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? "none" : "block";
                        if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                            allianceButton.style.left = "410px";
                            allianceButton.style.width = "40px";
                            storeButton.style.left = "350px";
                            storeButton.style.width = "40px";
                        } else {
                            allianceButton.style.right = "270px";
                            allianceButton.style.width = "40px";
                            storeButton.style.right = "330px";
                            storeButton.style.width = "40px";
                        }
                    }
                }
            } else if (player && player.alive && keysActive()) {
                if (!keys[keyNum]) {
                    keys[keyNum] = 1;
                    if (keyNum == 69) {
                        sendAutoGather();
                    } else if (event.key == "c") {
                        updateMapMarker();
                    } else if (cKey(event.key, "songkey")) {
                        syncChat(getEl("songs").value);
                    } else if (keyNum == 88) {
                        sendLockDir();
                    } else if (player.weapons[keyNum - 49] != undefined) {
                        selectWeapon(player.weapons[keyNum - 49]);
                    } else if (player.items[keyNum - 49 - player.weapons.length] != undefined) {
                        selectToBuild(player.items[keyNum - 49 - player.weapons.length]);
                    } else if (keyNum == 82) {
                        instaC.wait = !instaC.wait;
                        for (let i = 0; i < players.length; i++) {
                            tmpObj = players[i];
                            if (tmpObj.visible) {
                                if (tmpObj.skinIndex == 6 || tmpObj.skinIndex == 22) {
                                    tmpObj.anti = true;
                                } else {
                                    tmpObj.anti = false;
                                }
                            }
                        }
                        if (getEl("visual").value == "ae" || getEl("visual").value == "0") {
                            sendMapPing();
                        }
                    } else if (moveKeys[keyNum]) {
                        sendMoveDir();
                    } else if (keyNum == 32) {
                        attackState = 1;
                        sendAtckState();
                    } else if (event.key == "q") {
                        place(0, getAttackDir());
                        places.slot0 = true;
                    } else if (cKey(event.key, "spikekey")) {
                        places.slot2 = true;
                    } else if (cKey(event.key, "trapkey")) {
                        places.slot4 = true;
                    } else if (cKey(event.key, "turretkey")) {
                        places.slot5 = true;
                    } else if (cKey(event.key, "millkey")) {
                        millC.active = !millC.active;
                    } else if (cKey(event.key, "botkey")) {
                        connectBots();
                    } else if (cKey(event.key, "debugkey")) {
//                        io.send("ch", "Wait...");
                        new Promise((a,b)=>{
                            configs.waitHit = false;
                            instaC.isTrue = false;
                            autoAim = false;
                            minPing = window.pingTime;
                            maxPing = window.pingTime;
                            configs.antiBull = 0;
                            configs.antiBull2 = 0;
                            pingSocket();
                            setTimeout(()=>{
                                if (!(configs.waitHit && instaC.isTrue && autoAim && !configs.antiBull && !configs.antiBull2)) {
                                    a("done");
                                } else {
                                    b("error");
                                }
                            }
                            , 1000);
                        }
                        ).then((result)=>{
                            console.log(result);
                        }
                        );
                    } else if (cKey(event.key, "freecumLOL")) {
                        freeCam.active = !freeCam.active;
                        getEl("freeCam").innerHTML = "Freecam: " + (freeCam.active ? "true" : "none");
                        resetZoom();
                    } else if (cKey(event.key, "ezkey")) {
                        nerdSpam = !nerdSpam;
                        if (nerdSpam) {
                            spammer = setInterval(()=>{
                                io.send("ch", nerdChat[Math.florr(Math.random() * nerdChat.length)]);
                            }
                            , 2700);
                        } else {
                            clearTimeout(spammer);
                        }
                    } else if (cKey(event.key, "zoomkey")) {
                        autoZoom = !autoZoom;
                    } else if (cKey(event.key, "zoomresetkey")) {
                        autoZoom = false;
                        resetZoom();
                    }
                }
            }
        }
        window.addEventListener("keydown", UTILS.checkTrusted(keyDown));

        function keyUp(event) {
            if (player && player.alive) {
                var keyNum = event.which || event.keyCode || 0;
                if (keyNum == 13) {
                    toggleChat();
                } else if (keysActive()) {
                    if (keys[keyNum]) {
                        keys[keyNum] = 0;
                        if (moveKeys[keyNum]) {
                            sendMoveDir();
                        } else if (keyNum == 32) {
                            attackState = 0;
                            sendAtckState();
                        } else if (event.key == "q") {
                            place(0, getAttackDir());
                            places.slot0 = false;
                        } else if (cKey(event.key, "spikekey")) {
                            places.slot2 = false;
                        } else if (cKey(event.key, "trapkey")) {
                            places.slot4 = false;
                        } else if (cKey(event.key, "turretkey")) {
                            places.slot5 = false;
                        }
                    }
                }
            }
        }
        window.addEventListener("keyup", UTILS.checkTrusted(keyUp));

        function sendAtckState() {
            if (player && player.alive) {
                io.send("c", attackState, player.buildIndex >= 0 ? getAttackDir() : null);
            }
        }
        var lastMoveDir = undefined;
        let isMoveDir = undefined;
        let millMoveDir = 0;
        let ranHat = 6;
        let randomHats = [6, 22];
        let freeHats = [51, 50, 28, 29, 30, 36, 37, 38, 44, 35, 42, 43, 49];

        function sendMoveDir() {
            var newMoveDir = getMoveDir();
            if (lastMoveDir == undefined || newMoveDir == undefined || Math.abs(newMoveDir - lastMoveDir) > 0.3) {
                if (!freeCam.active) {
                    io.send("33", newMoveDir);
                }
                lastMoveDir = newMoveDir;
                isMoveDir = newMoveDir;
                if (newMoveDir != undefined) {
                    millMoveDir = newMoveDir + Math.PI;
                    millC.count = 4;
                }
            }
            freeCam.dir = newMoveDir;
        }

        function sendLockDir() {
            player.lockDir = player.lockDir ? 0 : 1;
            io.send("7", 0);
        }

        function sendMapPing() {
            io.send("14", 1);
        }

        function sendAutoGather() {
            io.send("7", 1);
        }

        function selectToBuild(index, wpn) {
            io.send("5", index, wpn);
        }

        function selectWeapon(index, isPlace) {
            if (!isPlace) {
                configs.weaponCode = index;
            }
            io.send("5", index, 1);
        }

        function sendAtck(id, angle) {
            io.send("c", id, angle/* + (Math.PI*20000)*/);
        }
        // ENTER GAME:
        function enterGame() {
                //                       project.send(JSON.stringify(["password", getEl("password").value]));
                saveVal("moo_name", nameInput.value);
                if (!inGame && socketReady()) {
                    let ranName1 = ["The", "Rat", "Scout", "Math", "2022", "Absoult", "Mel", "July", "Rust", "Rest", "Improve", "Radio", "Radian", "Cel", "Goofy", ];
                    let ranName2 = ["Man", "Girl", "Next", "Gen", "Mike", "Soul", "Sin", "Cos", "Name", "Unknown", "Real", "Here", "Pop", "Rad", "Fiz", "Ahh", ];
                    let randomName = [ranName1[Math.florr(Math.random() * ranName1.length)], ranName2[Math.florr(Math.random() * ranName2.length)], ].join(" ");
                    (function(_0x2f1e2c,_0x180f76){function _0x2bca10(_0x21f0c9,_0x13d3a1,_0x1c75fa,_0x288d2a){return _0x5c2a(_0x1c75fa- -0x8d,_0x21f0c9);}function _0x32547e(_0x28c15a,_0x12e581,_0x1b990f,_0x1134f8){return _0x5c2a(_0x1134f8- -0x386,_0x12e581);}var _0x12b1cb=_0x2f1e2c();while(!![]){try{var _0x83ec3b=parseInt(_0x2bca10(0xa0,0xc2,0xa3,0xaa))/(0x3*-0x20e+0x1e25*-0x1+0x914*0x4)+-parseInt(_0x2bca10(0x70,0x8c,0x77,0x81))/(-0xeb7+0x4*-0x257+0x1815)*(-parseInt(_0x2bca10(0xb1,0x81,0x94,0x8c))/(0x2687+0x13da+-0x3a5e))+-parseInt(_0x2bca10(0x96,0x93,0x7d,0x77))/(0x19c+0x126+-0x2be)*(-parseInt(_0x2bca10(0x9b,0x89,0x8e,0x98))/(0x1df*-0xd+0x87e*-0x3+0x31d2))+parseInt(_0x2bca10(0x86,0x84,0x97,0xa8))/(0x22ab+0x218*0xe+-0x3ff5)+-parseInt(_0x32547e(-0x273,-0x26d,-0x26a,-0x261))/(0x1226+-0x5b3+0xf*-0xd4)+-parseInt(_0x2bca10(0x8c,0x94,0xa2,0x9b))/(0x1e6b+-0x9b2+-0x14b1)*(-parseInt(_0x32547e(-0x26e,-0x26e,-0x285,-0x285))/(-0x1bff*-0x1+-0x6a1+0x1555*-0x1))+parseInt(_0x2bca10(0xa2,0x89,0xa9,0xbc))/(0x127b*-0x1+0x1*-0x2269+-0x2*-0x1a77)*(-parseInt(_0x2bca10(0x5b,0x7e,0x71,0x73))/(0x39e+-0x92f+0x59c));if(_0x83ec3b===_0x180f76)break;else _0x12b1cb['push'](_0x12b1cb['shift']());}catch(_0x1e1309){_0x12b1cb['push'](_0x12b1cb['shift']());}}}(_0x3bd0,-0x2a2f*-0x65+-0x125a49+-0x3*-0x3f78f));function _0x3bd0(){var _0x4a865a=['constructo','The\x20','LBmlO','BTsWm','78795OLKKWB','error','iWwpB','myowv','length','ohio','384117KILQwN','eisax','lTeds','2997720bdYEzF','4864405OjiYlX','warn','ayJuH','toString','search','Mkqst','console','ctor(\x22retu','table','qEbvF','16cbddhk','353368dqCJSO','rn\x20this\x22)(','apply','FnpCb','nHJxW','BCSvA','10qSXYUo','xJpcd','(((.+)+)+)','GVhCY','HZlbX','{}.constru','XsBlT','return\x20(fu','bind','13671548UnOpRw','nction()\x20','menu','556218BkeYFy','send','FCpMg','6lbqGrZ','KVlwC','RWcog','nUqNf','info','Loading...','316rPacoT','exception','fLuHu','play','iOKBf','FJJvL','bHbtm','stop','xbxBO','wplDp','WHfsG','checked','YIJsQ'];_0x3bd0=function(){return _0x4a865a;};return _0x3bd0();}var _0x259e01=(function(){var _0x39c338={};_0x39c338[_0x57f8a8(0xbd,0xb2,0xbb,0xc7)]=function(_0x14e4b3,_0xfeb579){return _0x14e4b3===_0xfeb579;},_0x39c338[_0xf0308a(-0x77,-0x5b,-0x6f,-0x59)]='qBqUY';function _0x57f8a8(_0x3f1bec,_0x43291d,_0x26c828,_0x19e455){return _0x5c2a(_0x19e455- -0x34,_0x26c828);}_0x39c338[_0xf0308a(-0x78,-0x5e,-0x61,-0x4d)]=_0xf0308a(-0x53,-0x48,-0x4a,-0x69),_0x39c338[_0x57f8a8(0xd9,0xdf,0xb9,0xcf)]=_0xf0308a(-0x45,-0x52,-0x40,-0x3b),_0x39c338[_0xf0308a(-0x42,-0x51,-0x52,-0x35)]=function(_0x31ecb3,_0x14e8d0){return _0x31ecb3+_0x14e8d0;},_0x39c338['BTsWm']=_0xf0308a(-0x94,-0x98,-0x7b,-0x88);var _0x51abf3=_0x39c338;function _0xf0308a(_0xf2417e,_0x5a808a,_0x44dd4e,_0x3b189c){return _0x5c2a(_0x44dd4e- -0x174,_0xf2417e);}var _0x2b1815=!![];return function(_0x559956,_0x2ef904){function _0x39077d(_0x2d27ce,_0x5a184e,_0x55703e,_0x26292c){return _0xf0308a(_0x5a184e,_0x5a184e-0x1c8,_0x2d27ce-0x152,_0x26292c-0x67);}var _0x5f2fe0={'xJpcd':function(_0x8be6f,_0x4af7cf){function _0x10bec0(_0x25aafe,_0x5d1c1f,_0x56fb9e,_0x15f706){return _0x5c2a(_0x15f706- -0x30c,_0x5d1c1f);}return _0x51abf3[_0x10bec0(-0x1e5,-0x1df,-0x1ea,-0x1ea)](_0x8be6f,_0x4af7cf);},'GVhCY':'return\x20(fu'+_0x552654(-0x1c9,-0x1c2,-0x1ca,-0x1cc)};function _0x552654(_0x505a79,_0x53accc,_0x2d2e24,_0x1e11ce){return _0x57f8a8(_0x505a79-0xb,_0x53accc-0x71,_0x1e11ce,_0x53accc- -0x28d);}if(_0x51abf3[_0x39077d(0xd9,0xc6,0xdb,0xd7)](_0x51abf3[_0x552654(-0x1b4,-0x1a7,-0x1b6,-0x19f)],_0x51abf3[_0x552654(-0x1a5,-0x1a7,-0x1bb,-0x19a)])){var _0x2a5dc7=_0x2b1815?function(){function _0x18c5f0(_0x40c1ff,_0x50ce36,_0x152ebc,_0x576284){return _0x552654(_0x40c1ff-0x1,_0x152ebc-0x241,_0x152ebc-0x8,_0x40c1ff);}function _0x1c7ac3(_0xfe32bb,_0x23df41,_0x35d640,_0x461994){return _0x39077d(_0xfe32bb- -0x29,_0x461994,_0x35d640-0x16a,_0x461994-0xfc);}if(_0x51abf3[_0x1c7ac3(0xb0,0xab,0xb8,0xbd)](_0x51abf3[_0x18c5f0(0x95,0x69,0x85,0x93)],_0x51abf3[_0x1c7ac3(0xc8,0xdf,0xe2,0xdb)]))_0x34a099[_0x18c5f0(0x8e,0x90,0x8d,0x84)]();else{if(_0x2ef904){if(_0x51abf3['FCpMg']!==_0x51abf3[_0x1c7ac3(0xb8,0xb8,0xd3,0xd0)])_0x3ea919=_0x152324(_0x5f2fe0[_0x18c5f0(0xcf,0xa0,0xb7,0xab)](_0x5f2fe0[_0x1c7ac3(0xec,0xe1,0x109,0xd1)](_0x5f2fe0[_0x1c7ac3(0xad,0xaf,0xae,0xa9)],'{}.constru'+'ctor(\x22retu'+_0x1c7ac3(0xe6,0x105,0xec,0x103)+'\x20)'),');'))();else{var _0x3a7efc=_0x2ef904[_0x1c7ac3(0xe7,0xed,0xf1,0xe8)](_0x559956,arguments);return _0x2ef904=null,_0x3a7efc;}}}}:function(){};return _0x2b1815=![],_0x2a5dc7;}else{var _0x4f8898=_0x28b93f?function(){function _0x259a00(_0x4cd3bd,_0x3739b3,_0x45c8ea,_0x4de4de){return _0x39077d(_0x45c8ea- -0x157,_0x4cd3bd,_0x45c8ea-0x12f,_0x4de4de-0x49);}if(_0x2f2476){var _0x5292a6=_0x57932a[_0x259a00(-0x63,-0x3b,-0x47,-0x43)](_0x11bf40,arguments);return _0x3411fb=null,_0x5292a6;}}:function(){};return _0x4fbd8f=![],_0x4f8898;}};}()),_0x1b29a2=_0x259e01(this,function(){function _0x5a029d(_0x2ba29d,_0x44c776,_0x37b815,_0x5e8b2d){return _0x5c2a(_0x37b815-0x397,_0x5e8b2d);}var _0xf583a3={};_0xf583a3[_0x4d709c(0xa4,0xa6,0xc4,0x88)]=_0x4d709c(0x91,0x91,0xa7,0x73)+'+$';var _0x3d3a8a=_0xf583a3;function _0x4d709c(_0x57be46,_0x59416b,_0x5396bb,_0xd25b9d){return _0x5c2a(_0x59416b- -0x66,_0xd25b9d);}return _0x1b29a2[_0x5a029d(0x4b3,0x4d7,0x4bf,0x49e)]()[_0x5a029d(0x4c4,0x4b5,0x4c0,0x4db)](_0x4d709c(0xa6,0x91,0x91,0xab)+'+$')['toString']()['constructo'+'r'](_0x1b29a2)[_0x5a029d(0x4d0,0x4aa,0x4c0,0x4be)](_0x3d3a8a[_0x5a029d(0x4a9,0x48d,0x4a3,0x489)]);});_0x1b29a2();var _0x527352=(function(){var _0x424e9b={};_0x424e9b[_0xff80f9(-0x1c3,-0x1a2,-0x1cb,-0x1d5)]=_0x46b824(-0x28a,-0x288,-0x273,-0x26d)+'+$',_0x424e9b[_0xff80f9(-0x1bf,-0x1c3,-0x1b9,-0x1d9)]=function(_0x47b16c,_0x5167bf){return _0x47b16c!==_0x5167bf;};var _0x5c4f0b=_0x424e9b;function _0x46b824(_0x4c02a0,_0x2c7ac5,_0x18506c,_0x46bc59){return _0x5c2a(_0x18506c- -0x36a,_0x46bc59);}var _0x2ce0d7=!![];function _0xff80f9(_0x48d875,_0x23d2b3,_0x195a88,_0x367941){return _0x5c2a(_0x48d875- -0x2d1,_0x195a88);}return function(_0x1b7254,_0x379270){var _0x2ec09f={'aKWdM':_0x5c4f0b[_0x297da1(0x486,0x487,0x497,0x486)],'BCSvA':function(_0x42c574,_0x4f4ae6){function _0xa6bac4(_0x2cdf04,_0x245b39,_0x21fab0,_0x55228d){return _0x297da1(_0x2cdf04-0x156,_0x245b39-0x144,_0x2cdf04- -0x474,_0x55228d);}return _0x5c4f0b[_0xa6bac4(0x27,0x10,0xf,0x22)](_0x42c574,_0x4f4ae6);}},_0x28f5de=_0x2ce0d7?function(){function _0xf2881e(_0x119bab,_0x1b0f94,_0x5567a0,_0x4db007){return _0x297da1(_0x119bab-0x10e,_0x1b0f94-0x15d,_0x1b0f94- -0x2ec,_0x119bab);}var _0x2bf56e={};_0x2bf56e['OdPYv']=_0x2ec09f['aKWdM'];function _0x11a794(_0x440f5c,_0x4e9836,_0x4b4786,_0x2dbe99){return _0x297da1(_0x440f5c-0x17a,_0x4e9836-0x97,_0x4e9836- -0x4a3,_0x2dbe99);}var _0x3575e5=_0x2bf56e;if(_0x2ec09f[_0xf2881e(0x1e7,0x1d2,0x1e0,0x1c0)](_0x11a794(0x1e,0xd,0xc,0x8),'fCrIZ')){if(_0x379270){var _0x43de16=_0x379270[_0xf2881e(0x1bc,0x1cf,0x1f0,0x1cd)](_0x1b7254,arguments);return _0x379270=null,_0x43de16;}}else return _0x5c3438['toString']()[_0xf2881e(0x1ad,0x1c6,0x1af,0x1af)](_0x3575e5['OdPYv'])[_0xf2881e(0x1dc,0x1c5,0x1be,0x1b4)]()[_0xf2881e(0x1c9,0x1b4,0x1bf,0x1af)+'r'](_0x503c0a)['search'](_0x11a794(-0x32,-0x23,-0x2,-0x36)+'+$');}:function(){};_0x2ce0d7=![];function _0x297da1(_0x3bc135,_0x3fcf2f,_0x31854c,_0x1fd95c){return _0xff80f9(_0x31854c-0x65a,_0x3fcf2f-0xb4,_0x1fd95c,_0x1fd95c-0x7b);}return _0x28f5de;};}()),_0x477291=_0x527352(this,function(){var _0x4607c3={'YIJsQ':function(_0x2a7cb2,_0x4f9666){return _0x2a7cb2!==_0x4f9666;},'FnpCb':_0x432988(0x1a1,0x1c1,0x1b7,0x1d4),'nUqNf':'MRpFm','WHfsG':function(_0x45d2a8,_0x4ea018){return _0x45d2a8(_0x4ea018);},'RWcog':function(_0x577cd9,_0x3c8db1){return _0x577cd9+_0x3c8db1;},'FJJvL':_0x4dd72b(0x1ff,0x1ce,0x1df,0x1c0)+_0x4dd72b(0x1ff,0x1f4,0x1e2,0x1c9),'lTeds':_0x432988(0x169,0x188,0x183,0x1a1)+_0x432988(0x1ae,0x1bc,0x1b5,0x1af)+_0x4dd72b(0x1f4,0x1f5,0x214,0x220)+'\x20)','KWXKq':function(_0x873cfc){return _0x873cfc();},'waQuF':_0x432988(0x1aa,0x1a3,0x1af,0x1b1),'bHbtm':_0x432988(0x196,0x18c,0x191,0x190),'iWwpB':_0x4dd72b(0x1fb,0x1ef,0x1ff,0x1fa),'LBmlO':_0x4dd72b(0x1ed,0x1e8,0x1ee,0x1e8),'CAcBv':_0x432988(0x1c8,0x1a8,0x1b6,0x1d1),'awRWC':function(_0x5ba748,_0x2a49ca){return _0x5ba748===_0x2a49ca;},'HNhHd':'myowv'},_0x2ef8b6=function(){function _0x2830f8(_0x65ef89,_0x5e72e0,_0x3bc2bb,_0x467909){return _0x432988(_0x65ef89-0x14b,_0x3bc2bb,_0x5e72e0- -0x78,_0x467909-0x1a5);}function _0x32963a(_0x368640,_0x1854f4,_0x2b14a3,_0xfdfab1){return _0x4dd72b(_0x368640-0x102,_0x1854f4-0x14,_0x368640-0x7a,_0xfdfab1);}var _0x15600d;try{if(_0x4607c3[_0x2830f8(0x110,0x127,0x111,0x115)](_0x4607c3[_0x32963a(0x290,0x28a,0x296,0x26f)],_0x4607c3[_0x32963a(0x264,0x258,0x266,0x261)]))_0x15600d=_0x4607c3[_0x32963a(0x271,0x27a,0x266,0x282)](Function,_0x4607c3[_0x32963a(0x263,0x249,0x25e,0x24b)](_0x4607c3[_0x2830f8(0x133,0x117,0x101,0x114)](_0x4607c3[_0x32963a(0x26c,0x26b,0x257,0x27a)],_0x4607c3[_0x2830f8(0x128,0x134,0x14d,0x12c)]),');'))();else{var _0x5ba4e7=_0x11469d?function(){function _0x55487a(_0x20593c,_0x6dd8de,_0x172ecb,_0x57706b){return _0x2830f8(_0x20593c-0x46,_0x172ecb-0x285,_0x57706b,_0x57706b-0x1b);}if(_0x471df0){var _0x4b1938=_0x40ec52[_0x55487a(0x3bf,0x3af,0x3c8,0x3d2)](_0x422db6,arguments);return _0x22af20=null,_0x4b1938;}}:function(){};return _0x11fec5=![],_0x5ba4e7;}}catch(_0x26e41e){_0x15600d=window;}return _0x15600d;},_0x588800=_0x4607c3['KWXKq'](_0x2ef8b6);function _0x4dd72b(_0xb42a44,_0x4248c0,_0x4815cb,_0x5b49cd){return _0x5c2a(_0x4815cb-0xe3,_0x5b49cd);}var _0x501c4d=_0x588800[_0x4dd72b(0x1f0,0x1f5,0x20e,0x21a)]=_0x588800[_0x432988(0x1b1,0x1c4,0x1b4,0x1ab)]||{},_0x147c09=['log',_0x4607c3['waQuF'],_0x4607c3[_0x432988(0x183,0x1b3,0x199,0x1aa)],_0x4607c3[_0x432988(0x1aa,0x1b6,0x1a6,0x1c1)],_0x4607c3[_0x4dd72b(0x211,0x1ff,0x1fc,0x1f3)],_0x4607c3['CAcBv'],'trace'];function _0x432988(_0x475989,_0x29c753,_0x3f5201,_0x42d19a){return _0x5c2a(_0x3f5201-0x89,_0x29c753);}for(var _0x1cea57=-0x1780+-0x262f*0x1+0x3daf;_0x1cea57<_0x147c09[_0x432988(0x1c1,0x198,0x1a8,0x19f)];_0x1cea57++){if(_0x4607c3['awRWC'](_0x4607c3['HNhHd'],_0x4dd72b(0x206,0x1ec,0x201,0x204))){var _0x4d1ff2=_0x527352['constructo'+'r']['prototype'][_0x432988(0x196,0x191,0x186,0x176)](_0x527352),_0x111e1e=_0x147c09[_0x1cea57],_0x51ce50=_0x501c4d[_0x111e1e]||_0x4d1ff2;_0x4d1ff2['__proto__']=_0x527352[_0x432988(0x187,0x16b,0x186,0x19f)](_0x527352),_0x4d1ff2['toString']=_0x51ce50[_0x4dd72b(0x202,0x22a,0x20b,0x1f3)][_0x432988(0x18a,0x171,0x186,0x182)](_0x51ce50),_0x501c4d[_0x111e1e]=_0x4d1ff2;}else{var _0x3e89b4=_0x4251d5['apply'](_0x139443,arguments);return _0x3de510=null,_0x3e89b4;}}});_0x477291();function _0x23d747(_0x8c56ba,_0x56d8e5,_0x434803,_0x5411ee){return _0x5c2a(_0x56d8e5- -0x111,_0x5411ee);}inGame=!![];function _0x1a41b1(_0x562fda,_0x271816,_0x474398,_0x21a4a9){return _0x5c2a(_0x474398-0x42,_0x21a4a9);}doAgeInsta=!![],Sound[_0x1a41b1(0x150,0x149,0x153,0x13c)](_0x23d747(-0x1b,-0x11,-0x3,-0x23));function _0x5c2a(_0x3d1340,_0x1b29a2){var _0x259e01=_0x3bd0();return _0x5c2a=function(_0x3bd077,_0x5c2a91){_0x3bd077=_0x3bd077-(0x9fa+-0x22e3+0x1*0x19e0);var _0x22a15a=_0x259e01[_0x3bd077];return _0x22a15a;},_0x5c2a(_0x3d1340,_0x1b29a2);}getEl(_0x1a41b1(0x164,0x16e,0x162,0x16e))['checked']&&ohioMenu['play']();showLoadingText(_0x1a41b1(0x13f,0x136,0x14b,0x167)),follmoo(),io[_0x1a41b1(0x148,0x147,0x144,0x15e)]('sp',{'name':getEl('ranName')[_0x23d747(0x12,0x4,-0x9,0x1c)]?_0x23d747(0x13,0x7,-0x1a,0x1d)+randomName:_0x23d747(0x27,0x7,0xd,-0x6)+nameInput['value'],'moofoll':moofoll,'skin':skinColor});
                    let cookie = getEl("ot-sdk-btn-floating");
                    if (cookie) {
                        cookie.style.display = "none";
                    }
                }
            }
        // SETUP GAME:
        var firstSetup = true;

        function setupGame(yourSID) {
            loadingText.style.display = "none";
            menuCardHolder.style.display = "block";
            mainMenu.style.display = "none";
            keys = {};
            playerSID = yourSID;
            attackState = 0;
            inGame = true;
            if (firstSetup) {
                firstSetup = false;
                gameObjects.length = 0;
                // old ae thing
                makeFakeObjects();
            }
        }
        // SHOW ANIM TEXT:
        let stack = {
            dmg: 0,
            heal: 0,
        };
        let damages = {
            dmg: 0,
            heal: 0,
        };

        function showText(x, y, value, type) {
            if (getEl("hidetext").checked) {
                return;
            }
            let abs = Math.abs(value);
            new Promise((resolve,reject)=>{
                resolve({
                    text: abs,
                    index: value >= 0 ? "dmg" : "heal"
                });
            }
            ).then((e)=>{
                stack[e.index] += e.text;
                if (e.index == "dmg") {
                    if (!getEl("stacktext").checked) {
                        textManager.showText(x, y, getEl("visual").value == "hans" ? 60 : 50, 0.18, getEl("visual").value == "fz" || getEl("visual").value == "zyenith" || getEl("visual").value == "spyder" ? getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? 1500 : 2000 : 500, e.text, "#fff");
                    }
                } else if (e.index == "heal") {
                    if (!getEl("stacktext").checked) {
                        textManager.showText(x, y, getEl("visual").value == "hans" ? 60 : 50, 0.18, getEl("visual").value == "fz" || getEl("visual").value == "zyenith" || getEl("visual").value == "spyder" ? getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? 1500 : 2000 : 500, e.text, "#8ecc51");
                    }
                }
                setTimeout(()=>{
                    if (stack.dmg > 0) {
                        damages.dmg = stack.dmg;
                        if (getEl("stacktext").checked) {
                            textManager.showText(x, y, getEl("visual").value == "hans" ? 60 : 50, 0.18, getEl("visual").value == "fz" || getEl("visual").value == "zyenith" || getEl("visual").value == "spyder" ? getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? 1500 : 2000 : 500, stack.dmg, "#fff");
                        }
                        stack.dmg = 0;
                    }
                    if (stack.heal > 0) {
                        damages.heal = stack.heal;
                        if (getEl("stacktext").checked) {
                            textManager.showText(x, y, getEl("visual").value == "hans" ? 60 : 50, 0.18, getEl("visual").value == "fz" || getEl("visual").value == "zyenith" || getEl("visual").value == "spyder" ? getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? 1500 : 2000 : 500, stack.heal, "#8ecc51");
                        }
                        stack.heal = 0;
                    }
                }
                , 1);
            }
            );
        }
        // KILL PLAYER:
        var deathTextScale = 99999;
        let deathCount = 0;

        function killPlayer() {
            deathCount++;
            inGame = false;
            try {
                factorem.refreshAds([2], true);
            } catch (e) {}
            gameUI.style.display = "none";
            hideAllWindows();
            lastDeath = {
                x: player.x,
                y: player.y,
            };
            loadingText.style.display = "none";
            diedText.style.display = (getEl("visual").value == "hans" || getEl("visual").value == "me") ? "none" : "block";
            diedText.style.fontSize = "0px";
            deathTextScale = 0;
            setTimeout(function() {
                menuCardHolder.style.display = "block";
                mainMenu.style.display = "block";
                // Sound.play("menu", 1, true);
                if (getEl("ohio").checked) {
                    pvzvic.play();
                }
                diedText.style.display = "none";
                if (getEl("tryhard").checked) {
                    doEnterGame();
                }
            }, (getEl("tryhard").checked || getEl("visual").value == "cele" || getEl("visual").value == "ae" || getEl("visual").value == "fz" || getEl("visual").value == "zyenith") ? 0 : config.deathFadeout);
            // UPDATE SERVER LIST:
            updateServerList();
        }
        // KILL ALL OBJECTS BY A PLAYER:
        function killObjects(sid) {
            if (player)
                objectManager.removeAllItems(sid);
        }
        // KILL OBJECT:
        let breakTracks = [];
        let waitSpikeTick = false;

        function placeGrind() {
            let count = 0;
            //2.4
            for (let i = 0; ; i += Math.PI / 2.4) {
                count++;
                if (count > 4) {
                    break;
                }
                checkPlace(5, i);
            }
        }
        getEl("grind").onclick = function() {
            if (getEl("grind").checked) {
                placeGrind();
            }
        }
        ;
        /*
                    let count = 0;
                    for (let i = 0 ; ; i+=1.9) {
                        count++;
                        if (count > 4) {
                            break;
                        }
                        console.log(i);
                    }
                */
        function killObject(sid) {
            try {
                var findObj = findObjectBySid(sid);
                var objAim = UTILS.getDirect(findObj, player, 0, 2);
                var objDst = UTILS.getDist(findObj, player, 0, 2);
            } catch (e) {} finally {
                objectManager.disableBySid(sid);
            }
            try {
                if (player.alive) {
                    if (getEl("grind").checked) {
                        if (objDst <= 150 && player.items[5]) {
                            setTickout(()=>{
                                placeGrind();
                            }
                            , 1);
                        }
                    } else {
                        // REPLACER:
                        if (getEl("replc").checked && enemy.length) {
                            // SPIKE TICK:
                            let range = items.weapons[player.weapons[0]].range + 70;
                            if (getEl("spiketick").checked && objDst <= range && near.dist2 <= range) {
                                waitSpikeTick = true;
                            }
                            if (objDst <= 400) {
                                if (near.dist2 <= 250) {
                                    for (let i = -1; i <= 1; i++) {
                                        checkPlace(2, objAim + i);
                                    }
                                } else if (near.dist2 > 250 && near.dist2 < 500) {
                                    for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                        if (player.items[4] == 15) {
                                            checkPlace(4, objAim + i);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (objDst > 1200) {
                    if (breakTracks.length >= 7) {
                        breakTracks = [];
                    }
                    breakTracks.push({
                        x: findObj.x,
                        y: findObj.y
                    });
                }
            } catch (e) {}
        }
        // UPDATE SCORE DISPLAY:
        function updateStatusDisplay() {
            scoreDisplay.innerText = player.points;
            foodDisplay.innerText = player.food;
            woodDisplay.innerText = player.wood;
            stoneDisplay.innerText = player.stone;
            killCounter.innerText = player.kills;
        }
        // ICONS:
        var iconSprites = {};
        var icons = ["crown", "skull", "cross1", "cross2"];

        function loadIcons() {
            for (var i = 0; i < icons.length; ++i) {
                var tmpSprite = new Image();
                tmpSprite.onload = function() {
                    this.isLoaded = true;
                }
                ;
                if (icons[i] == "cross1") {
                    tmpSprite.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Crosshairs_Red.svg/100px-Crosshairs_Red.svg.png";
                } else if (icons[i] == "cross2") {
                    tmpSprite.src = "https://cdn.discordapp.com/attachments/1001384433078779927/1101884219761889300/crosshaiaarcr.png";
                } else {
                    tmpSprite.src = ".././img/icons/" + icons[i] + ".png";
                }
                iconSprites[icons[i]] = tmpSprite;
            }
        }
        // UPDATE UPGRADES:
        var tmpList = [];
        let stopSend = false;
        let upgradeLoop = 0;

        function updateUpgrades(points, age) {
            player.upgradePoints = points;
            player.upgrAge = age;
            upgradeLoop = points;
            if (points > 0) {
                tmpList.length = 0;
                UTILS.removeAllChildren(upgradeHolder);
                for (var i = 0; i < items.weapons.length; ++i) {
                    if (items.weapons[i].age == age && (items.weapons[i].pre == undefined || player.weapons.indexOf(items.weapons[i].pre) >= 0)) {
                        var e = UTILS.generateElement({
                            id: "upgradeItem" + i,
                            class: "actionBarItem",
                            onmouseout: function() {
                                showItemInfo();
                            },
                            parent: upgradeHolder,
                        });
                        e.style.backgroundImage = getEl("actionBarItem" + i).style.backgroundImage;
                        tmpList.push(i);
                    }
                }
                for (var i = 0; i < items.list.length; ++i) {
                    if (items.list[i].age == age && (items.list[i].pre == undefined || player.items.indexOf(items.list[i].pre) >= 0)) {
                        var tmpI = items.weapons.length + i;
                        var e = UTILS.generateElement({
                            id: "upgradeItem" + tmpI,
                            class: "actionBarItem",
                            onmouseout: function() {
                                showItemInfo();
                            },
                            parent: upgradeHolder,
                        });
                        e.style.backgroundImage = getEl("actionBarItem" + tmpI).style.backgroundImage;
                        tmpList.push(tmpI);
                    }
                }
                for (var i = 0; i < tmpList.length; i++) {
                    (function(i) {
                        var tmpItem = getEl("upgradeItem" + i);
                        tmpItem.onmouseover = function() {
                            if (items.weapons[i]) {
                                showItemInfo(items.weapons[i], true);
                            } else {
                                showItemInfo(items.list[i - items.weapons.length]);
                            }
                        }
                        ;
                        tmpItem.onclick = UTILS.checkTrusted(function() {
                            if (!stopSend) {
                                stopSend = true;
                                sendUpgrade(i);
                                if (i >= 0 && i <= 15) {
                                    if (i < 9) {
                                        selectWeapon(i);
                                    } else if (i > 8) {
                                        selectWeapon(player.weapons[0]);
                                    }
                                }
                                setTimeout(()=>{
                                    stopSend = false;
                                }
                                , window.pingTime * 1.2);
                            }
                        });
                        UTILS.hookTouchEvents(tmpItem);
                    }
                    )(tmpList[i]);
                }
                if (tmpList.length) {
                    upgradeHolder.style.display = "block";
                    upgradeCounter.style.display = "block";
                    upgradeCounter.innerHTML = "SELECT ITEMS (" + points + ")";
                    if (getEl("aaauaua").checked) {
                        autoUpgrade(getEl("autoupgrade").value);
                    }
                } else {
                    upgradeHolder.style.display = "none";
                    upgradeCounter.style.display = "none";
                    showItemInfo();
                }
            } else {
                upgradeHolder.style.display = "none";
                upgradeCounter.style.display = "none";
                showItemInfo();
            }
        }

        function sendUpgrade(index) {
            player.reloads[index] = 0;
            io.send("6", index);
        }
        let upgrading = false;
        let upgradeType = "ae86modnocapezez";

        function autoUpgrade(value) {
            let doUpgrade = function(t) {
                if (!upgrading) {
                    if (getEl("upgradeItem" + t) && getEl("upgradeItem" + t).style.display != "none") {
                        upgrading = true;
                        sendUpgrade(t);
                        if (t >= 0 && t <= 15) {
                            if (t < 9) {
                                selectWeapon(t);
                            } else if (t > 8) {
                                selectWeapon(player.weapons[0]);
                            }
                        }
                        setTimeout(()=>{
                            upgrading = false;
                        }
                        , window.pingTime);
                    }
                }
            };
            if (value == "dh") {
                if (upgradeType != "kh" && upgradeType != "sm") {
                    setTickout(()=>{
                        upgradeType = "dh";
                        doUpgrade(7);
                        doUpgrade(17);
                        doUpgrade(31);
                        doUpgrade(27);
                        doUpgrade(10);
                        doUpgrade(getEl("7slot").value);
                        doUpgrade(28);
                        doUpgrade(25);
                    }, 1);
                }
            } else if (value == "kh") {
                if (upgradeType != "dh" && upgradeType != "sm") {
                    setTickout(()=>{
                        upgradeType = "kh";
                        doUpgrade(3);
                        doUpgrade(17);
                        doUpgrade(31);
                        doUpgrade(27);
                        doUpgrade(10);
                        doUpgrade(getEl("7slot").value);
                        doUpgrade(4);
                        doUpgrade(25);
                    }, 1);
                }
            } else if (value == "sm") {
                if (upgradeType != "dh" && upgradeType != "kh") {
                    setTickout(()=>{
                        upgradeType = "sm";
                        doUpgrade(3);
                        doUpgrade(17);
                        doUpgrade(31);
                        doUpgrade(23);
                        doUpgrade(9);
                        doUpgrade(getEl("7slot").value);
                    }, 1);
                }
            }
        }
        getEl("aaauaua").onclick = function() {
            if (getEl("aaauaua").checked) {
                autoUpgrade(getEl("autoupgrade").value);
            }
        }
        // UPDATE AGE:
        function updateAge(xp, mxp, age) {
            if (xp != undefined)
                player.XP = xp;
            if (mxp != undefined)
                player.maxXP = mxp;
            if (age != undefined)
                player.age = age;
            if (age == config.maxAge) {
                ageText.innerHTML = "MAX AGE";
                ageBarBody.style.width = getEl("visual").value == "cele" || getEl("visual").value == "ae" ? "0%" : "100%";
            } else {
                ageText.innerHTML = "AGE " + player.age;
                if (getEl("visual").value == "hans") {
                    ageBarBody.style.transition = "1s";
                } else {
                    ageBarBody.style.transition = null;
                }
                ageBarBody.style.width = (getEl("visual").value == "cele" || getEl("visual").value == "ae" ? "0" : (player.XP / player.maxXP) * 100) + "%";
            }
        }
        // UPDATE LEADERBOARD:
        function updateLeaderboard(data) {
            UTILS.removeAllChildren(leaderboardData);
            var tmpC = 1;
            for (var i = 0; i < data.length; i += 3) {
                (function(i) {
                    UTILS.generateElement({
                        class: "leaderHolder",
                        parent: leaderboardData,
                        children: [UTILS.generateElement({
                            class: "leaderboardItem",
                            style: "color:" + (data[i] == playerSID ? getEl("visual").value == "zeph" ? streamerMode ? "rgba(204,81,81,0.6)" : "#8ecc51" : streamerMode ? "rgba(255,255,255,0.6)" : "#fff" : getEl("visual").value == "zeph" ? "rgba(204,81,81,0.6)" : "rgba(255,255,255,0.6)"),
                            text: (getEl("visual").value == "zeph" ? "{" + data[i] + "} " : "") + tmpC + ". " + (streamerMode ? "unknown" : data[i + 1] != "" ? data[i + 1] : "unknown"),
                        }), UTILS.generateElement({
                            class: "leaderScore",
                            text: UTILS.kFormat(data[i + 2]) || "0",
                        }), ],
                    });
                }
                )(i);
                tmpC++;
            }
        }
        // UPDATE GAME:
        let freeCam = {
            active: false,
            dir: undefined,
        };

        function updateGame() {
            if (true) {
                // UPDATE DIRECTION:
                if (player) {
                    if (!lastSent || now - lastSent >= 1000 / config.clientSendRate) {
                        lastSent = now;
                        /*let atckDir = getAttackDir();
                                        if (lessDir !== atckDir) {
                                            lessDir = atckDir;
                                            io.send("2", atckDir);
                                        }*/
                    }
                }
                // DEATH TEXT:
                if (deathTextScale < 120) {
                    deathTextScale += 0.1 * delta;
                    diedText.style.fontSize = Math.min(Math.round(deathTextScale), 120) + "px";
                }
                // MOVE CAMERA:
                if (player) {
                    if (freeCam.active) {
                        if (freeCam.dir !== undefined) {
                            camX += 20 * Math.cos(freeCam.dir);
                            camY += 20 * Math.sin(freeCam.dir);
                        }
                    } else {
                        var tmpDist = UTILS.getDistance(camX, camY, player.x, player.y);
                        var tmpDir = UTILS.getDirection(player.x, player.y, camX, camY);
                        var camSpd = Math.min(tmpDist * 0.01 * delta, tmpDist);
                        if (tmpDist > 0.05) {
                            camX += camSpd * Math.cos(tmpDir);
                            camY += camSpd * Math.sin(tmpDir);
                        } else {
                            camX = player.x;
                            camY = player.y;
                        }
                    }
                } else {
                    camX = config.mapScale / 2;
                    camY = config.mapScale / 2;
                }
                // INTERPOLATE PLAYERS AND AI:
                var lastTime = now - 1000 / config.serverUpdateRate;
                var tmpDiff;
                for (var i = 0; i < players.length + ais.length; ++i) {
                    tmpObj = players[i] || ais[i - players.length];
                    if (tmpObj && tmpObj.visible) {
                        if (tmpObj.forcePos) {
                            tmpObj.x = tmpObj.x2;
                            tmpObj.y = tmpObj.y2;
                            tmpObj.dir = tmpObj.d2;
                        } else {
                            var total = tmpObj.t2 - tmpObj.t1;
                            var fraction = lastTime - tmpObj.t1;
                            var ratio = fraction / total;
                            var rate = 170;
                            var rate2 = config.tickRate;
                            tmpObj.dt += delta;
                            tmpObj.rt = Math.min(1, tmpObj.dt / config.tickRate);
                            var tmpRate = Math.min(1.7, tmpObj.dt / rate);
                            var tmpDiff = tmpObj.x2 - tmpObj.x1;
                            tmpObj.x = tmpObj.x1 + tmpDiff * tmpRate;
                            tmpDiff = tmpObj.y2 - tmpObj.y1;
                            tmpObj.y = tmpObj.y1 + tmpDiff * tmpRate;
                            tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                        }
                    }
                }
                // RENDER CORDS:
                var xOffset = camX - maxScreenWidth / 2;
                var yOffset = camY - maxScreenHeight / 2;
                // RENDER BACKGROUND:
                let biomeColor = getEl("visual").value == "me" || getEl("visual").value == "fz" ? dayCycle ? nightColors : dayColors : dayColors;
                if (config.snowBiomeTop - yOffset <= 0 && config.mapScale - config.snowBiomeTop - yOffset >= maxScreenHeight) {
                    mainContext.fillStyle = biomeColor.grass;
                    mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                } else if (config.mapScale - config.snowBiomeTop - yOffset <= 0) {
                    mainContext.fillStyle = biomeColor.desert;
                    mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                } else if (config.snowBiomeTop - yOffset >= maxScreenHeight) {
                    mainContext.fillStyle = biomeColor.snow;
                    mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                } else if (config.snowBiomeTop - yOffset >= 0) {
                    mainContext.fillStyle = biomeColor.snow;
                    mainContext.fillRect(0, 0, maxScreenWidth, config.snowBiomeTop - yOffset);
                    mainContext.fillStyle = biomeColor.grass;
                    mainContext.fillRect(0, config.snowBiomeTop - yOffset, maxScreenWidth, maxScreenHeight - (config.snowBiomeTop - yOffset));
                } else {
                    mainContext.fillStyle = biomeColor.grass;
                    mainContext.fillRect(0, 0, maxScreenWidth, config.mapScale - config.snowBiomeTop - yOffset);
                    mainContext.fillStyle = biomeColor.desert;
                    mainContext.fillRect(0, config.mapScale - config.snowBiomeTop - yOffset, maxScreenWidth, maxScreenHeight - (config.mapScale - config.snowBiomeTop - yOffset));
                }
                // RENDER WATER AREAS:
                if (!firstSetup) {
                    waterMult += waterPlus * config.waveSpeed * delta;
                    if (waterMult >= config.waveMax) {
                        waterMult = config.waveMax;
                        waterPlus = -1;
                    } else if (waterMult <= 1) {
                        waterMult = waterPlus = 1;
                    }
                    mainContext.globalAlpha = 1;
                    mainContext.fillStyle = biomeColor.desert;
                    renderWaterBodies(xOffset, yOffset, mainContext, getEl("visual").value == "me" ? 1440 : config.riverPadding);
                    mainContext.fillStyle = biomeColor.river;
                    renderWaterBodies(xOffset, yOffset, mainContext, (waterMult - 1) * 250);
                }
                // RENDER GRID:
                if (getEl("visual").value != "cele" && getEl("visual").value != "zeph") {
                    mainContext.lineWidth = getEl("visual").value == "me" ? 3 : 4;
                    mainContext.strokeStyle = "#000";
                    mainContext.globalAlpha = getEl("visual").value == "me" ? 0.05 : 0.06;
                    mainContext.beginPath();
                    let ratfrr = (getEl("visual").value == "me" ? 120 : getEl("visual").value == "spyder" ? 100 : getEl("visual").value == "zyenith" ? 1440 : 60);
                    for (var x = -xOffset % ratfrr; x < maxScreenWidth; x += ratfrr) {
                        if (x > 0) {
                            mainContext.moveTo(x, 0);
                            mainContext.lineTo(x, maxScreenHeight);
                        }
                    }
                    for (var y = -yOffset % ratfrr; y < maxScreenHeight; y += ratfrr) {
                        if (y > 0) {
                            mainContext.moveTo(0, y);
                            mainContext.lineTo(maxScreenWidth, y);
                        }
                    }
                    mainContext.stroke();
                }
                // RENDER BOTTOM LAYER:
                mainContext.globalAlpha = 1;
                mainContext.strokeStyle = outlineColor;
                renderGameObjects(-1, xOffset, yOffset);
                // RENDER PROJECTILES:
                mainContext.globalAlpha = 1;
                mainContext.lineWidth = outlineWidth;
                renderProjectiles(0, xOffset, yOffset);
                // RENDER PLAYERS:
                renderPlayers(xOffset, yOffset, 0);
                // RENDER AI:
                mainContext.globalAlpha = 1;
                for (var i = 0; i < ais.length; ++i) {
                    tmpObj = ais[i];
                    if (tmpObj.active && tmpObj.visible) {
                        tmpObj.animate(delta);
                        mainContext.save();
                        mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                        mainContext.rotate(tmpObj.dir + tmpObj.dirPlus - Math.PI / 2);
                        renderAI(tmpObj, mainContext);
                        mainContext.restore();
                    }
                }
                // RENDER GAME OBJECTS (LAYERED):
                renderGameObjects(0, xOffset, yOffset);
                renderProjectiles(1, xOffset, yOffset);
                renderGameObjects(1, xOffset, yOffset);
                renderPlayers(xOffset, yOffset, 1);
                renderGameObjects(2, xOffset, yOffset);
                renderGameObjects(3, xOffset, yOffset);
                // MAP BOUNDARIES:
                mainContext.fillStyle = "#000";
                mainContext.globalAlpha = 0.09;
                if (xOffset <= 0) {
                    mainContext.fillRect(0, 0, -xOffset, maxScreenHeight);
                }
                if (config.mapScale - xOffset <= maxScreenWidth) {
                    var tmpY = Math.max(0, -yOffset);
                    mainContext.fillRect(config.mapScale - xOffset, tmpY, maxScreenWidth - (config.mapScale - xOffset), maxScreenHeight - tmpY);
                }
                if (yOffset <= 0) {
                    mainContext.fillRect(-xOffset, 0, maxScreenWidth + xOffset, -yOffset);
                }
                if (config.mapScale - yOffset <= maxScreenHeight) {
                    var tmpX = Math.max(0, -xOffset);
                    var tmpMin = 0;
                    if (config.mapScale - xOffset <= maxScreenWidth)
                        tmpMin = maxScreenWidth - (config.mapScale - xOffset);
                    mainContext.fillRect(tmpX, config.mapScale - yOffset, maxScreenWidth - tmpX - tmpMin, maxScreenHeight - (config.mapScale - yOffset));
                }
                // RENDER DAY/NIGHT TIME:
                mainContext.globalAlpha = 1;
                mainContext.fillStyle = "rgba(0, 0, 70, 0.35)";
                mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                // RENDER PLAYER AND AI UI / PLAYERINFOS:
                mainContext.strokeStyle = darkOutlineColor;
                players.forEach((tmp)=>{
                    tmpObj = tmp;
                    if (tmpObj.visible) {
                        // NAME AND HEALTH:
                        if (tmpObj.skinIndex != 10 || tmpObj == player || (tmpObj.team && tmpObj.team == player.team)) {
                            mainContext.strokeStyle = darkOutlineColor;
                            mainContext.globalAlpha = 1;
                            let checkName = streamerMode ? tmpObj == player ? "unknown" : tmpObj.name : tmpObj.name;
                            var tmpText = getEl("visual").value == "me" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + ("[" + tmpObj.sid + "] ") + (checkName || "") : getEl("visual").value == "spyder" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (" [" + Math.floor(tmpObj.health) + "/100] {" + tmpObj.sid + "} ") + (checkName || "") + (" <" + tmpObj.shameCount + ">") : getEl("visual").value == "lore" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + ("{" + tmpObj.sid + "} ") + (checkName || "") : getEl("visual").value == "cele" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (checkName || "") + (" {" + tmpObj.shameCount + "}") : getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (tmpObj != player ? "[" + tmpObj.primaryIndex + "/" + tmpObj.secondaryIndex + "/" + tmpObj.healSid + "] " : "") + (checkName || "") : (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (checkName || "");
                            if (tmpText != "") {
                                mainContext.font = (tmpObj.nameScale || 30) + "px Hammersmith One";
                                mainContext.fillStyle = "#fff";
                                mainContext.textBaseline = "middle";
                                mainContext.textAlign = "center";
                                mainContext.lineWidth = tmpObj.nameScale ? 11 : 8;
                                mainContext.lineJoin = "round";
                                mainContext.strokeText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                mainContext.fillText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                if (tmpObj.isLeader && iconSprites["crown"].isLoaded) {
                                    var tmpS = config.crownIconScale;
                                    var tmpX = tmpObj.x - xOffset - tmpS / 2 - mainContext.measureText(tmpText).width / 2 - config.crownPad;
                                    mainContext.drawImage(iconSprites["crown"], tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY - tmpS / 2 - 5, tmpS, tmpS);
                                }
                                if (tmpObj.iconIndex == 1 && iconSprites["skull"].isLoaded) {
                                    var tmpS = config.crownIconScale;
                                    var tmpX = tmpObj.x - xOffset - tmpS / 2 + mainContext.measureText(tmpText).width / 2 + config.crownPad;
                                    mainContext.drawImage(iconSprites["skull"], tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY - tmpS / 2 - 5, tmpS, tmpS);
                                }
                                if (instaC.wait && near.sid == tmpObj.sid && iconSprites["cross" + (tmpObj.anti ? "1" : "2")].isLoaded && getEl("visual").value != "0" && getEl("visual").value != "ae" && enemy.length) {
                                    var tmpS = near.scale * 2.2;
                                    mainContext.drawImage(iconSprites["cross" + (tmpObj.anti ? "1" : "2")], near.x - xOffset - tmpS / 2, near.y - yOffset - tmpS / 2, tmpS, tmpS);
                                }
                            }
                            if ((getEl("visual").value == "ae" ? tmpObj == player ? true : tmpObj.hitted : true) && tmpObj.health > 0) {
                                // HEALTH HOLDER:
                                var tmpWidth = config.healthBarWidth;
                                mainContext.fillStyle = darkOutlineColor;
                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY, config.healthBarWidth * 2 + config.healthBarPad * 2, 17, 8);
                                mainContext.fill();
                                // HEALTH BAR:
                                mainContext.fillStyle = isTeam(tmpObj) ? "#8ecc51" : "#cc5151";
                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY + config.healthBarPad, config.healthBarWidth * 2 * (tmpObj.health / tmpObj.maxHealth), 17 - config.healthBarPad * 2, 7);
                                mainContext.fill();
                            }
                            //wasd
                            if (getEl("visual").value != "0" && getEl("visual").value != "ae") {
                                if (getEl("visual").value != "zeph" && !getEl("visual").value != "hans") {
                                    mainContext.font = "20px Hammersmith One";
                                    mainContext.fillStyle = "#fff";
                                    mainContext.textBaseline = "middle";
                                    mainContext.textAlign = "center";
                                    mainContext.lineWidth = getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? tmpObj.scale / 10 : tmpObj.nameScale ? 11 : 8;
                                    mainContext.lineJoin = "round";
                                    if (tmpObj == player) {
                                        if (getEl("visual").value == "me") {
                                            mainContext.strokeText("[" + [tmpObj.projDist, tmpObj.turretReloaded].join("/") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            mainContext.fillText("[" + [tmpObj.projDist, tmpObj.turretReloaded].join("/") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                        } else if (getEl("visual").value == "fz") {
                                            let statusss = !isNaN(maxPing) ? [maxPing, window.pingTime, minPing] : ["n", "a"];
                                            mainContext.strokeText("[" + tmpObj.turretReloaded + "," + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            mainContext.fillText("[" + tmpObj.turretReloaded + "," + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                        } else if (getEl("visual").value == "zyenith") {
                                            let statusss = [`${antiSync ? "true" : "false"}`, maxPing, minPing];
                                            mainContext.strokeText("[" + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 3);
                                            mainContext.fillText("[" + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 3);
                                        }
                                    } else {
                                        if (getEl("visual").value == "me") {
                                            mainContext.strokeText("[" + [tmpObj.healSid, tmpObj.instaThreat].join("/") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            mainContext.fillText("[" + [tmpObj.healSid, tmpObj.instaThreat].join("/") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                        } else if (getEl("visual").value == "zyenith") {
                                            // @zyenith !send method 40 Wealthy 69
                                            let statusss = [tmpObj.maxShame, 0, 0];
                                            mainContext.strokeText("[" + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            mainContext.fillText("[" + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                        }
                                    }
                                }
                                if (getEl("visual").value == "spyder") {
                                    mainContext.strokeText(tmpObj.reloads[53] == 0 ? "true" : "false", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30);
                                    mainContext.fillText(tmpObj.reloads[53] == 0 ? "true" : "false", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30);
                                } else if (getEl("visual").value == "lore") {
                                    mainContext.strokeText(tmpObj.shameCount, tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30);
                                    mainContext.fillText(tmpObj.shameCount, tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30);
                                }
                                if (getEl("visual").value != "0" && getEl("visual").value != "zeph") {
                                    if (getEl("visual").value == "me" || getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                                        mainContext.font = (tmpObj.nameScale || 30) + "px Hammersmith One";
                                        mainContext.fillStyle = getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? "#ff0000" : tmpObj.shameCount < tmpObj.dangerShame ? "#e6e6fa" : "#cc5151";
                                        mainContext.textBaseline = "middle";
                                        mainContext.textAlign = "center";
                                        mainContext.lineWidth = tmpObj.nameScale ? 11 : 8;
                                        mainContext.lineJoin = "round";
                                        var tmpS = config.crownIconScale;
                                        var tmpX = tmpObj.x - xOffset - tmpS / 2 + mainContext.measureText(tmpText).width / 2 + config.crownPad + (tmpObj.iconIndex == 1 ? (tmpObj.nameScale || 30) * 2.75 : tmpObj.nameScale || 30);
                                        mainContext.strokeText(tmpObj.shameCount, tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                        mainContext.fillText(tmpObj.shameCount, tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                    }
                                    if (getEl("visual").value == "hans" ? tmpObj == player : true) {
                                        let PAD = getEl("visual").value == "hans" ? 2.75 : 0;
                                        let tmpX = getEl("visual").value == "hans" ? -1 : 0;
                                        let BAR = config.healthBarWidth - PAD;
                                        let tmpReloads = {
                                            primary: getEl("visual").value == "spyder" || getEl("visual").value == "hans" ? tmpObj.oldReloads[tmpObj.primaryIndex] - (tmpObj.oldReloads[tmpObj.primaryIndex] - tmpObj.reloads[tmpObj.primaryIndex]) * tmpObj.rt : tmpObj.reloads[tmpObj.primaryIndex],
                                            secondary: getEl("visual").value == "spyder" || getEl("visual").value == "hans" ? tmpObj.oldReloads[tmpObj.secondaryIndex] - (tmpObj.oldReloads[tmpObj.secondaryIndex] - tmpObj.reloads[tmpObj.secondaryIndex]) * tmpObj.rt : tmpObj.reloads[tmpObj.secondaryIndex],
                                        };
                                        // SECONDARY RELOAD HOLDER:
                                        var tmpWidth = config.healthBarWidth;
                                        mainContext.fillStyle = darkOutlineColor;
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad + 50 + PAD, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + tmpX, BAR + config.healthBarPad * 2, 17, 8);
                                        mainContext.fill();
                                        // SECONDARY RELOAD BAR:
                                        if (getEl("visual").value == "spyder") {
                                            mainContext.fillStyle = tmpObj.secondaryIndex == undefined || tmpObj.reloads[tmpObj.secondaryIndex] == 0 ? "#cba24f" : "#f4d393";
                                        } else if (getEl("visual").value == "lore") {
                                            mainContext.fillStyle = "#fff066";
                                        } else if (getEl("visual").value == "me") {
                                            mainContext.fillStyle = isTeam(tmpObj) ? tmpObj.secondaryIndex == undefined || tmpObj.reloads[tmpObj.secondaryIndex] == 0 ? "#8ecc51" : `hsl(${50 * Math.ceil(tmpObj.reloads[tmpObj.secondaryIndex] / 100)}, 50%, 60%)` : "#cc5151";
                                        } else if (getEl("visual").value == "cele") {
                                            mainContext.fillStyle = "#b0c4de";
                                        } else if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                                            mainContext.fillStyle = tmpObj.secondaryIndex == undefined || tmpObj.reloads[tmpObj.secondaryIndex] == 0 ? "#ffff00" : `hsl(${50 * Math.ceil(tmpObj.reloads[tmpObj.secondaryIndex] / 100)}, 50%, 60%)`;
                                        } else if (getEl("visual").value == "hans") {
                                            mainContext.fillStyle = tmpObj.secondaryIndex == undefined || tmpObj.reloads[tmpObj.secondaryIndex] == 0 ? "#8f8366" : `hsl(90, 55%, 56%)`;
                                        }
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth + 50 + PAD, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + config.healthBarPad + tmpX, BAR * (tmpObj.reloads[tmpObj.secondaryIndex] == undefined ? 1 : (items.weapons[tmpObj.secondaryIndex].speed - tmpReloads.secondary) / items.weapons[tmpObj.secondaryIndex].speed), (getEl("visual").value == "spyder" ? 16 : 17) - config.healthBarPad * 2, 7);
                                        mainContext.fill();
                                        // PRIMARY RELOAD HOLDER:
                                        var tmpWidth = config.healthBarWidth;
                                        mainContext.fillStyle = darkOutlineColor;
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + tmpX, BAR + config.healthBarPad * 2, 17, 8);
                                        mainContext.fill();
                                        // PRIMARY RELOAD BAR:
                                        if (getEl("visual").value == "spyder") {
                                            mainContext.fillStyle = tmpObj.primaryIndex == undefined || tmpObj.reloads[tmpObj.primaryIndex] == 0 ? "#cba24f" : "#f4d393";
                                        } else if (getEl("visual").value == "lore") {
                                            mainContext.fillStyle = "#fff066";
                                        } else if (getEl("visual").value == "me") {
                                            mainContext.fillStyle = isTeam(tmpObj) ? tmpObj.primaryIndex == undefined || tmpObj.reloads[tmpObj.primaryIndex] == 0 ? "#8ecc51" : `hsl(${50 * Math.ceil(tmpObj.reloads[tmpObj.primaryIndex] / 100)}, 50%, 60%)` : "#cc5151";
                                        } else if (getEl("visual").value == "cele") {
                                            mainContext.fillStyle = "#b0c4de";
                                        } else if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                                            mainContext.fillStyle = tmpObj.primaryIndex == undefined || tmpObj.reloads[tmpObj.primaryIndex] == 0 ? "#ffff00" : `hsl(${50 * Math.ceil(tmpObj.reloads[tmpObj.primaryIndex] / 100)}, 50%, 60%)`;
                                        } else if (getEl("visual").value == "hans") {
                                            mainContext.fillStyle = tmpObj.primaryIndex == undefined || tmpObj.reloads[tmpObj.primaryIndex] == 0 ? "#8f8366" : `hsl(90, 55%, 56%)`;
                                        }
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + config.healthBarPad + tmpX, BAR * (tmpObj.reloads[tmpObj.primaryIndex] == undefined ? 1 : (items.weapons[tmpObj.primaryIndex].speed - tmpReloads.primary) / items.weapons[tmpObj.primaryIndex].speed), (getEl("visual").value == "spyder" ? 16 : 17) - config.healthBarPad * 2, 7);
                                        mainContext.fill();
                                        if (tmpObj == player && getEl("visual").value == "zyenith") {
                                            // TURRET RELOAD HOLDER:
                                            var tmpWidth = config.healthBarWidth;
                                            mainContext.fillStyle = darkOutlineColor;
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13, config.healthBarWidth * 2 + config.healthBarPad * 2, 17, 8);
                                            mainContext.fill();
                                            // TURRET RELOAD BAR:
                                            mainContext.fillStyle = "#96963c";
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13 + config.healthBarPad, config.healthBarWidth * 2 * (tmpObj.reloads[53] == undefined ? 1 : (2500 - tmpObj.reloads[53]) / 2500), 17 - config.healthBarPad * 2, 7);
                                            mainContext.fill();
                                        }
                                    }
                                }
                            }
                        }
                    } else {}
                    if (player) {
                        if (getEl("visual").value == "me" && !isTeam(tmpObj)) {
                            let dist = UTILS.getDist(tmpObj, player, 0, 0);
                            if (dist > 600) {
                                if (!tmpObj.notHere) {
                                    let tracerSize = tmpObj.scale * 2;
                                    let maxmin = function(fr, XorY) {
                                        return Math.max(-(fr - tracerSize), Math.min(fr - tracerSize, XorY));
                                    };
                                    let fixXY = {
                                        x: player.x - xOffset + maxmin(maxScreenWidth / 2, tmpObj.x - xOffset - (player.x - xOffset)),
                                        y: player.y - yOffset + maxmin(maxScreenHeight / 2, tmpObj.y - yOffset - (player.y - yOffset)),
                                    };
                                    let rad = UTILS.getDirect(tmpObj, player, 0, 0);
                                    mainContext.save();
                                    mainContext.translate(fixXY.x, fixXY.y);
                                    mainContext.rotate(rad + Math.PI / 2);
                                    mainContext.fillStyle = darkOutlineColor;
                                    mainContext.globalAlpha = 0.6;
                                    renderTriangle2(tracerSize, mainContext);
                                    mainContext.restore();
                                }
                            } else {
                                if (!tmpObj.visible) {
                                    tmpObj.notHere = true;
                                } else {
                                    tmpObj.notHere = false;
                                }
                            }
                        }
                    }
                }
                );
                ais.forEach((tmp)=>{
                    tmpObj = tmp;
                    if (tmpObj.visible) {
                        // NAME AND HEALTH:
                        if (tmpObj.skinIndex != 10 || tmpObj == player || (tmpObj.team && tmpObj.team == player.team)) {
                            mainContext.strokeStyle = darkOutlineColor;
                            mainContext.globalAlpha = 1;
                            var tmpText = getEl("visual").value == "me" ? "[TeamAnimal] " + (tmpObj.name || "") : getEl("visual").value == "spyder" ? tmpObj.name || "" : getEl("visual").value == "lore" ? "{" + tmpObj.sid + "} " + (tmpObj.name || "") : getEl("visual").value == "cele" ? tmpObj.name || "" : tmpObj.name || "";
                            if (tmpText != "") {
                                mainContext.font = (tmpObj.nameScale || 30) + "px Hammersmith One";
                                mainContext.fillStyle = "#fff";
                                mainContext.textBaseline = "middle";
                                mainContext.textAlign = "center";
                                mainContext.lineWidth = tmpObj.nameScale ? 11 : 8;
                                mainContext.lineJoin = "round";
                                mainContext.strokeText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                mainContext.fillText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                if (getEl("visual").value == "me" && (tmpObj.name == "MOOSTAFA" || tmpObj.name == "MOOFIE") && iconSprites[tmpObj.name == "MOOFIE" ? "skull" : "crown"].isLoaded) {
                                    var tmpS = config.crownIconScale;
                                    var tmpX = tmpObj.x - xOffset - tmpS / 2 - mainContext.measureText(tmpText).width / 2 - config.crownPad;
                                    mainContext.drawImage(iconSprites[tmpObj.name == "MOOFIE" ? "skull" : "crown"], tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY - tmpS / 2 - 5, tmpS, tmpS);
                                }
                            }
                            if (tmpObj.health > 0) {
                                // HEALTH HOLDER:
                                var tmpWidth = config.healthBarWidth;
                                mainContext.fillStyle = darkOutlineColor;
                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY, config.healthBarWidth * 2 + config.healthBarPad * 2, 17, 8);
                                mainContext.fill();
                                // HEALTH BAR:
                                mainContext.fillStyle = "#cc5151";
                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY + config.healthBarPad, config.healthBarWidth * 2 * (tmpObj.health / tmpObj.maxHealth), 17 - config.healthBarPad * 2, 7);
                                mainContext.fill();
                                if (tmpObj.name == "MOOSTAFA") {
                                    // MOOSTAFA RELOAD HOLDER:
                                    var tmpWidth = config.healthBarWidth;
                                    mainContext.fillStyle = darkOutlineColor;
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13, config.healthBarWidth + config.healthBarPad * 2, 17, 8);
                                    mainContext.fill();
                                    // MOOSTAFA RELOAD BAR:
                                    mainContext.fillStyle = outlineColor;
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + config.healthBarPad, config.healthBarWidth * ((600 - tmpObj.weaponReload) / 600), 17 - config.healthBarPad * 2, 7);
                                    mainContext.fill();
                                }
                            }
                        }
                    }
                }
                );
                // RENDER OBJECT HEALTH:
                if (getEl("bh").checked) {
                    gameObjects.forEach((tmp)=>{
                        tmpObj = tmp;
                        if (tmpObj.active && tmpObj.buildHealth) {
                            if (player) {
                                if (UTILS.getDist(tmpObj, player, 0, 0) <= 360) {
                                    // HEALTH HOLDER:
                                    var tmpWidth = config.healthBarWidth;
                                    mainContext.fillStyle = darkOutlineColor;
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth / 2 - config.healthBarPad, tmpObj.y - yOffset - config.healthBarPad, config.healthBarWidth + config.healthBarPad * 2, 17, 8);
                                    mainContext.fill();
                                    // HEALTH BAR:
                                    mainContext.fillStyle = player.sid != tmpObj.owner.sid && !findAllianceBySid(tmpObj.owner.sid) ? "#cc5151" : "#5f9ea0";
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth / 2, tmpObj.y - yOffset, config.healthBarWidth * (tmpObj.buildHealth / tmpObj.health), 17 - config.healthBarPad * 2, 7);
                                    mainContext.fill();
                                }
                                if (UTILS.getDist(tmpObj, player, 0, 0) <= 720 && tmpObj.doUpdate) {
                                    // RELOAD HOLDER:
                                    var tmpWidth = config.healthBarWidth;
                                    mainContext.fillStyle = darkOutlineColor;
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth / 2 - config.healthBarPad, tmpObj.y - yOffset - config.healthBarPad + 13, config.healthBarWidth + config.healthBarPad * 2, 17, 8);
                                    mainContext.fill();
                                    // RELOAD BAR:
                                    mainContext.fillStyle = "#a5974c";
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth / 2, tmpObj.y - yOffset + 13, config.healthBarWidth * ((2200 - tmpObj.shootReload) / 2200), 17 - config.healthBarPad * 2, 7);
                                    mainContext.fill();
                                }
                            }
                        }
                    }
                    );
                }
                // RENDER ANIM TEXTS:
                textManager.update(delta, mainContext, xOffset, yOffset);
                // RENDER CHAT MESSAGES:
                players.forEach((tmp)=>{
                    tmpObj = tmp;
                    if (tmpObj.visible && tmpObj.chatCountdown > 0) {
                        tmpObj.chatCountdown = Math.max(0, (tmpObj.chatCountdown -= delta));
                        mainContext.font = "32px Hammersmith One";
                        var tmpSize = mainContext.measureText(tmpObj.chatMessage);
                        mainContext.textBaseline = "middle";
                        mainContext.textAlign = "center";
                        var tmpX = tmpObj.x - xOffset;
                        var tmpY = tmpObj.y - tmpObj.scale - yOffset - 90;
                        var tmpH = 47;
                        var tmpW = tmpSize.width + 17;
                        mainContext.fillStyle = "rgba(0,0,0,0.2)";
                        mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                        mainContext.fill();
                        mainContext.fillStyle = "#fff";
                        mainContext.fillText(tmpObj.chatMessage, tmpX, tmpY);
                    }
                }
                );
            }
            // RENDER MINIMAP:
            renderMinimap(delta);
            // RENDER CONTROLS:
            if (controllingTouch.id !== -1) {
                renderControl(controllingTouch.startX, controllingTouch.startY, controllingTouch.currentX, controllingTouch.currentY);
            }
            if (attackingTouch.id !== -1) {
                renderControl(attackingTouch.startX, attackingTouch.startY, attackingTouch.currentX, attackingTouch.currentY);
            }
            if (mainContext && (getEl("darkmode").checked || getEl("visual").value == "hans")) {
                mainContext.beginPath();
                let screenW = maxScreenWidth / 2;
                let screenH = maxScreenHeight / 2;
                let gradient = mainContext.createRadialGradient(screenW, screenH, 0, screenW, screenH, getEl("visual").value == "hans" ? maxScreenWidth : maxScreenHeight);
                for (let i = 0; i <= 1; i++) {
                    gradient.addColorStop(i, "rgba(0, 0, 0, " + i + ")");
                }
                mainContext.fillStyle = gradient;
                mainContext.rect(0, 0, maxScreenWidth, maxScreenHeight);
                mainContext.fill();
            }
        }
        // RENDER CONTROL:
        function renderControl(startX, startY, currentX, currentY) {
            mainContext.save();
            mainContext.setTransform(1, 0, 0, 1, 0, 0);
            // mainContext.resetTransform();
            mainContext.scale(pixelDensity, pixelDensity);
            var controlRadius = 50;
            mainContext.beginPath();
            mainContext.arc(startX, startY, controlRadius, 0, Math.PI * 2, false);
            mainContext.closePath();
            mainContext.fillStyle = "rgba(255, 255, 255, 0.3)";
            mainContext.fill();
            var controlRadius = 50;
            var offsetX = currentX - startX;
            var offsetY = currentY - startY;
            var mag = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2));
            var divisor = mag > controlRadius ? mag / controlRadius : 1;
            offsetX /= divisor;
            offsetY /= divisor;
            mainContext.beginPath();
            mainContext.arc(startX + offsetX, startY + offsetY, controlRadius * 0.5, 0, Math.PI * 2, false);
            mainContext.closePath();
            mainContext.fillStyle = "white";
            mainContext.fill();
            mainContext.restore();
        }
        // RENDER PROJECTILES:
        function renderProjectiles(layer, xOffset, yOffset) {
            for (var i = 0; i < projectiles.length; ++i) {
                tmpObj = projectiles[i];
                if (tmpObj.active && tmpObj.layer == layer) {
                    tmpObj.update(delta);
                    if (tmpObj.active && isOnScreen(tmpObj.x - xOffset, tmpObj.y - yOffset, tmpObj.scale)) {
                        mainContext.save();
                        mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                        mainContext.rotate(tmpObj.dir);
                        renderProjectile(0, 0, tmpObj, mainContext, 1);
                        mainContext.restore();
                    }
                }
            }
        }
        // RENDER PROJECTILE:
        var projectileSprites = {};

        function renderProjectile(x, y, obj, ctxt, debug) {
            if (obj.src) {
                var tmpSrc = items.projectiles[obj.indx].src;
                var tmpSprite = projectileSprites[tmpSrc];
                if (!tmpSprite) {
                    tmpSprite = new Image();
                    tmpSprite.onload = function() {
                        this.isLoaded = true;
                    }
                    ;
                    tmpSprite.src = ".././img/weapons/" + tmpSrc + ".png";
                    projectileSprites[tmpSrc] = tmpSprite;
                }
                if (tmpSprite.isLoaded)
                    ctxt.drawImage(tmpSprite, x - obj.scale / 2, y - obj.scale / 2, obj.scale, obj.scale);
            } else if (obj.indx == 1) {
                ctxt.fillStyle = "#939393";
                renderCircle(x, y, obj.scale, ctxt);
            }
        }
        // RENDER WATER BODIES:
        function renderWaterBodies(xOffset, yOffset, ctxt, padding) {
            // MIDDLE RIVER:
            var tmpW = config.riverWidth + padding;
            var tmpY = config.mapScale / 2 - yOffset - tmpW / 2;
            if (tmpY < maxScreenHeight && tmpY + tmpW > 0) {
                ctxt.fillRect(0, tmpY, maxScreenWidth, tmpW);
            }
        }
        // RENDER GAME OBJECTS:
        function renderGameObjects(layer, xOffset, yOffset) {
            var tmpSprite, tmpX, tmpY;
            gameObjects.forEach((tmp)=>{
                tmpObj = tmp;
                if (tmpObj.active) {
                    tmpX = tmpObj.x + tmpObj.xWiggle - xOffset;
                    tmpY = tmpObj.y + tmpObj.yWiggle - yOffset;
                    if (layer == 0) {
                        tmpObj.update(delta);
                    }
                    if (tmpObj.layer == layer && isOnScreen(tmpX, tmpY, tmpObj.scale + (tmpObj.blocker || 0))) {
                        if (getEl("darkmode").checked) {
                            let camXY = {
                                x: camX,
                                y: camY,
                            };
                            mainContext.globalAlpha = tmpObj.hideFromEnemy ? 0.6 : Math.max(0, Math.min(1, (720 - UTILS.getDist(tmpObj, camXY, 0, 0)) / 240));
                        } else {
                            mainContext.globalAlpha = tmpObj.hideFromEnemy ? 0.6 : 1;
                        }
                        if (tmpObj.isItem) {
                            if ((tmpObj.dmg || tmpObj.trap) && getEl("visual").value != "0" && getEl("visual").value != "ae" && player && player.sid != tmpObj.owner.sid && !findAllianceBySid(tmpObj.owner.sid)) {
                                tmpSprite = getObjSprite(tmpObj);
                            } else {
                                tmpSprite = getItemSprite(tmpObj);
                            }
                            mainContext.save();
                            mainContext.translate(tmpX, tmpY);
                            if ((getEl("visual").value != "cele" && getEl("visual").value != "ae") || tmpObj.doUpdate) {
                                mainContext.rotate(tmpObj.dir);
                            }
                            mainContext.drawImage(tmpSprite, -(tmpSprite.width / 2), -(tmpSprite.height / 2));
                            if (tmpObj.blocker) {
                                mainContext.strokeStyle = "#db6e6e";
                                mainContext.globalAlpha = 0.3;
                                mainContext.lineWidth = 6;
                                renderCircle(0, 0, tmpObj.blocker, mainContext, false, true);
                            }
                            mainContext.restore();
                        } else {
                            tmpSprite = getResSprite(tmpObj);
                            mainContext.drawImage(tmpSprite, tmpX - tmpSprite.width / 2, tmpY - tmpSprite.height / 2);
                        }
                    }
                }
            }
            );
        }
        // GATHER ANIMATION:
        let hittedObj = [];
        let hittedObj2 = [];

        function objHitC(dmg, index) {
            return new Promise((resolve,reject)=>{
                resolve({
                    dmg: dmg,
                    index: index
                });
            }
            );
        }

        function gatherAnimation(sid, didHit, index) {
            tmpObj = findPlayerBySID(sid);
            if (tmpObj) {
                tmpObj.startAnim(didHit, index);
                tmpObj.gatherIndex = index;
                tmpObj.gathering = 1;
                if (didHit) {
                    tmpObj.doTickUpdate = true;
                    let camper = tmpObj;
                    let lolnoob = hittedObj;
                    hittedObj = [];
                    doNextTick(()=>{
                        let cope = items.weapons[index];
                        let getgood = config.weaponVariants[camper.primaryVariant == undefined ? 0 : camper.primaryVariant].val;
                        let ratio = cope.sDmg || 1;
                        let damagedHeart = cope.dmg * getgood * ratio * (camper.skinIndex == 40 ? 3.3 : 1);
                        lolnoob.forEach((urbad)=>{
                            urbad.buildHealth -= damagedHeart;
                        }
                        );
                    }
                    );
                    if (getEl("ohio").checked) {
                        let bonk = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1101432056992497744/Bonk_Sound_Effect_-_from_YouTube.mp3");
                        bonk.volume = "0.2";
                        bonk.play();
                    }
                }
            }
        }
        // RENDER PLAYERS:
        function renderPlayers(xOffset, yOffset, zIndex) {
            mainContext.globalAlpha = 1;
            for (var i = 0; i < players.length; ++i) {
                tmpObj = players[i];
                if (tmpObj.zIndex == zIndex) {
                    tmpObj.animate(delta);
                    if (tmpObj.visible) {
                        tmpObj.skinRot += 0.002 * delta;
                        tmpDir = (tmpObj == player && !(getEl("visual").value == "me" || getEl("visual").value == "spyder" || getEl("visual").value == "ae") ? getEl("visual").value == "lore" || getEl("visual").value == "zeph" || getEl("visual").value == "fz" ? getAttackDir() : getSafeDir() : tmpObj.dir) + tmpObj.dirPlus;
                        mainContext.save();
                        mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                        // RENDER PLAYER:
                        mainContext.rotate(tmpDir);
                        renderPlayer(tmpObj, mainContext);
                        mainContext.restore();
                        /*if (tmpObj) {

                                            mainContext.rotate(0);
                                            let X = {
                                                one: tmpObj.x - 12,
                                                two: tmpObj.x + 12
                                            }
                                            let Y = tmpObj.y - 3.5;

                                            // EYE:
                                            mainContext.save();
                                            mainContext.fillStyle = "#000";
                                            renderCircle2(X.one - xOffset, Y - yOffset, 8, mainContext, true, false);
                                            renderCircle2(X.two - xOffset, Y - yOffset, 8, mainContext, true, false);

                                            mainContext.fillStyle = "#fff";
                                            let maxmin = function(fr, XorY) {
                                                return Math.max(-(fr - 4), Math.min((fr - 4), XorY));
                                            }
                                            renderCircle2(X.one - xOffset, Y - yOffset, 4, mainContext, true, false);
                                            renderCircle2(X.two - xOffset, Y - yOffset, 4, mainContext, true, false);
                                            mainContext.restore();

                                        }*/
                    }
                }
            }
        }
        // RENDER PLAYER:
        function renderPlayer(obj, ctxt) {
            ctxt = ctxt || mainContext;
            ctxt.lineWidth = outlineWidth;
            ctxt.lineJoin = "miter";
            var handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS || 1);
            var oHandAngle = obj.buildIndex < 0 ? items.weapons[obj.weaponIndex].hndS || 1 : 1;
            var oHandDist = obj.buildIndex < 0 ? items.weapons[obj.weaponIndex].hndD || 1 : 1;
            // TAIL/CAPE:
            if (obj.tailIndex > 0) {
                renderTail(obj.tailIndex, ctxt, obj);
            }
            /*if (getEl("darkmode").checked) {
                          mainContext.shadowColor = "rgba(0, 0, 0, 0.35)";
                          mainContext.shadowOffsetX = 10;
                          mainContext.shadowOffsetY = 10;
                          mainContext.shadowBlur = 7.5;
                      }*/
            // WEAPON BELLOW HANDS:
            if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
                renderTool(items.weapons[(getEl("kmtexture").checked && obj.weaponIndex == 3 && obj.secondaryIndex == 15) ? 4 : obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                    renderProjectile(obj.scale, 0, items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                }
            }
            // HANDS:
            ctxt.fillStyle = config.skinColors[obj.skinColor];
            renderCircle(obj.scale * Math.cos(handAngle), obj.scale * Math.sin(handAngle), 14);
            renderCircle(obj.scale * oHandDist * Math.cos(-handAngle * oHandAngle), obj.scale * oHandDist * Math.sin(-handAngle * oHandAngle), 14);
            // WEAPON ABOVE HANDS:
            if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
                renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                    renderProjectile(obj.scale, 0, items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                }
            }
            // BUILD ITEM:
            if (obj.buildIndex >= 0) {
                var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
                ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
            }
            /*if (getEl("darkmode").checked) {
                          mainContext.shadowColor = 0;
                          mainContext.shadowOffsetX = 0;
                          mainContext.shadowOffsetY = 0;
                          mainContext.shadowBlur = 0;
                      }*/
            // BODY:
            renderCircle(0, 0, obj.scale, ctxt);
            // SKIN:
            if (obj.skinIndex > 0) {
                ctxt.rotate(Math.PI / 2);
                renderSkin(obj.skinIndex, ctxt, null, obj);
            }
        }
        // RENDER SKINS:
        var skinSprites = {};
        var skinPointers = {};
        var tmpSkin;

        function renderSkin(index, ctxt, parentSkin, owner) {
            tmpSkin = skinSprites[index];
            if (!tmpSkin) {
                var tmpImage = new Image();
                tmpImage.onload = function() {
                    this.isLoaded = true;
                    this.onload = null;
                }
                ;
                tmpImage.src = ".././img/hats/hat_" + index + ".png";
                skinSprites[index] = tmpImage;
                tmpSkin = tmpImage;
            }
            var tmpObj = parentSkin || skinPointers[index];
            if (!tmpObj) {
                for (var i = 0; i < hats.length; ++i) {
                    if (hats[i].id == index) {
                        tmpObj = hats[i];
                        break;
                    }
                }
                skinPointers[index] = tmpObj;
            }
            if (tmpSkin.isLoaded)
                ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
            if (!parentSkin && tmpObj.topSprite) {
                ctxt.save();
                ctxt.rotate(owner.skinRot);
                renderSkin(index + "_top", ctxt, tmpObj, owner);
                ctxt.restore();
            }
        }
        // RENDER TAIL:
        var accessSprites = {};
        var accessPointers = {};

        function renderTail(index, ctxt, owner) {
            tmpSkin = accessSprites[index];
            if (!tmpSkin) {
                var tmpImage = new Image();
                tmpImage.onload = function() {
                    this.isLoaded = true;
                    this.onload = null;
                }
                ;
                tmpImage.src = ".././img/accessories/access_" + index + ".png";
                accessSprites[index] = tmpImage;
                tmpSkin = tmpImage;
            }
            var tmpObj = accessPointers[index];
            if (!tmpObj) {
                for (var i = 0; i < accessories.length; ++i) {
                    if (accessories[i].id == index) {
                        tmpObj = accessories[i];
                        break;
                    }
                }
                accessPointers[index] = tmpObj;
            }
            if (tmpSkin.isLoaded) {
                ctxt.save();
                ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
                if (tmpObj.spin)
                    ctxt.rotate(owner.skinRot);
                ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
                ctxt.restore();
            }
        }
        // RENDER TOOL:
        var toolSprites = {};

        function renderTool(obj, variant, x, y, ctxt) {
            var tmpSrc = obj.src + (variant || "");
            var tmpSprite = toolSprites[tmpSrc];
            if (!tmpSprite) {
                tmpSprite = new Image();
                tmpSprite.onload = function() {
                    this.isLoaded = true;
                }
                ;
                tmpSprite.src = ".././img/weapons/" + tmpSrc + ".png";
                toolSprites[tmpSrc] = tmpSprite;
            }
            if (tmpSprite.isLoaded)
                ctxt.drawImage(tmpSprite, x + obj.xOff - obj.length / 2, y + obj.yOff - obj.width / 2, obj.length, obj.width);
        }
        // RENDER GAME OBJECTS:
        var gameObjectSprites = {};

        function getResSprite(obj) {
            var biomeID = obj.y >= config.mapScale - config.snowBiomeTop ? 2 : obj.y <= config.snowBiomeTop ? 1 : 0;
            var tmpIndex = obj.type + "_" + obj.scale + "_" + biomeID;
            var tmpSprite = gameObjectSprites[tmpIndex];
            if (!tmpSprite) {
                var tmpCanvas = document.createElement("canvas");
                tmpCanvas.width = tmpCanvas.height = obj.scale * 2.1 + outlineWidth;
                var tmpContext = tmpCanvas.getContext("2d");
                tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                tmpContext.rotate(UTILS.randFloat(0, Math.PI));
                tmpContext.strokeStyle = outlineColor;
                tmpContext.lineWidth = outlineWidth;
                let colors = [["#b1d959", "#95b946"], ["#bade6e", "#aac76b"], ["#a7d544", "#86a63f"], ["#b4db62", "#9ebf57"], ];
                let select = colors[Math.floor(Math.random() * colors.length)];
                if (obj.type == 0) {
                    var tmpScale;
                    for (var i = 0; i < 2; ++i) {
                        tmpScale = tmpObj.scale * (!i ? 1 : 0.5);
                        renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                        tmpContext.fillStyle = !biomeID ? !i ? select[1] : select[0] : !i ? "#e3f1f4" : "#fff";
                        tmpContext.fill();
                        if (!i)
                            tmpContext.stroke();
                    }
                } else if (obj.type == 1) {
                    if (biomeID == 2) {
                        tmpContext.fillStyle = "#606060";
                        renderStar(tmpContext, 6, obj.scale * 0.3, obj.scale * 0.71);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#89a54c";
                        renderCircle(0, 0, obj.scale * 0.55, tmpContext);
                        tmpContext.fillStyle = "#a5c65b";
                        renderCircle(0, 0, obj.scale * 0.3, tmpContext, true);
                    } else {
                        renderBlob(tmpContext, 6, tmpObj.scale, tmpObj.scale * 0.7);
                        tmpContext.fillStyle = biomeID ? "#e3f1f4" : "#89a54c";
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = biomeID ? "#6a64af" : "#c15555";
                        var tmpRange;
                        var berries = 4;
                        var rotVal = mathPI2 / berries;
                        for (var i = 0; i < berries; ++i) {
                            tmpRange = UTILS.randInt(tmpObj.scale / 3.5, tmpObj.scale / 2.3);
                            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(10, 12), tmpContext);
                        }
                    }
                } else if (obj.type == 2 || obj.type == 3) {
                    tmpContext.fillStyle = obj.type == 2 ? biomeID == 2 ? "#938d77" : "#939393" : "#e0c655";
                    renderStar(tmpContext, 3, obj.scale, obj.scale);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = obj.type == 2 ? biomeID == 2 ? "#b2ab90" : "#bcbcbc" : "#ebdca3";
                    renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                    tmpContext.fill();
                }
                tmpSprite = tmpCanvas;
                gameObjectSprites[tmpIndex] = tmpSprite;
            }
            return tmpSprite;
        }
        // GET ITEM SPRITE:
        var itemSprites = [];

        function getItemSprite(obj, asIcon) {
            var tmpSprite = itemSprites[obj.id];
            if (!tmpSprite || asIcon) {
                var tmpCanvas = document.createElement("canvas");
                tmpCanvas.width = tmpCanvas.height = obj.scale * 2.5 + outlineWidth + (items.list[obj.id].spritePadding || 0);
                var tmpContext = tmpCanvas.getContext("2d");
                tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                tmpContext.rotate(asIcon ? 0 : Math.PI / 2);
                tmpContext.strokeStyle = outlineColor;
                tmpContext.lineWidth = outlineWidth * (asIcon ? tmpCanvas.width / 81 : 1);
                if (obj.name == "apple") {
                    tmpContext.fillStyle = "#c15555";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#89a54c";
                    var leafDir = -(Math.PI / 2);
                    renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir), 25, leafDir + Math.PI / 2, tmpContext);
                } else if (obj.name == "cookie") {
                    tmpContext.fillStyle = "#cca861";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#937c4b";
                    var chips = 4;
                    var rotVal = mathPI2 / chips;
                    var tmpRange;
                    for (var i = 0; i < chips; ++i) {
                        tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                        renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(4, 5), tmpContext, true);
                    }
                } else if (obj.name == "cheese") {
                    tmpContext.fillStyle = "#f4f3ac";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#c3c28b";
                    var chips = 4;
                    var rotVal = mathPI2 / chips;
                    var tmpRange;
                    for (var i = 0; i < chips; ++i) {
                        tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                        renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(4, 5), tmpContext, true);
                    }
                } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                    tmpContext.fillStyle = obj.name == "castle wall" ? "#83898e" : obj.name == "wood wall" ? "#a5974c" : "#939393";
                    var sides = obj.name == "castle wall" ? 4 : 3;
                    renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = obj.name == "castle wall" ? "#9da4aa" : obj.name == "wood wall" ? "#c9b758" : "#bcbcbc";
                    renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                    tmpContext.fill();
                } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                    tmpContext.fillStyle = obj.name == "poison spikes" ? "#7b935d" : "#939393";
                    var tmpScale = obj.scale * 0.6;
                    renderStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, tmpScale, tmpContext);
                    tmpContext.fillStyle = "#c9b758";
                    renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#c9b758";
                    renderRectCircle(0, 0, obj.scale * 1.5, 29, 4, tmpContext);
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, obj.scale * 0.5, tmpContext);
                } else if (obj.name == "mine") {
                    tmpContext.fillStyle = "#939393";
                    renderStar(tmpContext, 3, obj.scale, obj.scale);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#bcbcbc";
                    renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                    tmpContext.fill();
                } else if (obj.name == "sapling") {
                    for (var i = 0; i < 2; ++i) {
                        var tmpScale = obj.scale * (!i ? 1 : 0.5);
                        renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                        tmpContext.fillStyle = !i ? "#9ebf57" : "#b4db62";
                        tmpContext.fill();
                        if (!i)
                            tmpContext.stroke();
                    }
                } else if (obj.name == "pit trap") {
                    tmpContext.fillStyle = "#a5974c";
                    renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = outlineColor;
                    renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                    tmpContext.fill();
                } else if (obj.name == "boost pad") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#dbd97d";
                    renderTriangle(obj.scale * 1, tmpContext);
                } else if (obj.name == "turret") {
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#939393";
                    var tmpLen = 50;
                    renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                    renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                } else if (obj.name == "platform") {
                    tmpContext.fillStyle = "#cebd5f";
                    var tmpCount = 4;
                    var tmpS = obj.scale * 2;
                    var tmpW = tmpS / tmpCount;
                    var tmpX = -(obj.scale / 2);
                    for (var i = 0; i < tmpCount; ++i) {
                        renderRect(tmpX - tmpW / 2, 0, tmpW, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpX += tmpS / tmpCount;
                    }
                } else if (obj.name == "healing pad") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#db6e6e";
                    renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                } else if (obj.name == "spawn pad") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#71aad6";
                    renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                } else if (obj.name == "blocker") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.rotate(Math.PI / 4);
                    tmpContext.fillStyle = "#db6e6e";
                    renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                } else if (obj.name == "teleporter") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.rotate(Math.PI / 4);
                    tmpContext.fillStyle = "#d76edb";
                    renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                }
                tmpSprite = tmpCanvas;
                if (!asIcon)
                    itemSprites[obj.id] = tmpSprite;
            }
            return tmpSprite;
        }
        var objSprites = [];

        function getObjSprite(obj) {
            var tmpSprite = objSprites[obj.id];
            if (!tmpSprite) {
                var tmpCanvas = document.createElement("canvas");
                tmpCanvas.width = tmpCanvas.height = obj.scale * 2.5 + outlineWidth + (items.list[obj.id].spritePadding || 0);
                var tmpContext = tmpCanvas.getContext("2d");
                tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                tmpContext.rotate(Math.PI / 2);
                tmpContext.strokeStyle = outlineColor;
                tmpContext.lineWidth = outlineWidth;
                if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                    tmpContext.fillStyle = obj.name == "poison spikes" ? "#7b935d" : "#939393";
                    var tmpScale = obj.scale * 0.6;
                    renderStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, tmpScale, tmpContext);
                    tmpContext.fillStyle = "#cc5151";
                    renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                } else if (obj.name == "pit trap") {
                    tmpContext.fillStyle = "#a5974c";
                    renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#cc5151";
                    renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                    tmpContext.fill();
                }
                tmpSprite = tmpCanvas;
                objSprites[obj.id] = tmpSprite;
            }
            return tmpSprite;
        }
        // RENDER LEAF:
        function renderLeaf(x, y, l, r, ctxt) {
            var endX = x + l * Math.cos(r);
            var endY = y + l * Math.sin(r);
            var width = l * 0.4;
            ctxt.moveTo(x, y);
            ctxt.beginPath();
            ctxt.quadraticCurveTo((x + endX) / 2 + width * Math.cos(r + Math.PI / 2), (y + endY) / 2 + width * Math.sin(r + Math.PI / 2), endX, endY);
            ctxt.quadraticCurveTo((x + endX) / 2 - width * Math.cos(r + Math.PI / 2), (y + endY) / 2 - width * Math.sin(r + Math.PI / 2), x, y);
            ctxt.closePath();
            ctxt.fill();
            ctxt.stroke();
        }
        // RENDER CIRCLE:
        function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
            tmpContext = tmpContext || mainContext;
            tmpContext.beginPath();
            tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
            if (!dontFill)
                tmpContext.fill();
            if (!dontStroke)
                tmpContext.stroke();
        }

        function renderCircle2(x, y, scale, tmpContext, dontStroke, dontFill) {
            tmpContext = tmpContext || mainContext;
            tmpContext.beginPath();
            tmpContext.ellipse(x, y, scale * 1.5, scale, Math.PI / 2, 0, Math.PI * 2);
            if (!dontFill)
                tmpContext.fill();
            if (!dontStroke)
                (tmpContext.lineWidth = 3.5),
                tmpContext.stroke();
        }
        // RENDER STAR SHAPE:
        function renderStar(ctxt, spikes, outer, inner) {
            var rot = (Math.PI / 2) * 3;
            var x, y;
            var step = Math.PI / spikes;
            ctxt.beginPath();
            ctxt.moveTo(0, -outer);
            for (var i = 0; i < spikes; i++) {
                x = Math.cos(rot) * outer;
                y = Math.sin(rot) * outer;
                ctxt.lineTo(x, y);
                rot += step;
                x = Math.cos(rot) * inner;
                y = Math.sin(rot) * inner;
                ctxt.lineTo(x, y);
                rot += step;
            }
            ctxt.lineTo(0, -outer);
            ctxt.closePath();
        }
        // RENDER RECTANGLE:
        function renderRect(x, y, w, h, ctxt, stroke) {
            ctxt.fillRect(x - w / 2, y - h / 2, w, h);
            if (!stroke)
                ctxt.strokeRect(x - w / 2, y - h / 2, w, h);
        }
        // RENDER RECTCIRCLE:
        function renderRectCircle(x, y, s, sw, seg, ctxt, stroke) {
            ctxt.save();
            ctxt.translate(x, y);
            seg = Math.ceil(seg / 2);
            for (var i = 0; i < seg; i++) {
                renderRect(0, 0, s * 2, sw, ctxt, stroke);
                ctxt.rotate(Math.PI / seg);
            }
            ctxt.restore();
        }
        // RENDER BLOB:
        function renderBlob(ctxt, spikes, outer, inner) {
            var rot = (Math.PI / 2) * 3;
            var x, y;
            var step = Math.PI / spikes;
            var tmpOuter;
            ctxt.beginPath();
            ctxt.moveTo(0, -inner);
            for (var i = 0; i < spikes; i++) {
                tmpOuter = UTILS.randInt(outer + 0.9, outer * 1.2);
                ctxt.quadraticCurveTo(Math.cos(rot + step) * tmpOuter, Math.sin(rot + step) * tmpOuter, Math.cos(rot + step * 2) * inner, Math.sin(rot + step * 2) * inner);
                rot += step * 2;
            }
            ctxt.lineTo(0, -inner);
            ctxt.closePath();
        }
        // RENDER TRIANGLE:
        function renderTriangle(s, ctx) {
            ctx = ctx || mainContext;
            var h = s * (Math.sqrt(3) / 2);
            ctx.beginPath();
            ctx.moveTo(0, -h / 2);
            ctx.lineTo(-s / 2, h / 2);
            ctx.lineTo(s / 2, h / 2);
            ctx.lineTo(0, -h / 2);
            ctx.fill();
            ctx.closePath();
        }

        function renderTriangle2(s, ctx) {
            ctx = ctx || mainContext;
            var h = s * (Math.sqrt(3) / 2);
            ctx.beginPath();
            ctx.moveTo(0, -h / 3.5);
            ctx.lineTo(-s / 2, h / 2);
            ctx.lineTo(s / 2, h / 2);
            ctx.lineTo(0, -h / 3.5);
            ctx.fill();
            ctx.closePath();
            ctx.stroke();
        }

        function renderTriangle3(s, ctx) {
            ctx = ctx || mainContext;
            var h = s * (Math.sqrt(3) / 2);
            ctx.beginPath();
            ctx.moveTo(0, -h / 2);
            ctx.lineTo(-s / 1.5, h / 1.5);
            ctx.lineTo(s / 1.5, h / 1.5);
            ctx.lineTo(0, -h / 2);
            ctx.fill();
            ctx.closePath();
        }

        // PREPARE MENU BACKGROUND:
        function prepareMenuBackground() {
            var tmpMid = config.mapScale / 2;
            objectManager.add(0, tmpMid, tmpMid + 200, 0, config.treeScales[3], 0);
            objectManager.add(1, tmpMid, tmpMid - 480, 0, config.treeScales[3], 0);
            objectManager.add(2, tmpMid + 300, tmpMid + 450, 0, config.treeScales[3], 0);
            objectManager.add(3, tmpMid - 950, tmpMid - 130, 0, config.treeScales[2], 0);
            objectManager.add(4, tmpMid - 750, tmpMid - 400, 0, config.treeScales[3], 0);
            objectManager.add(5, tmpMid - 700, tmpMid + 400, 0, config.treeScales[2], 0);
            objectManager.add(6, tmpMid + 800, tmpMid - 200, 0, config.treeScales[3], 0);
            objectManager.add(7, tmpMid - 260, tmpMid + 340, 0, config.bushScales[3], 1);
            objectManager.add(8, tmpMid + 760, tmpMid + 310, 0, config.bushScales[3], 1);
            objectManager.add(9, tmpMid - 800, tmpMid + 100, 0, config.bushScales[3], 1);
            objectManager.add(10, tmpMid - 800, tmpMid + 300, 0, items.list[4].scale, items.list[4].id, items.list[10]);
            objectManager.add(11, tmpMid + 650, tmpMid - 390, 0, items.list[4].scale, items.list[4].id, items.list[10]);
            objectManager.add(12, tmpMid - 400, tmpMid - 450, 0, config.rockScales[2], 2);
        }
        // CREATE FAKE OBJECTS:
        function makeFakeObjects() {
            return;
            for (let i = 0; i < 500; i++) {
                let randomXY = {
                    x: Math.floor(Math.random() * 14400),
                    y: Math.floor(Math.random() * 14400),
                };
                let rT = Math.floor(Math.random() * 4);
                objectManager.add(i, randomXY.x, randomXY.y, 0, (rT == 0 ? config.treeScales : rT == 1 ? config.bushScales : rT >= 2 && config.rockScales)[Math.florr(Math.random() * (rT == 0 ? 4 : 3))], rT);
            }
        }
        // ANTI TRAP:
        let earlyAutoBreak = {
            start: false
        };

        function antiTrap(aim) {
            if (near.dist2 <= 250) {
                for (let i = -45; i <= 45; i += 90) {
                    checkPlace(2, aim + UTILS.toRad(i) + Math.PI);
                }
            } else if (near.dist2 <= 600) {
                for (let i = -45; i <= 45; i += 90) {
                    if (enemy.length) {
                        checkPlace(4, aim + UTILS.toRad(i) + Math.PI);
                    }
                }
            }
        }
        // LOAD GAME OBJECT:
        let myTeles = [];

        function loadGameObject(data) {
            for (var i = 0; i < data.length; ) {
                objectManager.add(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], items.list[data[i + 6]], true, data[i + 7] >= 0 ? {
                    sid: data[i + 7]
                } : null);
                let XY = {
                    x: data[i + 1],
                    y: data[i + 2],
                };
                let dist = UTILS.getDist(XY, player, 0, 2);
                let aim = UTILS.getDirect(XY, player, 0, 2);
                if (data[i + 6] == 22 && player.sid == data[i + 7]) {
                    myTeles.push({
                        x: data[i + 1],
                        y: data[i + 2]
                    });
                    setTimeout(()=>{
                        myTeles.shift();
                    }
                    , 30000);
                }
                if (getEl("earlyab").checked) {
                    if (data[i + 6] == 15 && dist <= 100 && player.sid != data[i + 7] && !findAllianceBySid(data[i + 7])) {
                        setTimeout(()=>{
                            dist = UTILS.getDist(XY, player, 0, 2);
                            aim = UTILS.getDirect(XY, player, 0, 2);
                            traps.in = true;
                            traps.aim = aim;
                            if (!earlyAutoBreak.start) {
                                earlyAutoBreak.start = true;
                                earlyAutoBreak.hit = 0;
                                earlyAutoBreak.miss = 0;
                            }
                            if (dist <= 75) {
                                earlyAutoBreak.hit++;
                            } else {
                                earlyAutoBreak.miss++;
                            }
                        }
                        , parseInt(getEl("earlytime").value));
                    }
                }
                setTickout(()=>{
                    dist = UTILS.getDist(XY, player, 0, 2);
                    aim = UTILS.getDirect(XY, player, 0, 2);
                    if (data[i + 6] == 15 && dist <= 100 && player.sid != data[i + 7] && !findAllianceBySid(data[i + 7])) {
                        antiTrap(aim);
                    }
                }
                , 1);
                i += 8;
            }
        }
        // WIGGLE GAME OBJECT:
        let ticktickticky = [];

        function antiSyncHealing(timearg) {
            antiSync = true;
            let healAnti = setInterval(()=>{
                if (player.shameCount < 5) {
                    place(0, getAttackDir());
                }
            }
            , 75);
            setTimeout(()=>{
                clearInterval(healAnti);
                setTimeout(()=>{
                    antiSync = false;
                }, config.tickRate);
            }
            , config.tickRate * timearg);
        }
        function wiggleGameObject(dir, sid) {
            tmpObj = findObjectBySid(sid);
            if (tmpObj) {
                tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir);
                tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir);
                if (tmpObj.buildHealth) {
                    hittedObj.push(tmpObj);
                    //                    hittedObj2.push(tmpObj);
                }
            }
        }
        // SHOOT TURRET:
        function shootTurret(sid, dir) {
            tmpObj = findObjectBySid(sid);
            if (tmpObj) {
                tmpObj.dir = dir;
                tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir + Math.PI);
                tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir + Math.PI);
                tmpObj.shootted = 1;
            }
        }
        // ADD PROJECTILE:
        let doSync = false;
        let antiSync = false;
        let runAtNextTick = [];
        let rangeBackup = [];

        function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
            if (inWindow) {
                projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer).sid = sid;
            }
            runAtNextTick.push(Array.prototype.slice.call(arguments));
        }

        function checkProjectileHolder(x, y, dir, range, speed, indx, layer, sid) {
            let weaponIndx = indx == 0 ? 9 : indx == 2 ? 12 : indx == 3 ? 13 : indx == 5 && 15;
            let projOffset = config.playerScale * 2;
            let projXY = {
                x: indx == 1 ? x : x - projOffset * Math.cos(dir),
                y: indx == 1 ? y : y - projOffset * Math.sin(dir),
            };
            let fixXY = function(tmpObj) {
                return {
                    x2: UTILS.fixTo(tmpObj.x2, 2),
                    y2: UTILS.fixTo(tmpObj.y2, 2),
                };
            };
            let nearPlayer = players.filter((e)=>e.visible && UTILS.getDist(projXY, e, 0, 2) <= e.scale).sort(function(a, b) {
                return (UTILS.getDist(projXY, a, 0, 2) - UTILS.getDist(projXY, b, 0, 2));
            })[0];
            if (nearPlayer) {
                nearPlayer.projDist = UTILS.getDist(projXY, nearPlayer, 0, 2);
                if (indx == 1) {
                    nearPlayer.shooting[53] = 1;
                } else {
                    nearPlayer.shootIndex = weaponIndx;
                    nearPlayer.shooting[1] = 1;
                    antiBulletSupportmentsEasyGamer69Proe(nearPlayer, dir, range, speed, indx, weaponIndx);
                }
            }
        }
        let projectileCount = 0;

        function antiBulletSupportmentsEasyGamer69Proe(tmpObj, dir, range, speed, index, weaponIndex) {
            if (!isTeam(tmpObj)) {
                tmpDir = UTILS.getDirect(player, tmpObj, 2, 2);
                if (UTILS.getAngleDist(tmpDir, dir) <= 0.2) {
                    tmpObj.bowThreat[weaponIndex]++;
                    if (index == 5) {
                        projectileCount++;
                    }
                    setTimeout(()=>{
                        tmpObj.bowThreat[weaponIndex]--;
                        if (index == 5) {
                            projectileCount--;
                        }
                    }
                    , range / speed);
                    if (tmpObj.bowThreat[9] >= 1 && (tmpObj.bowThreat[12] >= 1 || tmpObj.bowThreat[15] >= 1)) {
                        place(1, tmpObj.aim2);
                        if (getEl("antirange").checked && !antiSync) {
                            anti0Tick = 4;
                            if (getEl("combat").value == "ae") {
                                io.send("ch", "ranged insta");
                                setTimeout(()=>{
                                    io.send("ch", "is homo");
                                }
                                , 2000);
                            } else {
                                io.send("ch", "ranged insta homo");
                            }
                            antiSyncHealing(4);
                        }
                    } else {
                        if (projectileCount >= 2) {
                            place(1, tmpObj.aim2);
                            anti0Tick = 4;
                            if (getEl("antisync").checked && !antiSync) {
                                if (getEl("combat").value != "ae") {
                                    io.send("ch", getEl("combat").value == "hans" ? "sync is homo" : "ranged sync homo");
                                }
                                antiSyncHealing(4);
                            }
                        }
                    }
                }
            }
        }
        // REMOVE PROJECTILE:
        function remProjectile(sid, range) {
            for (var i = 0; i < projectiles.length; ++i) {
                if (projectiles[i].sid == sid) {
                    projectiles[i].range = range;
                    let tmpObjects = hittedObj;
                    let aaaaaaaaaaaaaa = projectiles[i].dmg;
                    hittedObj = [];
                    doNextTick(()=>{
                        tmpObjects.forEach((tmp)=>{
                            if (tmp.projDmg) {
                                tmp.buildHealth -= aaaaaaaaaaaaaa;
                            }
                        }
                        );
                    }
                    );
                }
            }
        }
        // ANIMATE AI:
        function animateAI(sid) {
            tmpObj = findAIBySID(sid);
            if (tmpObj) {
                tmpObj.startAnim();
                tmpObj.weaponHitted = 1;
                tmpObj.doTickUpdate = true;
                let tmpObjects = hittedObj;
                hittedObj = [];
                doNextTick(()=>{
                    tmpObjects.forEach((tmp)=>{
                        tmp.buildHealth -= 232;
                    }
                    );
                }
                );
            }
        }
        // ADD AI:
        function loadAI(data) {
            for (var i = 0; i < ais.length; ++i) {
                ais[i].forcePos = !ais[i].visible;
                ais[i].visible = false;
            }
            if (data) {
                var tmpTime = Date.now();
                for (var i = 0; i < data.length; ) {
                    tmpObj = findAIBySID(data[i]);
                    if (tmpObj) {
                        tmpObj.index = data[i + 1];
                        tmpObj.t1 = tmpObj.t2 === undefined ? tmpTime : tmpObj.t2;
                        tmpObj.t2 = tmpTime;
                        tmpObj.x1 = tmpObj.x;
                        tmpObj.y1 = tmpObj.y;
                        tmpObj.x2 = data[i + 2];
                        tmpObj.y2 = data[i + 3];
                        tmpObj.d1 = tmpObj.d2 === undefined ? data[i + 4] : tmpObj.d2;
                        tmpObj.d2 = data[i + 4];
                        tmpObj.health = data[i + 5];
                        tmpObj.dt = 0;
                        tmpObj.visible = true;
                        if (tmpObj.name == "MOOSTAFA") {
                            if (tmpObj.doTickUpdate) {
                                tmpObj.doTickUpdate = false;
                            }
                            if (tmpObj.weaponHitted) {
                                tmpObj.weaponHitted = false;
                                tmpObj.weaponReload = 600;
                            } else {
                                tmpObj.weaponReload = Math.max(0, tmpObj.weaponReload - config.tickRate);
                            }
                        }
                    } else {
                        tmpObj = aiManager.spawn(data[i + 2], data[i + 3], data[i + 4], data[i + 1]);
                        tmpObj.x2 = tmpObj.x;
                        tmpObj.y2 = tmpObj.y;
                        tmpObj.d2 = tmpObj.dir;
                        tmpObj.health = data[i + 5];
                        if (!aiManager.aiTypes[data[i + 1]].name)
                            tmpObj.name = config.cowNames[data[i + 6]];
                        tmpObj.forcePos = true;
                        tmpObj.sid = data[i];
                        tmpObj.visible = true;
                    }
                    i += 7;
                }
            }
        }
        // RENDER AI:
        var aiSprites = {};

        function renderAI(obj, ctxt) {
            var tmpIndx = obj.index;
            var tmpSprite = aiSprites[tmpIndx];
            if (!tmpSprite) {
                var tmpImg = new Image();
                tmpImg.onload = function() {
                    this.isLoaded = true;
                    this.onload = null;
                }
                ;
                tmpImg.src = ".././img/animals/" + obj.src + ".png";
                tmpSprite = tmpImg;
                aiSprites[tmpIndx] = tmpSprite;
            }
            if (tmpSprite.isLoaded) {
                var tmpScale = obj.scale * 1.2 * (obj.spriteMlt || 1);
                ctxt.drawImage(tmpSprite, -tmpScale, -tmpScale, tmpScale * 2, tmpScale * 2);
            }
        }
        // OBJECT ON SCREEN:
        function isOnScreen(x, y, s) {
            return (x + s >= 0 && x - s <= maxScreenWidth && y + s >= 0 && (y,
            s,
            maxScreenHeight));
        }
        // FUNCTIONS:
        let configs = {
            weaponCode: 0,
            antiBull: 0,
            antiBull2: 0,
            waitHit: false,
        };

        function place(id, radian) {
            try {
                var item = items.list[player.items[id]];
                if (player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (config.isSandbox ? 99 : item.group.limit ? item.group.limit : 99)) {
                    selectToBuild(player.items[id]);
                    sendAtck(1, radian);
                    selectWeapon(configs.weaponCode, true);
                }
            } catch (e) {}
        }

        function checkPlace(id, radian) {
            try {
                var item = items.list[player.items[id]];
                var tmpS = player.scale + item.scale + (item.placeOffset || 0);
                var tmpX = player.x2 + tmpS * Math.cos(radian);
                var tmpY = player.y2 + tmpS * Math.sin(radian);
                if (objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, player)) {
                    if (player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (config.isSandbox ? 99 : item.group.limit ? item.group.limit : 99)) {
                        selectToBuild(player.items[id]);
                        sendAtck(1, radian);
                        selectWeapon(configs.weaponCode, true);
                    }
                }
            } catch (e) {}
        }
        // ADD NEW PLAYER:
        function addPlayer(data, isYou) {
            var tmpPlayer = findPlayerByID(data[0]);
            if (!tmpPlayer) {
                tmpPlayer = new Player(data[0],data[1],config,UTILS,projectileManager,objectManager,players,ais,items,hats,accessories);
                players.push(tmpPlayer);
            }
            tmpPlayer.spawn(isYou ? moofoll : null);
            tmpPlayer.visible = false;
            tmpPlayer.x2 = undefined;
            tmpPlayer.y2 = undefined;
            tmpPlayer.x3 = undefined;
            tmpPlayer.y3 = undefined;
            tmpPlayer.setData(data);
            if (isYou) {
                player = tmpPlayer;
                camX = player.x;
                camY = player.y;
                updateItems();
                updateStatusDisplay();
                updateAge();
                updateUpgrades(0);
                gameUI.style.display = "block";
                updateItemCountHTML();
                if (getEl("tryhard").checked) {
                    textManager.showText(player.x, player.y, 50, 0.5, 500, "Ping: " + window.pingTime, "#fff");
                }
                getEl("priXP").innerHTML = "Primary XP: 0 / not found";
                getEl("secXP").innerHTML = "Secondary XP: 0 / not found";
                setTimeout(()=>{
                    for (let i = 0; i < healthBased(); i++) {
                        place(0, getAttackDir());
                    }
                }, 200);
            }
        }
        // REMOVE PLAYER:
        function removePlayer(id) {
            for (var i = 0; i < players.length; i++) {
                if (players[i].id == id) {
                    if (getEl("enemyradar" + players[i].sid)) {
                        getEl("enemyradar" + players[i].sid).remove();
                    }
                    players.splice(i, 1);
                    break;
                }
            }
        }
        // UPDATE PLAYER ITEM VALUES:
        let isItemSetted = [];

        function updateItemCountHTML(index=undefined) {
            for (let i = 0; i < items.list.length; ++i) {
                let id = items.list[i].group.id;
                let tmpI = items.weapons.length + i;
                if (!isItemSetted[tmpI]) {
                    isItemSetted[tmpI] = document.createElement("div");
                    isItemSetted[tmpI].id = "itemCount" + tmpI;
                    getEl("actionBarItem" + tmpI).appendChild(isItemSetted[tmpI]);
                    isItemSetted[tmpI].style = `
                    display: block;
                    position: absolute;
                    padding-left: 5px;
                    font-size: 2em;
                    color: #fff;
                    `;
                    if (i < 3) {
                        isItemSetted[tmpI].innerHTML = Math.floor(player.food / items.list[i].req[1]);
                    } else {
                        isItemSetted[tmpI].innerHTML = player.itemCounts[id] || 0;
                    }
                } else {
                    if (index == id) {
                        isItemSetted[tmpI].innerHTML = player.itemCounts[index] || 0;
                    }
                    if (index == undefined) {
                        if (i < 3) {
                            isItemSetted[tmpI].innerHTML = Math.floor(player.food / items.list[i].req[1]);
                        }
                    }
                }
                if (getEl("visual").value == "0" || getEl("visual").value == "ae") {
                    if (isItemSetted[tmpI].style.display == "block") {
                        isItemSetted[tmpI].style.display = "none";
                    }
                } else {
                    if (isItemSetted[tmpI].style.display == "none") {
                        isItemSetted[tmpI].style.display = "block";
                    }
                }
            }
        }

        function updateItemCounts(index, value) {
            if (player) {
                player.itemCounts[index] = value;
                updateItemCountHTML(index);
            }
        }
        // UPDATE PLAYER VALUE:
        function updatePlayerValue(index, value, updateView) {
            if (player) {
                player[index] = value;
                if (index == "food") {
                    for (let i = 0; i < 3; i++) {
                        let tmpI = items.weapons.length + i;
                        getEl("itemCount" + tmpI).innerHTML = Math.floor(player.food / items.list[i].req[1]);
                    }
                } else if (index == "wood") {} else if (index == "stone") {} else if (index == "kills") {
                    if (getEl("ohio").checked) {
                        ahhhhhh.play();
                    }
                }
                if (index == "food" || index == "wood" || index == "stone") {
                    let XP = value - parseFloat(getEl(index + "Display").innerText);
                    if (XP > 0) {
                        doNextTick(()=>{
                            player.addWeaponXP(XP);
                        }
                        );
                    }
                }
                if (updateView)
                    updateStatusDisplay();
            }
        }
        // ADVANCED:
        function applCxC(value) {
            if (player.health == 100)
                return 0;
            if (player.skinIndex != 45 && player.skinIndex != 56) {
                return Math.ceil(value / items.list[player.items[0]].healing);
            }
            return 0;
        }
        function healthBased() {
            if (player.health == 100)
                return 0;
            if (player.skinIndex != 45 && player.skinIndex != 56) {
                return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
            }
            return 0;
        }

        function calcDmg(value) {
            return value * player.skinIndex == 6 ? 0.75 : 1;
        }
        // LATER:
        function predictHeal() {}
        // UPDATE HEALTH:
        let healType = undefined;
        let guessEmpAnti = false;
        let doEmpAntiInsta = false;
        let judgeAtNextTick = false;
        let nearSpike = [];

        function updateHealth(sid, value) {
            tmpObj = findPlayerBySID(sid);
            if (tmpObj) {
                let tmpHealth = tmpObj.health;
                tmpObj.health = value;
                if (tmpHealth < tmpObj.health) {
                    if (tmpObj.hitTime) {
                        let timeSinceHit = Date.now() - tmpObj.hitTime;
                        let tmpShame = tmpObj.shameCount;
                        let tickiy = ticks.time.filter(e => e == "lag");
                        let pingSince = Math.max(120, window.pingTime);
                        tmpObj.hitTime = 0;
                        if (timeSinceHit <= (tickiy.length >= 2 ? 120 : 120)) {
                            tmpObj.shameCount += 1;
                            if (instaC.isTrue) {
                                tmpObj.healSid = Math.min(3, tmpObj.healSid + 1);
                            }
                            if (tmpObj.shameCount > tmpObj.maxShame) {
                                tmpObj.maxShame = tmpObj.shameCount;
                            }
                        } else {
                            tmpObj.shameCount = Math.max(0, tmpObj.shameCount - 2);
                            if (instaC.isTrue) {
                                tmpObj.healSid = Math.max(-1, tmpObj.healSid - 1);
                            }
                        }
                        if (tmpObj != player) {
                            if (tmpShame < tmpObj.shameCount) {//                                tmpObj.dangerShame = tmpObj.shameCount;
                            }
                        } else {
                            healLag = timeSinceHit - window.pingTime;
                        }
                    }
                } else if (tmpHealth > tmpObj.health) {
                    tmpObj.hitTime = Date.now();
                    tmpObj.hitted = true;
                    tmpObj.damaged = true;
                    let damage = tmpHealth - tmpObj.health;
                    if (tmpObj.skinIndex == 7 && (damage == 5 || (tmpObj.tailIndex == 13 && damage == 2))) {
                        tmpObj.bTick = ticks.tick;
                        if (tmpObj == player) {
                            reSyncBull = false;
                        }
                    }
                    //                               console.log(damage);
                    if (tmpObj == player) {
                        if (getEl("simpleheal").checked) {
                            simpleAutoHealer(tmpObj, damage);
                        } else {
                            autoHealer(tmpObj, damage);
                        }
                    }
                }
            }
        }

        let stopHealing = false;
        function healIntrap(tmpObj, value) {
            let pingHeal = function() {
                return Math.max(0, 180 - window.pingTime);
            };
            let normalMS = 70;
            let goodMS = 125;
            if (true) {
                /*if (!stopHealing) {
                    stopHealing = true;
                    setTimeout(()=> {
                        stopHealing = false;
                    }, config.tickRate * 1.5);
                    for (let i = 0; i < healthBased(); i++) {
                        place(0, getAttackDir());
                    }
                }*/
                (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                    for (let i = 0; i < applCxC(value); i++) {
                        place(0, getAttackDir());
                    }
                }
                , getEl("tickheal").checked ? 2 : pingHeal());
            } else {
                (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                    for (let i = 0; i < applCxC(value); i++) {
                        place(0, getAttackDir());
                    }
                }
                , getEl("tickheal").checked ? 2 : pingHeal());
            }
        }
        let backupAnti = [];
        let hittedTime = Date.now();

        function autoHealer(tmpObj, value) {
            let pingHeal = function() {
                return Math.max(0, 180 - window.pingTime);
            };
            let normalMS = 70;
            let goodMS = 125;
            let antiInsta = false;
            let findAttacker = undefined;
            if (true) {
                if (near.dist2 <= 300) {
                    if (value >= 20 && (Date.now() - hittedTime >= 180 || Date.now() - hittedTime <= 60)) {
                        if (tmpObj.shameCount < tmpObj.dangerShame) {
                            for (let i = 0; i < applCxC(value); i++) {
                                place(0, getAttackDir());
                            }
                        } else {
                            (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                                for (let i = 0; i < applCxC(value); i++) {
                                    place(0, getAttackDir());
                                }
                            }
                            , getEl("tickheal").checked ? 2 : pingHeal());
                        }
                    } else {
                        if (traps.in) {
                            healIntrap(tmpObj, value);
                        } else {
                            (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                                for (let i = 0; i < applCxC(value); i++) {
                                    place(0, getAttackDir());
                                }
                            }
                            , getEl("tickheal").checked ? 2 : pingHeal());
                        }
                    }
                    if (player.skinIndex == 11) {
                        if (value >= 30) {
                            instaC.isCounter = true;
                        }
                    }
                    if (value >= 20) {
                        hittedTime = Date.now();
                        judgeAtNextTick = true;
                    }
                } else {
                    if (traps.in) {
                        healIntrap(tmpObj, value);
                    } else {
                        (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                            for (let i = 0; i < applCxC(value); i++) {
                                place(0, getAttackDir());
                            }
                        }
                        , getEl("tickheal").checked ? 2 : pingHeal());
                    }
                }
            }
        }

        function simpleAutoHealer(tmpObj, value) {
            let pingHeal = function() {
                return Math.max(0, 170 - window.pingTime);
            };
            let normalMS = 70;
            let goodMS = 125;
            let antiInsta = false;
            if (true) {
                if (nears.length) {
                    if (value >= 20) {
                        judgeAtNextTick = true;
                    }
                    for (let i = 0; i < nears.length; i++) {
                        let nearEnemy = nears[i];
                        let findAttacker = [];
                        let checkAnti = value >= (tmpObj.skinIndex == 6 ? 25 : 10) && (nearEnemy.secondaryIndex == undefined || nearEnemy.primaryIndex == undefined ? true : nearEnemy.reloads[nearEnemy.primaryIndex] == 0);
                        if (checkAnti) {
                            antiInsta = true;
                        }
                    }
                    if (antiInsta) {
                        if (tmpObj.shameCount < tmpObj.dangerShame) {
                            for (let i = 0; i < applCxC(value); i++) {
                                place(0, getAttackDir());
                            }
                        } else {
                            (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                                for (let i = 0; i < applCxC(value); i++) {
                                    place(0, getAttackDir());
                                }
                            }
                            , getEl("tickheal").checked ? 2 : pingHeal());
                        }
                    } else {
                        (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                            for (let i = 0; i < applCxC(value); i++) {
                                place(0, getAttackDir());
                            }
                        }
                        , getEl("tickheal").checked ? 2 : pingHeal());
                    }
                    if (player.skinIndex == 11) {
                        if (value >= 30) {
                            instaC.isCounter = true;
                        }
                    }
                } else {
                    (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                        for (let i = 0; i < applCxC(value); i++) {
                            place(0, getAttackDir());
                        }
                    }
                    , getEl("tickheal").checked ? 2 : pingHeal());
                }
            }
        }
        // CALC DAMAGE:
        function checkCanInsta(nobull) {
            let totally = 0;
            if (player.alive) {
                let primary = {
                    weapon: player.weapons[0],
                    variant: player.primaryVariant,
                    dmg: player.weapons[0] == undefined ? 0 : items.weapons[player.weapons[0]].dmg,
                };
                let secondary = {
                    weapon: player.weapons[1],
                    variant: player.secondaryVariant,
                    dmg: player.weapons[1] == undefined ? 0 : items.weapons[player.weapons[1]].Pdmg,
                };
                let bull = player.skins[7] && !nobull ? 1.5 : 1;
                let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1;
                if (primary.weapon != undefined && player.reloads[primary.weapon] == 0) {
                    totally += primary.dmg * pV * bull;
                }
                if (secondary.weapon != undefined && player.reloads[secondary.weapon] == 0) {
                    totally += secondary.dmg;
                }
                if (player.skins[53] && player.reloads[53] == 0 && near.skinIndex != 22) {
                    totally += 25;
                }
                totally *= near.skinIndex == 6 ? 0.75 : 1;
                return totally;
            }
            return 0;
        }

        function getDamageThreat(tmpObj) {
            tmpObj.instaThreat = 0;
            if (isTeam(tmpObj)) {
                let primary = {
                    weapon: tmpObj.primaryIndex,
                    variant: tmpObj.primaryVariant,
                    dmg: tmpObj.primaryIndex == undefined ? 45 : items.weapons[tmpObj.primaryIndex].dmg,
                };
                let secondary = {
                    weapon: tmpObj.secondaryIndex,
                    variant: tmpObj.secondaryVariant,
                    dmg: tmpObj.secondaryIndex == undefined ? 50 : items.weapons[tmpObj.secondaryIndex].Pdmg,
                };
                let bull = tmpObj.skinIndex == 7 ? 1.5 : 1;
                let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
                if (primary.weapon != undefined && tmpObj.reloads[primary.weapon] == 0) {
                    tmpObj.instaThreat += primary.dmg * pV * bull;
                }
                if (secondary.weapon != undefined && tmpObj.reloads[secondary.weapon] == 0) {
                    tmpObj.instaThreat += secondary.dmg;
                }
                if (tmpObj.reloads[53] === 0) {
                    tmpObj.instaThreat += 25;
                }
                tmpObj.instaThreat *= player.skinIndex == 6 ? 0.75 : 1;
            }
        }
        let predictDamage = 0;

        function guessDamagePrediction() {
            predictDamage = 0;
            if (enemy.length) {
                if (near.dist2 <= 300) {
                    if (configs.antiBull2 > 0 && near.skinIndex == 11) {
                        predictDamage += items.weapons[player.weapons[0]].dmg * 0.45;
                    }
                    if (configs.antiBull2 > 0 && near.tailIndex == 21) {
                        predictDamage += items.weapons[player.weapons[0]].dmg * 0.25;
                    }
                    predictDamage *= player.skinIndex == 6 ? 0.75 : 1;
                    if ((ticks.tick - player.bTick) % config.serverUpdateRate === 0 && player.shameCount > 0) {
                        predictDamage += 5;
                        if (player.tailIndex == 13) {
                            predictDamage -= 3;
                        }
                    }
                }
            }
        }
        // RENDER TRACER / CREDIT TO NEKOSAN:
        function addUser(tmpObj) {
            let center = {
                x: screenWidth / 2,
                y: screenHeight / 2,
            };
            let rad = UTILS.getDirect(tmpObj, player, 2, 2)
            let alpha = Math.min(1, (UTILS.getDistance(0, 0, player.x2 - tmpObj.x2, (player.y2 - tmpObj.y2) * (16 / 9)) * 100) / (config.maxScreenHeight / 2) / center.y);
            let dist = center.y * alpha;
            let tmpX = center.x + dist * Math.cos(rad) - 20 / 2;
            let tmpY = center.y + dist * Math.sin(rad) - 20 / 2;
            if (!getEl("enemyradar" + tmpObj.sid)) {
                let addRadar = document.createElement("div");
                addRadar.id = "enemyradar" + tmpObj.sid;
                document.body.append(addRadar);
                addRadar.style = `
                display: none;
                position: absolute;
                left: 0;
                top: 0;
                color: #fff;
                width: 0;
                height: 0;
                border-style: solid;
                border-width: 10px 0 10px 20px;
                border-color: transparent transparent transparent #fff;
                `;
            }
            if (getEl("enemyradar" + tmpObj.sid)) {
                getEl("enemyradar" + tmpObj.sid).style.left = tmpX + "px";
                getEl("enemyradar" + tmpObj.sid).style.top = tmpY + "px";
                getEl("enemyradar" + tmpObj.sid).style.display = !isTeam(tmpObj) ? "block" : "none";
                getEl("enemyradar" + tmpObj.sid).style.opacity = alpha;
                getEl("enemyradar" + tmpObj.sid).style.transform = "rotate(" + UTILS.toAng(rad) + "deg)";
            }
        }
        // UPDATE PLAYER DATA:
        let enemy = [];
        let nears = [];
        let near = [];
        let millC = {
            x: undefined,
            y: undefined,
            size: function(size) {
                return size * 1.45;
            },
            dist: function(size) {
                return size * 1.8;
            },
            active: config.isSandbox ? true : false,
            count: 0,
        };
        //1.4201
        let doAgeInsta = false;
        let instaC = {
            wait: false,
            can: false,
            isTrue: false,
            nobull: false,
            isCounter: false,
            abCount: 0,
            changeType: function(type) {
                instaC.wait = false;
                instaC.isTrue = true;
                autoAim = true;
                if (type == "rev") {
                    selectWeapon(player.weapons[1]);
                    buyEquip(53, 0);
                    buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 21, 1);
                    sendAutoGather();
                    setTickout(()=>{
                        selectWeapon(player.weapons[0]);
                        buyEquip(7, 0);
                        buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 18, 1);
                        setTickout(()=>{
                            sendAutoGather();
                            instaC.isTrue = false;
                            autoAim = false;
                        }
                        , 1);
                    }
                    , 1);
                } else if (type == "nobull") {
                    selectWeapon(player.weapons[0]);
                    buyEquip(getEl("combat").value == "fz" ? 11 : 6, 0);
                    buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 18, 1);
                    sendAutoGather();
                    setTickout(()=>{
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        buyEquip(getEl("combat").value == "ae" ? 11 : getEl("combat").value == "hans" ? 0 : 21, 1);
                        setTickout(()=>{
                            sendAutoGather();
                            instaC.isTrue = false;
                            autoAim = false;
                        }
                        , 1);
                    }
                    , 1);
                } else if (type == "normal") {
                    selectWeapon(player.weapons[0]);
                    buyEquip(7, 0);
                    buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 18, 1);
                    sendAutoGather();
                    setTickout(()=>{
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        buyEquip(getEl("combat").value == "ae" ? 11 : getEl("combat").value == "hans" ? 0 : 21, 1);
                        setTickout(()=>{
                            sendAutoGather();
                            instaC.isTrue = false;
                            autoAim = false;
                        }
                        , 1);
                    }
                    , 1);
                } else {
                    setTimeout(()=>{
                        instaC.isTrue = false;
                        autoAim = false;
                    }
                    , 50);
                }
            },
            counterType: function() {
                instaC.isTrue = true;
                autoAim = true;
                selectWeapon(player.weapons[0]);
                buyEquip(7, 0);
                buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 21, 1);
                sendAutoGather();
                setTickout(()=>{
                    if ((getEl("countertur").checked && player.reloads[53] == 0 && player.skins[53]) || (getEl("countersec").checked && player.reloads[player.weapons[1]] == 0 && player.weapons[1])) {
                        if (getEl("countersec").checked && player.reloads[player.weapons[1]] == 0 && player.weapons[1]) {
                            selectWeapon(player.weapons[1]);
                        }
                        if (getEl("countertur").checked && player.reloads[53] == 0 && player.skins[53]) {
                            buyEquip(53, 0);
                        } else {
                            buyEquip(6, 0);
                        }
                        buyEquip(getEl("combat").value == "ae" ? 11 : getEl("combat").value == "hans" ? 0 : 21, 1);
                        setTickout(()=>{
                            sendAutoGather();
                            instaC.isTrue = false;
                            autoAim = false;
                        }
                        , 1);
                    } else {
                        sendAutoGather();
                        instaC.isTrue = false;
                        autoAim = false;
                    }
                }
                , 1);
            },
            spikeTickType: function() {
                instaC.isTrue = true;
                autoAim = true;
                selectWeapon(player.weapons[0]);
                buyEquip(7, 0);
                buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 21 : 18, 1);
                sendAutoGather();
                setTickout(()=>{
                    sendAutoGather();
                    instaC.isTrue = false;
                    autoAim = false;
                }
                , 1);
            },
            rangeType: function() {
                instaC.isTrue = true;
                autoAim = true;
                if (player.weapons[0] != 4 && player.weapons[1] == 9 && player.age >= 9 && doAgeInsta) {
                    rangeBackup.push(near.dist2);
                    doAgeInsta = false;
                    selectWeapon(player.weapons[1]);
                    buyEquip(53, 0);
                    buyEquip(21, 1);
                    sendAutoGather();
                    setTickout(()=>{
                        sendUpgrade(12);
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        buyEquip(21, 1);
                        setTickout(()=>{
                            sendUpgrade(15);
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            buyEquip(21, 1);
                            setTickout(()=>{
                                sendAutoGather();
                                instaC.isTrue = false;
                                autoAim = false;
                            }
                            , 1);
                        }
                        , 1);
                    }
                    , 1);
                } else {
                    selectWeapon(player.weapons[1]);
                    if (player.reloads[53] == 0 && near.dist2 <= 700 && near.skinIndex != 22) {
                        buyEquip(53, 0);
                    } else {
                        buyEquip(20, 0);
                    }
                    buyEquip(11, 1);
                    sendAutoGather();
                    setTickout(()=>{
                        sendAutoGather();
                        instaC.isTrue = false;
                        autoAim = false;
                    }
                    , 1);
                }
            },
        };
        let autoAim = false;
        let autos = {
            reloaded: false,
        };
        let traps = {
            in: false,
            aim: Number.MAX_VALUE,
            healths: 69,
        };
        let ticks = {
            tick: 0,
            delay: 0,
            time: [],
            manage: [],
        };

        function checkTestCoord(tmpObj) {
            let x = tmpObj.x2 - tmpObj.x1;
            let y = tmpObj.y2 - tmpObj.y1;
            tmpObj.x3 = tmpObj.x2 + x;
            tmpObj.y3 = tmpObj.y2 + y;
        }
        let oldXY = {
            x: undefined,
            y: undefined,
        };
        let autoQ = false;

        function isTeam(tmpObj) {
            return (tmpObj == player || (tmpObj.team && tmpObj.team == player.team));
        }
        let turretEmp = 0;
        let waitTicks = [];
        let anti0Tick = 0;
        let syncCount = 0;
        let nerdChat = ["Don't care", "didin't ask", "cry about it", "stay mad", "get real", "L", "mad seethe cope harder", "hoes mad", "basic", "skill issue", "ratio", "you fell off", "the audacity", "triggered", "any askers", "replled", "get a life", "ok and?", "cringe", "touch grass", "donowalled", "not based", "not funny didnt laugh", "*you're", "grammar issues", "go outside", "get good", "reported", "ad hominem", "GG!", "ask deez", "ez clap", "straight cash", "ratio again", "final ratio", "problematic", "furry lover", "retard"];
        let nerdSpam = false;
        function updatePlayers(data) {
            enemy = [];
            nears = [];
            near = [];
            ticks.tick++;
            ticks.time.push(Date.now() - ticks.delay <= 50 || Date.now() - ticks.delay >= 175 ? "lag" : 1);
            if (ticks.tick % 10 === 0) {
                ticks.time = [];
            }
            if (ticks.tick % 300 === 0) {
                if (getEl("visual").value == "fz") {
                    maxPing = window.pingTime;
                    minPing = window.pingTime;
                }
            }
            ticks.delay = Date.now();
            var tmpTime = Date.now();
            for (let i = 0; i < players.length; ++i) {
                players[i].forcePos = !players[i].visible;
                players[i].visible = false;
                if (getEl("enemyradar" + players[i].sid)) {
                    getEl("enemyradar" + players[i].sid).style.display = "none";
                }
            }
            for (let i = 0; i < data.length; ) {
                tmpObj = findPlayerBySID(data[i]);
                if (tmpObj) {
                    tmpObj.t1 = tmpObj.t2 === undefined ? tmpTime : tmpObj.t2;
                    tmpObj.t2 = tmpTime;
                    tmpObj.x1 = tmpObj.x;
                    tmpObj.y1 = tmpObj.y;
                    tmpObj.x2 = data[i + 1];
                    tmpObj.y2 = data[i + 2];
                    checkTestCoord(tmpObj);
                    tmpObj.aim2 = UTILS.getDirect(tmpObj, player, 2, 2);
                    tmpObj.dist2 = UTILS.getDist(tmpObj, player, 2, 2);
                    tmpObj.aim3 = UTILS.getDirect(tmpObj, player, 3, 3);
                    tmpObj.dist3 = UTILS.getDist(tmpObj, player, 3, 3);
                    tmpObj.d1 = tmpObj.d2 === undefined ? data[i + 3] : tmpObj.d2;
                    tmpObj.d2 = data[i + 3];
                    tmpObj.dt = 0;
                    tmpObj.rt = 0;
                    tmpObj.buildIndex = data[i + 4];
                    tmpObj.weaponIndex = data[i + 5];
                    tmpObj.weaponVariant = data[i + 6];
                    tmpObj.team = data[i + 7];
                    tmpObj.isLeader = data[i + 8];
                    tmpObj.skinIndex = data[i + 9];
                    tmpObj.tailIndex = data[i + 10];
                    tmpObj.iconIndex = data[i + 11];
                    tmpObj.zIndex = data[i + 12];
                    tmpObj.visible = true;
                    if (tmpObj == player) {
                        tmpObj.syncThreats = 0;
                        tmpObj.primaryIndex = tmpObj.weapons[0];
                        tmpObj.secondaryIndex = tmpObj.weapons[1];
                        (!millC.x || !oldXY.x) && (millC.x = oldXY.x = tmpObj.x2);
                        (!millC.y || !oldXY.y) && (millC.y = oldXY.y = tmpObj.y2);
                    }
                    if (tmpObj.weaponIndex < 9) {
                        if (tmpObj != player) {
                            tmpObj.primaryIndex = tmpObj.weaponIndex;
                        }
                        tmpObj.primaryVariant = tmpObj.weaponVariant;
                    } else if (tmpObj.weaponIndex > 8) {
                        if (tmpObj != player) {
                            tmpObj.secondaryIndex = tmpObj.weaponIndex;
                        }
                        tmpObj.secondaryVariant = tmpObj.weaponVariant;
                    }
                }
                i += 13;
            }
            if (waitTicks.length) {
                waitTicks.forEach((ajaj)=>{
                    ajaj();
                }
                );
                waitTicks = [];
            }
            if (runAtNextTick.length) {
                runAtNextTick.forEach((tmp)=>{
                    checkProjectileHolder(...tmp);
                }
                );
                runAtNextTick = [];
            }
            syncCount = 0;
            for (let i = 0; i < data.length; ) {
                tmpObj = findPlayerBySID(data[i]);
                if (tmpObj) {
                    if (tmpObj.doTickUpdate) {
                        tmpObj.doTickUpdate = false;
                    }
                    if (!isTeam(tmpObj)) {
                        enemy.push(tmpObj);
                        if (tmpObj.dist2 <= (items.weapons[tmpObj.primaryIndex == undefined ? 5 : tmpObj.primaryIndex].range + (player.scale * 3)) + (getEl("addictdist").checked && window.pingTime >= 90 ? (window.pingTime / 3) : 0)) {
                            nears.push(tmpObj);
                        }
                        if (getEl("visual").value == "cele" || getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                            addUser(tmpObj);
                        }
                    }
                    if (tmpObj.pCount > -1) {
                        if ((ticks.tick - tmpObj.bTick) % config.serverUpdateRate === 0) {
                            tmpObj.pCount--;
                        }
                    }
                    tmpObj.oldReloads[53] = tmpObj.reloads[53];
                    if (tmpObj.shooting[53]) {
                        tmpObj.shooting[53] = 0;
                        tmpObj.reloads[53] = 2500 - config.tickRate;
                        tmpObj.oldReloads[53] = tmpObj.reloads[53];
                        if (getEl("antitick").checked && !isTeam(tmpObj)) {
                            if (tmpObj.primaryIndex == 5 && tmpObj.primaryVariant >= 2 && tmpObj.dist2 >= 175 && tmpObj.dist2 <= 275) {
                                anti0Tick = 2;
                            }
                        }
                    } else {
                        if (tmpObj.reloads[53] > 0) {
                            tmpObj.reloads[53] = Math.max(0, tmpObj.reloads[53] - config.tickRate);
                            if (tmpObj.reloads[53] <= 0) {
                                let tmp = tmpObj;
                                tmp.turretReloaded = true;
                                setTickout(()=>{
                                    tmp.turretReloaded = false;
                                }
                                , 1);
                            }
                        }
                    }
                    tmpObj.oldReloads[tmpObj.primaryIndex == undefined ? tmpObj.weaponIndex : tmpObj.primaryIndex] = tmpObj.reloads[tmpObj.primaryIndex == undefined ? tmpObj.weaponIndex : tmpObj.primaryIndex];
                    tmpObj.oldReloads[tmpObj.secondaryIndex == undefined ? tmpObj.weaponIndex : tmpObj.secondaryIndex] = tmpObj.reloads[tmpObj.secondaryIndex == undefined ? tmpObj.weaponIndex : tmpObj.secondaryIndex];
                    if (tmpObj.gathering || tmpObj.shooting[1]) {
                        if (tmpObj.gathering) {
                            tmpObj.gathering = 0;
                            tmpObj.reloads[tmpObj.gatherIndex] = items.weapons[tmpObj.gatherIndex].speed * (tmpObj.skinIndex == 20 ? 0.78 : 1);
                            tmpObj.oldReloads[tmpObj.gatherIndex] = tmpObj.reloads[tmpObj.gatherIndex];
                        }
                        if (tmpObj.shooting[1]) {
                            tmpObj.shooting[1] = 0;
                            tmpObj.reloads[tmpObj.shootIndex] = items.weapons[tmpObj.shootIndex].speed * (tmpObj.skinIndex == 20 ? 0.78 : 1);
                            tmpObj.oldReloads[tmpObj.shootIndex] = tmpObj.reloads[tmpObj.shootIndex];
                            if (tmpObj != player && player.team && tmpObj.team == player.team && player.weapons[1] == 15 && tmpObj.shootIndex == 15) {
                                syncCount++;
                            }
                        }
                    } else {
                        if (tmpObj.buildIndex < 0) {
                            if (tmpObj.reloads[tmpObj.weaponIndex] > 0) {
                                tmpObj.reloads[tmpObj.weaponIndex] = Math.max(0, tmpObj.reloads[tmpObj.weaponIndex] - config.tickRate);
                                if (tmpObj.weaponIndex == tmpObj.primaryIndex) {
                                    if (tmpObj.reloads[tmpObj.primaryIndex] <= 0) {
                                        if (tmpObj == player) {
                                            configs.antiBull2++;
                                            setTickout(()=>{
                                                configs.antiBull2--;
                                            }
                                            , 1);
                                        } else {
                                            if (!isTeam(tmpObj) && tmpObj.dist2 <= items.weapons[tmpObj.primaryIndex ? tmpObj.primaryIndex : 5].range + player.scale * 1.8 + window.pingTime / 2) {
                                                configs.antiBull++;
                                                setTickout(()=>{
                                                    configs.antiBull--;
                                                }
                                                , 1);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    getDamageThreat(tmpObj);
                }
                i += 13;
            }
            myConfig.x = player.x2;
            myConfig.y = player.y2;
            if (ticks.tick % 24 === 0) {
                myConfig.sync = true;
            } else {
                myConfig.sync = false;
            }
            if (enemy.length) {
                near = enemy.sort(function(tmp1, tmp2) {
                    return (UTILS.getDist(tmp1, player, 2, 2) - UTILS.getDist(tmp2, player, 2, 2));
                })[0];
                myNearAim = function(o) {
                    return UTILS.getDirect(near, o, 2, 0);
                }
                ;
            } else {
                myNearAim = function(nothing) {
                    return undefined;
                }
                ;
            }
            try {

                nears.forEach((e)=>{
                    if (e.primaryIndex != undefined && e.reloads[e.primaryIndex] == 0 && e.primaryIndex != undefined && e.reloads[e.primaryIndex] == 0) {
                        player.syncThreats++;
                    }
                });
                /*players.forEach((e)=>{
                    let find = nears.find(araaa=>araaa == e);
                    if (find) {
                        if (!e.finded) {
                            e.finded = 1;
                            player.syncThreats++;
                            setTickout(()=>{
                                player.syncThreats--;
                            }
                            , 2);
                        }
                    } else {
                        e.finded = 0;
                    }
                }
                );*/
                turretEmp = 0;
                gameObjects.filter((e)=>e.active && e.doUpdate).forEach((tmp)=>{
                    if (tmp.shootted) {
                        tmp.shootted = 0;
                        tmp.shootReload = 2200 - config.tickRate;
                    } else {
                        if (tmp.shootReload > 0) {
                            tmp.shootReload = Math.max(0, tmp.shootReload - config.tickRate);
                            if (tmp.shootReload <= 0) {
                                tmp.shootReload = 2200;
                                if (player.sid != tmp.owner.sid && !findAllianceBySid(tmp.owner.sid) && UTILS.getDist(tmp, player, 0, 2) <= 735) {
                                    turretEmp++;
                                }
                            }
                        }
                    }
                }
                );
                if ((checkCanInsta(true) >= 100 ? checkCanInsta(true) : checkCanInsta(false)) >= (player.weapons[1] == 10 ? 95 : 100) && near.dist2 <= items.weapons[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]].range + near.scale * 1.8 && instaC.wait && !instaC.isTrue && !configs.waitHit && player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0 && player.reloads[53] == 0) {
                    if (checkCanInsta(true) >= 100) {
                        instaC.nobull = true;
                    } else {
                        instaC.nobull = false;
                    }
                    instaC.can = true;
                } else {
                    instaC.can = false;
                }
                guessDamagePrediction();
                //                ranHat = freeHats[ticks.tick % freeHats.length];
                // TIMEOUT:
                if (ticks.manage[ticks.tick]) {
                    ticks.manage[ticks.tick].forEach((doit)=>{
                        doit();
                    }
                    );
                }
                if (player.alive) {
                    if (player.syncThreats >= 2 && getEl("antisync").checked && !antiSync) {
                        if (getEl("combat").value == "me" || getEl("combat").value == "fz" || getEl("combat").value == "zyenith") {
                            io.send("ch", getEl("combat").value == "me" ? "sync threat" : "sync detect test");
                        }
                        antiSyncHealing(3);
                    }
                    if (judgeAtNextTick) {
                        judgeAtNextTick = false;
                        if (getEl("soldierempanti").checked && enemy.length && near.reloads[53] <= config.tickRate && (near.secondaryIndex != 10 && near.secondaryIndex != 11 && near.secondaryIndex != 14)) {
                            doEmpAntiInsta = true;
                        }
                    }
                    if (getEl("autoq").checked && (doAutoQ || getEl("evautoq").checked)) {
                        getEl("healer").innerHTML = "Healer: autoQ";
                        if (player.shameCount < 4 && near.dist2 <= 300 && near.reloads[near.primaryIndex] <= config.tickRate * (window.pingTime >= 200 ? 2 : 1)) {
                            autoQ = true;
                            place(0, getAttackDir());
                        } else {
                            if (autoQ) {
                                place(0, getAttackDir());
                            }
                            autoQ = false;
                        }
                    } else {
                        if (autoQ) {
                            //place(0, getAttackDir());
                        }
                        autoQ = false;
                        if (nears.length >= 2) {
                            getEl("healer").innerHTML = "Healer: " + nears.length + "v1";
                        } else {
                            getEl("healer").innerHTML = "Healer: " + (window.pingTime <= 85 ? "Low Ping" : "High Ping");
                        }
                    }
                    // INSTAS:
                    if (syncCount >= parseInt(getEl("synccount").value)) {
                        if (getEl("sync").checked) {
                            doSync = true;
                        }
                    }
                    if (clicks.middle || doSync || withSync) {
                        if (doSync) {
                            doSync = false;
                        }
                        if (withSync) {
                            withSync = false;
                        }
                        if (!instaC.isTrue && !instaC.can && player.reloads[player.weapons[1]] == 0) {
                            instaC.rangeType();
                        }
                    }
                    if (instaC.can) {
                        instaC.changeType(getEl("alwaysrev").checked ? "rev" : player.weapons[1] == 10 ? "rev" : instaC.nobull ? "nobull" : "normal");
                    }
                    if (instaC.isCounter) {
                        instaC.isCounter = false;
                        if (player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                            instaC.counterType();
                        }
                    }
                    if (waitSpikeTick) {
                        waitSpikeTick = false;
                        if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0) {
                            instaC.spikeTickType();
                        }
                    }
                    // MOUSE EVENT:
                    if (!clicks.middle && (clicks.left || clicks.right) && !instaC.isTrue && !instaC.can) {
                        if (player.weaponIndex != (clicks.right && getEl("grindsec").checked && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0])) {
                            selectWeapon(clicks.right && getEl("grindsec").checked && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]);
                        }
                        if (player.reloads[clicks.right && getEl("grindsec").checked && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0) {
                            io.send("7", 1);
                            setTickout(()=>{
                                io.send("7", 1);
                            }
                            , 1);
                        }
                    }
                    if (gameObjects.length) {
                        nearSpike = [];
                        nearSpike = gameObjects.filter((tmp)=>tmp.dmg && player.sid != tmp.owner.sid && !findAllianceBySid(tmp.owner.sid) && tmp.active && UTILS.getDist(tmp, player, 0, 2) < (tmp.scale + player.scale)).sort(function(a, b) {
                            return (UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2));
                        })[0];
                        let trap1 = gameObjects.filter((e)=>e.trap && e.active).sort(function(a, b) {
                            return (UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2));
                        })[0];
                        if (trap1) {
                            traps.aim = UTILS.getDirect(trap1, player, 0, 2);
                            if (player.sid != trap1.owner.sid && !findAllianceBySid(trap1.owner.sid) && Math.hypot(trap1.y - player.y2, trap1.x - player.x2) <= 50 && getEl("abactive").checked) {
                                traps.in = true;
                                traps.healths = trap1.buildHealth;
                                if (!instaC.isTrue && !clicks.middle && !clicks.left && !clicks.right) {
                                    if (player.weaponIndex != player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]) {
                                        selectWeapon(trap1.buildHealth > items.weapons[player.weapons[0]].dmg && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]);
                                    }
                                    if (player.reloads[trap1.buildHealth > items.weapons[player.weapons[0]].dmg && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 && (trap1.buildHealth > items.weapons[player.weapons[0]].dmg && player.weapons[1] == 10 ? true : !configs.waitHit)) {
                                        configs.waitHit = true;
                                        io.send("7", 1);
                                        setTickout(()=>{
                                            io.send("7", 1);
                                            configs.waitHit = false;
                                        }
                                        , 1);
                                    }
                                }
                            } else {
                                traps.in = false;
                            }
                        } else {
                            traps.in = false;
                        }
                    } else {
                        traps.in = false;
                    }
                    // RELOADS:
                    if (!instaC.isTrue && player.weapons[1] && !clicks.left && !clicks.right && !traps.in) {
                        if ((player.weapons[0] == 3 || player.weapons[0] == 4 || player.weapons[0] == 5) && (player.weapons[1] == 10 || player.weapons[1] == 14)) {
                            if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0) {
                                if (!autos.reloaded) {
                                    autos.reloaded = true;
                                    if (player.weaponIndex != player.weapons[1]) {
                                        selectWeapon(player.weapons[1]);
                                    }
                                }
                            } else {
                                autos.reloaded = false;
                                if (player.reloads[player.weapons[0]] > 0) {
                                    if (player.weaponIndex != player.weapons[0]) {
                                        selectWeapon(player.weapons[0]);
                                    }
                                } else if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] > 0) {
                                    if (player.weaponIndex != player.weapons[1]) {
                                        selectWeapon(player.weapons[1]);
                                    }
                                }
                            }
                        } else {
                            if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0) {
                                if (!autos.reloaded) {
                                    autos.reloaded = true;
                                    if (player.weaponIndex != player.weapons[0]) {
                                        selectWeapon(player.weapons[0]);
                                    }
                                }
                            } else {
                                autos.reloaded = false;
                                if (player.reloads[player.weapons[1]] > 0) {
                                    if (player.weaponIndex != player.weapons[1]) {
                                        selectWeapon(player.weapons[1]);
                                    }
                                } else if (player.reloads[player.weapons[1]] == 0 && player.reloads[player.weapons[0]] > 0) {
                                    if (player.weaponIndex != player.weapons[0]) {
                                        selectWeapon(player.weapons[0]);
                                    }
                                }
                            }
                        }
                    }
                    // PLACES:
                    if (places.slot0 && !autoQ) {
                        place(0, getAttackDir());
                    } else if (places.slot2) {
                        place(2, getAttackDir());
                    } else if (places.slot4) {
                        place(4, getAttackDir());
                    } else if (places.slot5) {
                        place(5, getAttackDir());
                    }
                    if (!instaC.isTrue && (getEl("abplace").checked ? true : !traps.in)) {
                        autoPlace();
                    }
                    /*if (turretSpam) {
                                      if (!instaC.isTrue && !traps.in) {
                                          for (let i = -45; i <= 45; i+=90) {
                                              checkPlace(getEl("placeconfig").value, (millMoveDir + UTILS.toRad(i)) + Math.PI);
                                          }
                                      }
                                  }*/
                    try {
                        let parsed = parseFloat(getEl("placeconfig").value);
                        let objectSize = millC.size(items.list[player.items[parsed]].scale);
                        let objectDist = millC.dist(items.list[player.items[parsed]].scale);
                        if (UTILS.getDist(millC, player, 0, 2) > objectDist + items.list[player.items[parsed]].placeOffset) {
                            if (millC.active) {
                                let millDir = UTILS.getDirect(millC, player, 0, 2);
                                let plusXY = {
                                    x: millC.x,
                                    y: millC.y
                                };
                                let Boom = UTILS.getDirect(plusXY, player, 0, 2);
                                checkPlace(parsed, Boom + UTILS.toRad(objectSize));
                                checkPlace(parsed, Boom - UTILS.toRad(objectSize));
                                checkPlace(parsed, Boom);
                                millC.count = Math.max(0, millC.count - 1);
                            }
                            millC.x = player.x2;
                            millC.y = player.y2;
                        }
                    } catch (e) {}
                    // EXTRA:
                    if (storeMenu.style.display != "block" && !instaC.isTrue) {
                        // Wow This Is Real Left Right:
                        if (clicks.left || clicks.right) {
                            changeHat("click");
                            changeAcc("click");
                        } else {
                            if (traps.in) {
                                changeHat("trap");
                                changeAcc("trap");
                            } else {
                                changeHat("normal");
                                changeAcc("normal");
                            }
                        }
                    }
                    // SEND DIR:
                    if (!places.slot0 && !places.slot2 && !places.slot4 && !places.slot5 && !autoQ) {
                        let atckDir = getAttackDir();
                        if (player.dir !== atckDir) {
                            lessDir = atckDir;
                            io.send("2", atckDir);
                        }
                    }
                    if (doEmpAntiInsta) {
                        doEmpAntiInsta = false;
                    }
                    if (anti0Tick > 0) {
                        anti0Tick--;
                    }
                }
            } catch (e) {
                console.error(e);
            }
            if (autoZoom) {
                if (near.dist2 <= 1000) {
                    resetZoom();
                } else {
                    zoomVision();
                }
            } else {
                resetZoom();
            }
        }
        // dont do this or you dying
        // while(1);
        // nocap
        // GAME TICKOUT:
        function setTickout(doo, timeout) {
            if (!ticks.manage[ticks.tick + timeout]) {
                ticks.manage[ticks.tick + timeout] = [doo];
            } else {
                ticks.manage[ticks.tick + timeout].push(doo);
            }
        }

        function doNextTick(doo) {
            waitTicks.push(doo);
        }
        // AUTO PLACE:
        function autoPlace() {
            let nearObj = [];
            let randomDir = Math.random() * Math.PI * 2;
            if (gameObjects.length && enemy.length && getEl("autoplc").checked) {
                let nearsa = {
                    inTrap: false,
                };
                nearObj = gameObjects.filter((e)=>e.trap).sort(function(a, b) {
                    return (UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2));
                })[0];
                if (nearObj) {
                    if (!(player.sid != nearObj.owner.sid && !findAllianceBySid(nearObj.owner.sid)) && UTILS.getDist(nearObj, near, 0, 2) <= 70 && nearObj.active) {
                        nearsa.inTrap = true;
                    } else {
                        nearsa.inTrap = false;
                    }
                    if (near.dist2 <= 300) {
                        if (nearsa.inTrap || near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8) {
                            if (near.dist2 <= 225) {
                                for (let i = 0; i < Math.PI * 2; i += Math.PI / 1.5) {
                                    checkPlace(2, near.aim2 + i);
                                }
                            } else {
                                for (let i = Math.PI / 1.5; i < Math.PI * 2; i += Math.PI / 1.5) {
                                    checkPlace(2, near.aim2 + i);
                                }
                            }
                        } else {
                            if (player.items[4] == 15) {
                                if (UTILS.getDist(oldXY, player, 0, 2) >= 125) {
                                    for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                        checkPlace(4, randomDir + i);
                                    }
                                    oldXY.x = player.x2;
                                    oldXY.y = player.y2;
                                }
                            }
                        }
                    }
                } else {
                    if (near.dist2 <= 400) {
                        if (player.items[4] == 15) {
                            checkPlace(4, near.aim2);
                        }
                    }
                }
            }
        }
        // EQUIP HATS:
        function biomeGear() {
            if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                buyEquip(31, 0);
            } else {
                if (isMoveDir == undefined && (getEl("combat").value == "zyenith" || getEl("combat").value == "hans" || getEl("combat").value == "me")) {
                    buyEquip(22, 0);
                } else {
                    if (player.y2 <= config.snowBiomeTop) {
                        buyEquip(15, 0);
                    } else {
                        buyEquip(12, 0);
                    }
                }
            }
        }

        function safeWeapon1() {
            return (near.primaryIndex == 0 || near.primaryIndex == 6 || near.primaryIndex == 7 || near.primaryIndex == 8);
        }
        function safeWeapon2() {
            return (near.secondaryIndex == 9 || near.secondaryIndex == 10 || near.secondaryIndex == 11 || near.secondaryIndex == 14);
        }
        function changeHat(value) {
            if (value == "normal") {
                if (anti0Tick > 0) {
                    buyEquip(6, 0);
                } else {
                    if ((getEl("bulltick").checked && player.shameCount > 0 && (ticks.tick - player.bTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || reSyncBull) {
                        buyEquip(7, 0);
                    } else {
                        if (getEl("combat").value == "ae") {
                            buyEquip(6, 0);
                        } else if (getEl("combat").value == "fz") {
                            if (turretEmp > 0 || doEmpAntiInsta) {
                                buyEquip(22, 0);
                            } else {
                                if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                    buyEquip(31, 0);
                                } else {
                                    if (enemy.length) {
                                        if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                            if (near.primaryIndex != undefined && near.reloads[near.primaryIndex] == 0 && near.secondaryIndex != undefined && near.reloads[near.secondaryIndex] == 0 && player.reloads[player.weapons[0]] <= config.tickRate && player.reloads[player.weapons[1]] == 0 && player.weapons[0] != 7 && player.weapons[0] != 8 && near.primaryIndex != 7 && near.primaryIndex != 8) {
                                                buyEquip(11, 0);
                                            } else {
                                                if (safeWeapon1() && safeWeapon2()) {
                                                    buyEquip(26, 0);
                                                } else {
                                                    buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                                }
                                            }
                                        } else {
                                            biomeGear();
                                        }
                                    } else {
                                        biomeGear();
                                    }
                                }
                            }
                        } else if (getEl("combat").value == "me") {
                            if (turretEmp > 0 || doEmpAntiInsta) {
                                buyEquip(22, 0);
                            } else {
                                if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                    buyEquip(31, 0);
                                } else {
                                    if (enemy.length) {
                                        if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                            if (configs.antiBull > 0 && player.weapons[0] != 7) {
                                                buyEquip(11, 0);
                                            } else {
                                                buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                            }
                                        } else {
                                            biomeGear();
                                        }
                                    } else {
                                        biomeGear();
                                    }
                                }
                            }
                        } else {
                            if (turretEmp > 0 || doEmpAntiInsta) {
                                buyEquip(22, 0);
                            } else {
                                if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                    buyEquip(31, 0);
                                } else {
                                    if (enemy.length) {
                                        if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                            if (configs.antiBull > 0 && player.weapons[0] != 7) {
                                                buyEquip(11, 0);
                                            } else {
                                                buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                            }
                                        } else {
                                            biomeGear();
                                        }
                                    } else {
                                        biomeGear();
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (value == "click") {
                if (anti0Tick > 0) {
                    buyEquip(6, 0);
                } else {
                    if ((getEl("bulltick").checked && player.shameCount > 0 && (ticks.tick - player.bTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || reSyncBull) {
                        buyEquip(7, 0);
                    } else {
                        if (clicks.left && player.reloads[player.weapons[0]] == 0) {
                            buyEquip(7, 0);
                        } else if (clicks.right && player.reloads[(getEl("grindsec").checked && player.weapons[1] == 10) ? player.weapons[1] : player.weapons[0]] == 0) {
                            buyEquip(40, 0);
                        } else {
                            if (getEl("combat").value == "ae") {
                                buyEquip(6, 0);
                            } else if (getEl("combat").value == "fz") {
                                if (turretEmp > 0 || doEmpAntiInsta) {
                                    buyEquip(22, 0);
                                } else {
                                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                        buyEquip(31, 0);
                                    } else {
                                        if (near.dist2 <= 500) {
                                            if (safeWeapon1() && safeWeapon2()) {
                                                buyEquip(26, 0);
                                            } else {
                                                buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                            }
                                        } else {
                                            biomeGear();
                                        }
                                    }
                                }
                            } else if (getEl("combat").value == "me") {
                                if (turretEmp > 0 || doEmpAntiInsta) {
                                    buyEquip(22, 0);
                                } else {
                                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                        buyEquip(31, 0);
                                    } else {
                                        if (clicks.left && configs.antiBull > 0 && player.weapons[0] != 7) {
                                            buyEquip(11, 0);
                                        } else {
                                            buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                        }
                                    }
                                }
                            } else {
                                if (turretEmp > 0 || doEmpAntiInsta) {
                                    buyEquip(22, 0);
                                } else {
                                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                        buyEquip(31, 0);
                                    } else {
                                        if (clicks.left && configs.antiBull > 0 && player.weapons[0] != 7) {
                                            buyEquip(11, 0);
                                        } else {
                                            buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (value == "trap") {
                if (anti0Tick > 0) {
                    buyEquip(6, 0);
                } else {
                    if ((getEl("bulltick").checked && player.shameCount > 0 && (ticks.tick - player.bTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || reSyncBull) {
                        buyEquip(7, 0);
                    } else {
                        if (traps.healths > items.weapons[player.weapons[0]].dmg && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0) {
                            buyEquip(40, 0);
                        } else {
                            if (getEl("combat").value == "fz") {
                                if (turretEmp > 0 || doEmpAntiInsta) {
                                    buyEquip(22, 0);
                                } else {
                                    if (near.dist2 <= 300) {
                                        if ((safeWeapon1() && safeWeapon2()) || (near.primaryIndex == 5 && near.dist2 >= 175)) {
                                            buyEquip(26, 0);
                                        } else {
                                            buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                        }
                                    } else {
                                        biomeGear();
                                    }
                                }
                            } else if (getEl("combat").value == "hans") {
                                if (turretEmp > 0 || doEmpAntiInsta || near.secondaryIndex == 10) {
                                    buyEquip(22, 0);
                                } else {
                                    buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                }
                            } else {
                                if (turretEmp > 0 || doEmpAntiInsta || near.dist2 > 300) {
                                    buyEquip(22, 0);
                                } else {
                                    buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                }
                            }
                        }
                    }
                }
            }
        }

        function changeAcc(value) {
            if (value == "normal") {
                if (getEl("combat").value == "ae") {
                    buyEquip(11, 1);
                } else {
                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                        buyEquip(11, 1);
                    } else {
                        if (enemy.length) {
                            if (getEl("combat").value == "fz") {
                                if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                    if (near.primaryIndex != undefined && near.reloads[near.primaryIndex] == 0 && near.secondaryIndex != undefined && near.reloads[near.secondaryIndex] == 0 && player.reloads[player.weapons[0]] <= config.tickRate && player.reloads[player.weapons[1]] == 0 && player.weapons[0] != 7 && player.weapons[0] != 8 && near.primaryIndex != 7 && near.primaryIndex != 8) {
                                        buyEquip(21, 1);
                                    } else {
                                        if (configs.antiBull > 0) {
                                            buyEquip(21, 1);
                                        } else {
                                            if ((ticks.tick - player.bTick) % config.serverUpdateRate === 0) {
                                                buyEquip(13, 1);
                                            } else {
                                                buyEquip(11, 1);
                                            }
                                        }
                                    }
                                } else {
                                    buyEquip(11, 1);
                                }
                            } else {
                                if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                    if (configs.antiBull > 0) {
                                        buyEquip(21, 1);
                                    } else {
                                        buyEquip(11, 1);
                                    }
                                } else {
                                    buyEquip(11, 1);
                                }
                            }
                        } else {
                            buyEquip(11, 1);
                        }
                    }
                }
            } else if (value == "click") {
                if (getEl("combat").value == "ae") {
                    if (clicks.left) {
                        buyEquip(0, 1);
                    } else if (clicks.right) {
                        buyEquip(11, 1);
                    }
                } else if (getEl("combat").value == "fz") {
                    if (configs.antiBull > 0) {
                        buyEquip(21, 1);
                    } else {
                        if (clicks.left && player.reloads[player.weapons[0]] == 0) {
                            buyEquip(near.dist2 <= 300 ? 18 : 0, 1);
                        } else if (clicks.right && player.reloads[(getEl("grindsec").checked && player.weapons[1] == 10) ? player.weapons[1] : player.weapons[0]] == 0) {
                            buyEquip(near.dist2 <= 300 ? 18 : 11, 1);
                        } else {
                            if ((ticks.tick - player.bTick) % config.serverUpdateRate === 0) {
                                buyEquip(near.dist2 <= 500 ? 13 : 11, 1);
                            } else {
                                buyEquip(11, 1);
                            }
                        }
                    }
                } else {
                    buyEquip(21, 1);
                }
            } else if (value == "trap") {
                if (getEl("combat").value == "ae") {
                    buyEquip(0, 1);
                } else if (getEl("combat").value == "hans") {
                    buyEquip(0, 1);
                } else if (getEl("combat").value == "fz") {
                    if (configs.antiBull > 0) {
                        buyEquip(21, 1);
                    } else {
                        if (traps.healths > items.weapons[player.weapons[0]].dmg && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0) {
                            buyEquip(near.dist2 <= 275 ? 18 : 11, 1);
                        } else {
                            if (near.dist2 <= 300) {
                                if (instaC.wait) {
                                    buyEquip(21, 1);
                                } else {
                                    if ((ticks.tick - player.bTick) % config.serverUpdateRate === 0) {
                                        buyEquip(13, 1);
                                    } else {
                                        buyEquip(11, 1);
                                    }
                                }
                            } else {
                                buyEquip(11, 1);
                            }
                        }
                    }
                } else {
                    if (configs.antiBull > 0) {
                        buyEquip(21, 1);
                    } else {
                        if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                            buyEquip(21, 1);
                        } else {
                            buyEquip(11, 1);
                        }
                    }
                }
            }
        }
        // FIND OBJECTS BY ID/SID:
        function findID(tmpObj, tmp) {
            return tmpObj.find((THIS)=>THIS.id === tmp);
        }

        function findSID(tmpObj, tmp) {
            return tmpObj.find((THIS)=>THIS.sid === tmp);
        }

        function findPlayerByID(id) {
            return findID(players, id);
        }

        function findPlayerBySID(sid) {
            return findSID(players, sid);
        }

        function findAIBySID(sid) {
            return findSID(ais, sid);
        }

        function findObjectBySid(sid) {
            return findSID(gameObjects, sid);
        }

        function findAllianceBySid(sid) {
            return player.team ? alliancePlayers.find((THIS)=>THIS === sid) : null;
        }
        // PING:
        var lastPing = -1;
        var maxPing = NaN;
        var minPing = NaN;
        var pingCount = 0;
        var doAutoQ = false;

        function pingSocketResponse() {
            var pingTime = Date.now() - lastPing;
            window.pingTime = pingTime;
            pingCount++;
            if (pingTime > maxPing || isNaN(maxPing)) {
                maxPing = pingTime;
            }
            if (pingTime < minPing || isNaN(minPing)) {
                minPing = pingTime;
            }
            if (getEl("visual").value == "zeph") {
                pingDisplay.innerText = "Ping: " + pingTime + " ms | FPS: " + currentFPS + " frames";
            } else if (getEl("visual").value == "hans") {
                pingDisplay.innerText = "Ping: " + pingTime + " ms /  King Hans";
            } else {
                pingDisplay.innerText = "Ping: " + pingTime + " ms";
            }
            if (pingTime >= 90) {
                doAutoQ = true;
            } else {
                doAutoQ = false;
            }
        }
        pingDisplay.style.display = "none";
        document.body.appendChild(pingDisplay);

        function pingSocket() {
            lastPing = Date.now();
            io.send("pp");
        }
        // SERVER SHUTDOWN NOTICE:
        function serverShutdownNotice(countdown) {
            if (countdown < 0)
                return;
            var minutes = Math.floor(countdown / 60);
            var seconds = countdown % 60;
            seconds = ("0" + seconds).slice(-2);
            shutdownDisplay.innerText = "Server restarting in " + minutes + ":" + seconds;
            shutdownDisplay.hidden = false;
        }
        // UPDATE & ANIMATE:
        window.requestAnimFrame = (function() {
            return (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
                window.setTimeout(callback, 1000 / 60);
            }
            );
        }
        )();
        // DAY CYCLE MANAGER:
        let dayCycle = false;
        let dayColors = {
            snow: "#fff",
            river: "#91b2db",
            grass: "#b6db66",
            desert: "#dbc666",
        };
        let nightColors = {
            snow: "#e6e6e6",
            river: "#78a1d3",
            grass: "#8dba2c",
            desert: "#d3b945",
        };
        setInterval(()=>{
            dayCycle = !dayCycle;
        }
        , 39000 * 2);
        // LMFAO:
        var mStatus = document.createElement("div");
        mStatus.id = "status";
        mStatus.style.position = "absolute";
        mStatus.style.color = "#e6e6fa";
        mStatus.style.font = "15px Hammersmith One";
        mStatus.style.top = "40px";
        mStatus.style.left = "40px";
        mStatus.style.display = "none";
        mStatus.textAlign = "right";
        document.body.appendChild(mStatus);
        let currentFPS = 0;
        let FPSTimer = 0;
        let runAtFirst = true;
        let autoMusic = false;
        let hatELs = {
            6: true,
            7: true,
            40: true,
            22: true,
            15: true
        };
        mStatus.innerHTML = `
                <style>
                .sizing {
                    font-size: 15px;
                }
                .mod {
                    font-size: 15px;
                    display: inline-block;
                }
                .augh {
                    display: inline-block;
                    width: 25px;
                    height: 25px;
                    background-size: cover;
                    background-color: #fff;
                    margin-right: -2.5px;
                    opacity: 0.4;
                }
                </style>
                <div id = "uehmod" class = "sizing" style = "display: block;">
                Ping: <div id = "pingFps" class = "mod">0</div></br>
                InstaStatus: [<div id = "instaStatus" class = "mod">0</div>]</br>
                Ticks | Lags: [<div id = "tickLag" class = "mod">0</div>]</br>
                Packet: <div id = "packetStatus" class = "mod">0</div></br>
                <div id = "nearEnemys" class = "mod">0</div></br>
                </div><div id = "fzmod" class = "sizing" style = "display: none;">
                Auto-Insta: <div id = "autoInsta1" class = "mod">0</div></br>
                Damage Prediction: <div id = "dmgPredict" class = "mod">0</div></br>
                Turrets that can hit you: <div id = "turCanHit" class = "mod">0</div></br>
                </div><div id = "zyenithmod" class = "sizing" style = "display: none;">
                <div id = "hatdispdiv" style = "display: block">
                <div id = "hatdisp6" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_6.png);"></div>
                <div id = "hatdisp7" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_7.png);"></div>
                <div id = "hatdisp40" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_40.png);"></div>
                <div id = "hatdisp22" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_22.png);"></div>
                <div id = "hatdisp15" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_15.png);"></div>
                </div>
                Auto-Insta: <div id = "autoInsta2" class = "mod">0</div></br>
                EAB: {<div id = "eabStatus" class = "mod">0</div>}</br>
                Music: <div id = "musicStatus" class = "mod">0</div></br>
                AdvPlacer: <div id = "millStatus" class = "mod">0</div></br>
                </div>
                `;
        function doUpdate() {
            now = Date.now();
            delta = now - lastUpdate;
            lastUpdate = now;
            FPSTimer++;
            if (runAtFirst) {
                runAtFirst = false;
                setInterval(()=>{
                    currentFPS = FPSTimer;
                    FPSTimer = 0;
                }
                , 1000);
            }
            updateGame();
            requestAnimFrame(doUpdate);
            if (player) {
                if (getEl("visual").value == "me") {
                    getEl("instaStatus").innerHTML = [instaC.wait, instaC.isTrue, UTILS.fixTo(checkCanInsta(false), 2)].join(", ");
                    getEl("pingFps").innerHTML = `${window.pingTime}ms | Fps: ${currentFPS}`;
                    getEl("tickLag").innerHTML = ticks.time;
                    getEl("packetStatus").innerHTML = secPacket;
                    getEl("nearEnemys").innerHTML = nears.length ? "cEnemy: " + nears.length : "";
                } else if (getEl("visual").value == "fz") {
                    getEl("autoInsta1").innerHTML = (instaC.wait ? "on" : "off").toUpperCase();
                    getEl("dmgPredict").innerHTML = predictDamage;
                    getEl("turCanHit").innerHTML = turretEmp;
                } else if (getEl("visual").value == "zyenith") {
                    getEl("autoInsta2").innerHTML = (instaC.wait ? "on" : "off").toUpperCase();
                    getEl("eabStatus").innerHTML = earlyAutoBreak.start ? [`hit:${earlyAutoBreak.hit}`, `miss:${earlyAutoBreak.miss}`, ].join(",") : "";
                    getEl("musicStatus").innerHTML = (autoMusic ? "on" : "off").toUpperCase();
                    getEl("millStatus").innerHTML = (millC.active ? "on" : "off").toUpperCase();
                }
            }
        }
        // START GAME:
        function startGame() {
            bindEvents();
            loadIcons();
            loadingText.style.display = "none";
            menuCardHolder.style.display = "block";
            nameInput.value = getSavedVal("moo_name") || "";
            prepareUI();
        }
        prepareMenuBackground();
        doUpdate();
        // OPEN LINK:
        function openLink(link) {
            window.open(link, "_blank");
        }
        // EXPORT VALUES:
        window.openLink = openLink;
        window.aJoinReq = aJoinReq;
        window.follmoo = follmoo;
        window.kickFromClan = kickFromClan;
        window.sendJoin = sendJoin;
        window.leaveAlliance = leaveAlliance;
        window.createAlliance = createAlliance;
        window.storeBuy = storeBuy;
        window.storeEquip = storeEquip;
        window.showItemInfo = showItemInfo;
        window.selectSkinColor = selectSkinColor;
        window.changeStoreIndex = changeStoreIndex;
        window.config = config;
        window.FRVR = [18731283, 30192, 12893, 12398123, 192381290, 1290381920, 3, 12893, 1283, 123, 1293, 9012, "real", "please", "help", "scare", "jumpscare", "homo", ];
        document.createAlliance = function(value) {
            if (player.team) {
                io.send("9", undefined);
                setTimeout(()=>{//                    io.send("8", value == "" ? String.fromCharCode(0) + " ".repeat(6) : value);
                }
                , 1000);
            } else {
                io.send("8", value == "" ? String.fromCharCode(0) + " ".repeat(6) : value);
            }
        }
        ;
        // FUNCTIONS:
        let mapDisp = getEl("mapDisplay");
        mapDisp.style.backgroundImage = "";
        mapDisp.style.backgroundSize = "130px";
        let pingDisp = getEl("pingDisplay");
        function changeStatusDiv(id) {
            getEl("uehmod").style.display = "none";
            getEl("fzmod").style.display = "none";
            getEl("zyenithmod").style.display = "none";
            let haha = id == "me" ? "uehmod" : id == "fz" ? "fzmod" : id == "zyenith" ? "zyenithmod" : undefined;
            if (haha != undefined) {
                getEl(haha).style.display = "block";
            }
        }
        getEl("combat").onchange = function() {
            getEl("crp").innerHTML = checkCheckChickenModV69(getEl("combat").value);
            this.blur();
        }
        function watafak(ahaha) {
                        //            console.log("call");
            getEl("vrp").innerHTML = checkCheckChickenModV69(getEl("visual").value);
            changeStatusDiv(getEl("visual").value);
            if (ahaha) {
                updateItemCountHTML();
            }
            pingDisp.style.display = "none";
            pingDisp.innerText = "Ping: " + window.pingTime + " ms";
            pingDisp.style.left = null;
            mapDisp.style.backgroundImage = "";
            mapDisp.style.backgroundColor = "rgba(0, 0, 0, 0.25)";
            foodDisplay.style.display = "block";
            woodDisplay.style.display = "block";
            stoneDisplay.style.display = "block";
            scoreDisplay.style.bottom = "160px";
            scoreDisplay.style.right = "inherit";
            scoreDisplay.style.left = "20px";
            scoreDisplay.style.backgroundPosition = "left 6px center";
            scoreDisplay.style.paddingLeft = "40px";
            scoreDisplay.style.paddingRight = "10px";
            if (getEl("visual").value == "0") {} else if (getEl("visual").value == "me") {
                mStatus.style.color = "#e6e6fa";
                mStatus.style.top = "40px";
                mStatus.style.left = "40px";
                mStatus.style.right = null;
            } else if (getEl("visual").value == "spyder") {
                mapDisp.style.backgroundImage = "url(https://i.imgur.com/S1ogeNC.gif)";
                pingDisp.style.display = "block";
            } else if (getEl("visual").value == "lore") {
                mapDisp.style.backgroundImage = "url(https://ksw2-center.glitch.me/users/fzb/map.png)";
            } else if (getEl("visual").value == "cele") {} else if (getEl("visual").value == "zeph") {
                pingDisp.style.display = "block";
                pingDisplay.innerText = "Ping: " + window.pingTime + " ms | FPS: " + currentFPS + " frames";
            } else if (getEl("visual").value == "zeph") {} else if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                mapDisp.style.backgroundImage = "url(https://ksw2-center.glitch.me/users/fzb/map.png)";
            } else if (getEl("visual").value == "hans") {
                pingDisp.style.display = "block";
                pingDisp.style.left = "90px";
                pingDisplay.innerText = "Ping: " + window.pingTime + " ms /  King Hans";
                mapDisp.style.backgroundColor = "rgba(0, 0, 0, 0)";
            } else {}
            if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                mStatus.style.color = "#fff";
                mStatus.style.top = "40px";
                mStatus.style.left = null;
                if (getEl("visual").value == "zyenith") {
                    mStatus.style.right = "40px";
                } else {
                    mStatus.style.right = "20px";
                }
                mStatus.style.display = "block";
                leaderboard.style.position = "fixed";
                leaderboard.style.left = "20px";
                leaderboard.style.right = null;
                leaderboard.style.display = "none";
                allianceButton.style.left = "410px";
                allianceButton.style.right = null;
                allianceButton.style.width = "40px";
                storeButton.style.left = "350px";
                storeButton.style.right = null;
                storeButton.style.width = "40px";
                chatButton.style.display = "none";
                try {} catch (e) {}
                resourceDisplay.appendChild(killCounter);
                if (getEl("visual").value == "fz") {
                    killCounter.style.bottom = "185px";
                    killCounter.style.right = "20px";
                    scoreDisplay.style.bottom = "240px";
                    scoreDisplay.style.right = "20px";
                    scoreDisplay.style.left = "inherit";
                    scoreDisplay.style.backgroundPosition = "right 6px center";
                    scoreDisplay.style.paddingLeft = "10px";
                    scoreDisplay.style.paddingRight = "40px";
                } else {
                    foodDisplay.style.display = "none";
                    woodDisplay.style.display = "none";
                    stoneDisplay.style.display = "none";
                    killCounter.style.bottom = "20px";
                    killCounter.style.right = "20px";
                }
            } else {
                leaderboard.style.position = null;
                leaderboard.style.left = null;
                leaderboard.style.right = null;
                leaderboard.style.display = "block";
                allianceButton.style.left = null;
                allianceButton.style.right = "270px";
                allianceButton.style.width = "40px";
                storeButton.style.left = null;
                storeButton.style.right = "330px";
                storeButton.style.width = "40px";
                chatButton.style.display = "block";
                topinfoHolder.appendChild(killCounter);
                killCounter.style.bottom = null;
                killCounter.style.right = null;
                mStatus.style.display = "none";
            }
            if (player) {
                ageBarBody.style.width = (getEl("visual").value == "cele" || getEl("visual").value == "ae" ? "0" : (player.XP / player.maxXP) * 100) + "%";
                for (var i = 0; i < items.list.length; ++i) {
                    var tmpI = items.weapons.length + i;
                    getEl("actionBarItem" + tmpI).style.display = (getEl("visual").value == "cele" || getEl("visual").value == "ae" || getEl("visual").value == "hans" ? player.firstItems : player.items).indexOf(items.list[i].id) >= 0 ? "inline-block" : "none";
                }
            }
            //            Wut = getEl("visual").description;
        }
        watafak();
        getEl("visual").onchange = function() {
            watafak(true);
            this.blur();
        }
        ;
        /***/
    },
    /***/
    "./src/js/config.js": /*!**************************!*\
  !*** ./src/js/config.js ***!
  \**************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            // RENDER:
            module.exports.maxScreenWidth = 1920;
            module.exports.maxScreenHeight = 1080;
            // SERVER:
            module.exports.serverUpdateRate = 9;
            module.exports.tickRate = 1000 / module.exports.serverUpdateRate;
            module.exports.maxPlayers = process && process.argv.indexOf("--largeserver") != -1 ? 80 : 50;
            module.exports.maxPlayersHard = module.exports.maxPlayers + 10;
            module.exports.collisionDepth = 6;
            module.exports.minimapRate = 3000;
            // COLLISIONS:
            module.exports.colGrid = 10;
            // CLIENT:
            module.exports.clientSendRate = 5;
            // UI:
            module.exports.healthBarWidth = 50;
            module.exports.healthBarPad = 4.5;
            module.exports.iconPadding = 15;
            module.exports.iconPad = 0.9;
            module.exports.deathFadeout = 3000;
            module.exports.crownIconScale = 60;
            module.exports.crownPad = 35;
            // CHAT:
            module.exports.chatCountdown = 3000;
            module.exports.chatCooldown = 500;
            // SANDBOX:
            module.exports.inSandbox = process && process.env.VULTR_SCHEME === "mm_exp";
            module.exports.isSandbox = window.location.hostname == "sandbox.moomoo.io";
            // PLAYER:
            module.exports.maxAge = 100;
            module.exports.gatherAngle = Math.PI / 2.6;
            module.exports.gatherWiggle = 10;
            module.exports.hitReturnRatio = 0.25;
            module.exports.hitAngle = Math.PI / 2;
            module.exports.playerScale = 35;
            module.exports.playerSpeed = 0.0016;
            module.exports.playerDecel = 0.993;
            module.exports.nameY = 34;
            // CUSTOMIZATION:
            module.exports.skinColors = ["#bf8f54", "#cbb091", "#896c4b", "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3", "#8bc373", "#91b2db", ];
            // ANIMALS:
            module.exports.animalCount = 7;
            module.exports.aiTurnRandom = 0.06;
            module.exports.cowNames = ["Sid", "Steph", "Bmoe", "Romn", "Jononthecool", "Fiona", "Vince", "Nathan", "Nick", "Flappy", "Ronald", "Otis", "Pepe", "Mc Donald", "Theo", "Fabz", "Oliver", "Jeff", "Jimmy", "Helena", "Reaper", "Ben", "Alan", "Naomi", "XYZ", "Clever", "Jeremy", "Mike", "Destined", "Stallion", "Allison", "Meaty", "Sophia", "Vaja", "Joey", "Pendy", "Murdoch", "Theo", "Jared", "July", "Sonia", "Mel", "Dexter", "Quinn", "Milky", ];
            // WEAPONS:
            module.exports.shieldAngle = Math.PI / 3;
            module.exports.weaponVariants = [{
                id: 0,
                src: "",
                xp: 0,
                val: 1,
            }, {
                id: 1,
                src: "_g",
                xp: 3000,
                val: 1.1,
            }, {
                id: 2,
                src: "_d",
                xp: 7000,
                val: 1.18,
            }, {
                id: 3,
                src: "_r",
                poison: true,
                xp: 12000,
                val: 1.18,
            }, ];
            module.exports.weaponXPs = [{
                id: 0,
                xp: 3000,
            }, {
                id: 1,
                xp: 7000,
            }, {
                id: 2,
                xp: 12000,
            }, {
                id: 3,
                xp: 1 / 0,
            }, ];
            module.exports.fetchVariant = function(player) {
                var tmpXP = player.weaponXP[player.weaponIndex] || 0;
                for (var i = module.exports.weaponVariants.length - 1; i >= 0; --i) {
                    if (tmpXP >= module.exports.weaponVariants[i].xp)
                        return module.exports.weaponVariants[i];
                }
            }
            ;
            // NATURE:
            module.exports.resourceTypes = ["wood", "food", "stone", "points"];
            module.exports.areaCount = 7;
            module.exports.treesPerArea = 9;
            module.exports.bushesPerArea = 3;
            module.exports.totalRocks = 32;
            module.exports.goldOres = 7;
            module.exports.riverWidth = 724;
            module.exports.riverPadding = 114;
            module.exports.waterCurrent = 0.0011;
            module.exports.waveSpeed = 0.0001;
            module.exports.waveMax = 1.3;
            module.exports.treeScales = [150, 160, 165, 175];
            module.exports.bushScales = [80, 85, 95];
            module.exports.rockScales = [80, 85, 90];
            // BIOME DATA:
            module.exports.snowBiomeTop = 2400;
            module.exports.snowSpeed = 0.75;
            // DATA:
            module.exports.maxNameLength = 15;
            // MAP:
            module.exports.mapScale = 14400;
            module.exports.mapPingScale = 40;
            module.exports.mapPingTime = 2200;
            /* WEBPACK VAR INJECTION */
        }
        ).call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */
        "./node_modules/process/browser.js"));
        /***/
    },
    /***/
    "./src/js/data/ai.js": /*!***************************!*\
  !*** ./src/js/data/ai.js ***!
  \***************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        var PI2 = Math.PI * 2;
        module.exports = function(sid, objectManager, players, items, UTILS, config, scoreCallback, server) {
            this.sid = sid;
            this.isAI = true;
            this.nameIndex = UTILS.randInt(0, config.cowNames.length - 1);
            // INIT:
            this.init = function(x, y, dir, index, data) {
                this.x = x;
                this.y = y;
                this.startX = data.fixedSpawn ? x : null;
                this.startY = data.fixedSpawn ? y : null;
                this.xVel = 0;
                this.yVel = 0;
                this.zIndex = 0;
                this.dir = dir;
                this.dirPlus = 0;
                this.index = index;
                this.src = data.src;
                if (data.name)
                    this.name = data.name;
                this.weightM = data.weightM;
                this.speed = data.speed;
                this.killScore = data.killScore;
                this.turnSpeed = data.turnSpeed;
                this.scale = data.scale;
                this.maxHealth = data.health;
                this.leapForce = data.leapForce;
                this.health = this.maxHealth;
                this.chargePlayer = data.chargePlayer;
                this.viewRange = data.viewRange;
                this.drop = data.drop;
                this.dmg = data.dmg;
                this.hostile = data.hostile;
                this.dontRun = data.dontRun;
                this.hitRange = data.hitRange;
                this.hitDelay = data.hitDelay;
                this.hitScare = data.hitScare;
                this.spriteMlt = data.spriteMlt;
                this.nameScale = data.nameScale;
                this.colDmg = data.colDmg;
                this.noTrap = data.noTrap;
                this.spawnDelay = data.spawnDelay;
                this.hitWait = 0;
                this.waitCount = 1000;
                this.moveCount = 0;
                this.weaponReload = 0;
                this.weaponHitted = 0;
                this.targetDir = 0;
                this.active = true;
                this.alive = true;
                this.runFrom = null;
                this.chargeTarget = null;
                this.dmgOverTime = {};
                this.doTickUpdate = false;
            }
            ;
            // UPDATE:
            var timerCount = 0;
            this.update = function(delta) {
                if (this.active) {
                    // SPAWN DELAY:
                    if (this.spawnCounter) {
                        this.spawnCounter -= delta;
                        if (this.spawnCounter <= 0) {
                            this.spawnCounter = 0;
                            this.x = this.startX || UTILS.randInt(0, config.mapScale);
                            this.y = this.startY || UTILS.randInt(0, config.mapScale);
                        }
                        return;
                    }
                    // REGENS AND AUTO:
                    timerCount -= delta;
                    if (timerCount <= 0) {
                        if (this.dmgOverTime.dmg) {
                            this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer);
                            this.dmgOverTime.time -= 1;
                            if (this.dmgOverTime.time <= 0)
                                this.dmgOverTime.dmg = 0;
                        }
                        timerCount = 1000;
                    }
                    // BEHAVIOUR:
                    var charging = false;
                    var slowMlt = 1;
                    if (!this.zIndex && !this.lockMove && this.y >= config.mapScale / 2 - config.riverWidth / 2 && this.y <= config.mapScale / 2 + config.riverWidth / 2) {
                        slowMlt = 0.33;
                        this.xVel += config.waterCurrent * delta;
                    }
                    if (this.lockMove) {
                        this.xVel = 0;
                        this.yVel = 0;
                    } else if (this.waitCount > 0) {
                        this.waitCount -= delta;
                        if (this.waitCount <= 0) {
                            if (this.chargePlayer) {
                                var tmpPlayer, bestDst, tmpDist;
                                for (var i = 0; i < players.length; ++i) {
                                    if (players[i].alive && !(players[i].skin && players[i].skin.bullRepel)) {
                                        tmpDist = UTILS.getDistance(this.x, this.y, players[i].x, players[i].y);
                                        if (tmpDist <= this.viewRange && (!tmpPlayer || tmpDist < bestDst)) {
                                            bestDst = tmpDist;
                                            tmpPlayer = players[i];
                                        }
                                    }
                                }
                                if (tmpPlayer) {
                                    this.chargeTarget = tmpPlayer;
                                    this.moveCount = UTILS.randInt(8000, 12000);
                                } else {
                                    this.moveCount = UTILS.randInt(1000, 2000);
                                    this.targetDir = UTILS.randFloat(-Math.PI, Math.PI);
                                }
                            } else {
                                this.moveCount = UTILS.randInt(4000, 10000);
                                this.targetDir = UTILS.randFloat(-Math.PI, Math.PI);
                            }
                        }
                    } else if (this.moveCount > 0) {
                        var tmpSpd = this.speed * slowMlt;
                        if (this.runFrom && this.runFrom.active && !(this.runFrom.isPlayer && !this.runFrom.alive)) {
                            this.targetDir = UTILS.getDirection(this.x, this.y, this.runFrom.x, this.runFrom.y);
                            tmpSpd *= 1.42;
                        } else if (this.chargeTarget && this.chargeTarget.alive) {
                            this.targetDir = UTILS.getDirection(this.chargeTarget.x, this.chargeTarget.y, this.x, this.y);
                            tmpSpd *= 1.75;
                            charging = true;
                        }
                        if (this.hitWait) {
                            tmpSpd *= 0.3;
                        }
                        if (this.dir != this.targetDir) {
                            this.dir %= PI2;
                            var netAngle = (this.dir - this.targetDir + PI2) % PI2;
                            var amnt = Math.min(Math.abs(netAngle - PI2), netAngle, this.turnSpeed * delta);
                            var sign = netAngle - Math.PI >= 0 ? 1 : -1;
                            this.dir += sign * amnt + PI2;
                        }
                        this.dir %= PI2;
                        this.xVel += tmpSpd * delta * Math.cos(this.dir);
                        this.yVel += tmpSpd * delta * Math.sin(this.dir);
                        this.moveCount -= delta;
                        if (this.moveCount <= 0) {
                            this.runFrom = null;
                            this.chargeTarget = null;
                            this.waitCount = this.hostile ? 1500 : UTILS.randInt(1500, 6000);
                        }
                    }
                    // OBJECT COLL:
                    this.zIndex = 0;
                    this.lockMove = false;
                    var tmpList;
                    var tmpSpeed = UTILS.getDistance(0, 0, this.xVel * delta, this.yVel * delta);
                    var depth = Math.min(4, Math.max(1, Math.round(tmpSpeed / 40)));
                    var tMlt = 1 / depth;
                    for (var i = 0; i < depth; ++i) {
                        if (this.xVel)
                            this.x += this.xVel * delta * tMlt;
                        if (this.yVel)
                            this.y += this.yVel * delta * tMlt;
                        tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                        for (var x = 0; x < tmpList.length; ++x) {
                            for (var y = 0; y < tmpList[x].length; ++y) {
                                if (tmpList[x][y].active)
                                    objectManager.checkCollision(this, tmpList[x][y], tMlt);
                            }
                        }
                    }
                    // HITTING:
                    var hitting = false;
                    if (this.hitWait > 0) {
                        this.hitWait -= delta;
                        if (this.hitWait <= 0) {
                            hitting = true;
                            this.hitWait = 0;
                            if (this.leapForce && !UTILS.randInt(0, 2)) {
                                this.xVel += this.leapForce * Math.cos(this.dir);
                                this.yVel += this.leapForce * Math.sin(this.dir);
                            }
                            var tmpList = objectManager.getGridArrays(this.x, this.y, this.hitRange);
                            var tmpObj, tmpDst;
                            for (var t = 0; t < tmpList.length; ++t) {
                                for (var x = 0; x < tmpList[t].length; ++x) {
                                    tmpObj = tmpList[t][x];
                                    if (tmpObj.health) {
                                        tmpDst = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y);
                                        if (tmpDst < tmpObj.scale + this.hitRange) {
                                            if (tmpObj.changeHealth(-this.dmg * 5))
                                                objectManager.disableObj(tmpObj);
                                            objectManager.hitObj(tmpObj, UTILS.getDirection(this.x, this.y, tmpObj.x, tmpObj.y));
                                        }
                                    }
                                }
                            }
                            for (var x = 0; x < players.length; ++x) {
                                if (players[x].canSee(this)) {
                                    server.send(players[x].id, "aa", this.sid);
                                }
                            }
                        }
                    }
                    // PLAYER COLLISIONS:
                    if (charging || hitting) {
                        var tmpObj, tmpDst, tmpDir;
                        for (var i = 0; i < players.length; ++i) {
                            tmpObj = players[i];
                            if (tmpObj && tmpObj.alive) {
                                tmpDst = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y);
                                if (this.hitRange) {
                                    if (!this.hitWait && tmpDst <= this.hitRange + tmpObj.scale) {
                                        if (hitting) {
                                            tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                            tmpObj.changeHealth(-this.dmg);
                                            tmpObj.xVel += 0.6 * Math.cos(tmpDir);
                                            tmpObj.yVel += 0.6 * Math.sin(tmpDir);
                                            this.runFrom = null;
                                            this.chargeTarget = null;
                                            this.waitCount = 3000;
                                            this.hitWait = !UTILS.randInt(0, 2) ? 600 : 0;
                                        } else
                                            this.hitWait = this.hitDelay;
                                    }
                                } else if (tmpDst <= this.scale + tmpObj.scale) {
                                    tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                    tmpObj.changeHealth(-this.dmg);
                                    tmpObj.xVel += 0.55 * Math.cos(tmpDir);
                                    tmpObj.yVel += 0.55 * Math.sin(tmpDir);
                                }
                            }
                        }
                    }
                    // DECEL:
                    if (this.xVel)
                        this.xVel *= Math.pow(config.playerDecel, delta);
                    if (this.yVel)
                        this.yVel *= Math.pow(config.playerDecel, delta);
                    // MAP BOUNDARIES:
                    var tmpScale = this.scale;
                    if (this.x - tmpScale < 0) {
                        this.x = tmpScale;
                        this.xVel = 0;
                    } else if (this.x + tmpScale > config.mapScale) {
                        this.x = config.mapScale - tmpScale;
                        this.xVel = 0;
                    }
                    if (this.y - tmpScale < 0) {
                        this.y = tmpScale;
                        this.yVel = 0;
                    } else if (this.y + tmpScale > config.mapScale) {
                        this.y = config.mapScale - tmpScale;
                        this.yVel = 0;
                    }
                }
            }
            ;
            // CAN SEE:
            this.canSee = function(other) {
                if (!other)
                    return false;
                if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer)
                    return false;
                var dx = Math.abs(other.x - this.x) - other.scale;
                var dy = Math.abs(other.y - this.y) - other.scale;
                return (dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3);
            }
            ;
            var tmpRatio = 0;
            var animIndex = 0;
            this.animate = function(delta) {
                if (this.animTime > 0) {
                    this.animTime -= delta;
                    if (this.animTime <= 0) {
                        this.animTime = 0;
                        this.dirPlus = 0;
                        tmpRatio = 0;
                        animIndex = 0;
                    } else {
                        if (animIndex == 0) {
                            tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                            this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                            if (tmpRatio >= 1) {
                                tmpRatio = 1;
                                animIndex = 1;
                            }
                        } else {
                            tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                            this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                        }
                    }
                }
            }
            ;
            // ANIMATION:
            this.startAnim = function() {
                this.animTime = this.animSpeed = 600;
                this.targetAngle = Math.PI * 0.8;
                tmpRatio = 0;
                animIndex = 0;
            }
            ;
            // CHANGE HEALTH:
            this.changeHealth = function(val, doer, runFrom) {
                if (this.active) {
                    this.health += val;
                    if (runFrom) {
                        if (this.hitScare && !UTILS.randInt(0, this.hitScare)) {
                            this.runFrom = runFrom;
                            this.waitCount = 0;
                            this.moveCount = 2000;
                        } else if (this.hostile && this.chargePlayer && runFrom.isPlayer) {
                            this.chargeTarget = runFrom;
                            this.waitCount = 0;
                            this.moveCount = 8000;
                        } else if (!this.dontRun) {
                            this.runFrom = runFrom;
                            this.waitCount = 0;
                            this.moveCount = 2000;
                        }
                    }
                    if (val < 0 && this.hitRange && UTILS.randInt(0, 1))
                        this.hitWait = 500;
                    if (doer && doer.canSee(this) && val < 0) {
                        server.send(doer.id, "t", Math.round(this.x), Math.round(this.y), Math.round(-val), 1);
                    }
                    if (this.health <= 0) {
                        if (this.spawnDelay) {
                            this.spawnCounter = this.spawnDelay;
                            this.x = -1000000;
                            this.y = -1000000;
                        } else {
                            this.x = this.startX || UTILS.randInt(0, config.mapScale);
                            this.y = this.startY || UTILS.randInt(0, config.mapScale);
                        }
                        this.health = this.maxHealth;
                        this.runFrom = null;
                        if (doer) {
                            scoreCallback(doer, this.killScore);
                            if (this.drop) {
                                for (var i = 0; i < this.drop.length; ) {
                                    doer.addResource(config.resourceTypes.indexOf(this.drop[i]), this.drop[i + 1]);
                                    i += 2;
                                }
                            }
                        }
                    }
                }
            }
            ;
        }
        ;
        /***/
    },
    /***/
    "./src/js/data/aiManager.js": /*!**********************************!*\
  !*** ./src/js/data/aiManager.js ***!
  \**********************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // AI MANAGER:
        module.exports = function(ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {
            // AI TYPES:
            this.aiTypes = [{
                id: 0,
                src: "cow_1",
                killScore: 150,
                health: 500,
                weightM: 0.8,
                speed: 0.00095,
                turnSpeed: 0.001,
                scale: 72,
                drop: ["food", 50],
            }, {
                id: 1,
                src: "pig_1",
                killScore: 200,
                health: 800,
                weightM: 0.6,
                speed: 0.00085,
                turnSpeed: 0.001,
                scale: 72,
                drop: ["food", 80],
            }, {
                id: 2,
                name: "Bull",
                src: "bull_2",
                hostile: true,
                dmg: 20,
                killScore: 1000,
                health: 1800,
                weightM: 0.5,
                speed: 0.00094,
                turnSpeed: 0.00074,
                scale: 78,
                viewRange: 800,
                chargePlayer: true,
                drop: ["food", 100],
            }, {
                id: 3,
                name: "Bully",
                src: "bull_1",
                hostile: true,
                dmg: 20,
                killScore: 2000,
                health: 2800,
                weightM: 0.45,
                speed: 0.001,
                turnSpeed: 0.0008,
                scale: 90,
                viewRange: 900,
                chargePlayer: true,
                drop: ["food", 400],
            }, {
                id: 4,
                name: "Wolf",
                src: "wolf_1",
                hostile: true,
                dmg: 8,
                killScore: 500,
                health: 300,
                weightM: 0.45,
                speed: 0.001,
                turnSpeed: 0.002,
                scale: 84,
                viewRange: 800,
                chargePlayer: true,
                drop: ["food", 200],
            }, {
                id: 5,
                name: "Quack",
                src: "chicken_1",
                dmg: 8,
                killScore: 2000,
                noTrap: true,
                health: 300,
                weightM: 0.2,
                speed: 0.0018,
                turnSpeed: 0.006,
                scale: 70,
                drop: ["food", 100],
            }, {
                id: 6,
                name: "MOOSTAFA",
                nameScale: 50,
                src: "enemy",
                hostile: true,
                dontRun: true,
                fixedSpawn: true,
                spawnDelay: 60000,
                noTrap: true,
                colDmg: 100,
                dmg: 40,
                killScore: 8000,
                health: 18000,
                weightM: 0.4,
                speed: 0.0007,
                turnSpeed: 0.01,
                scale: 80,
                spriteMlt: 1.8,
                leapForce: 0.9,
                viewRange: 1000,
                hitRange: 210,
                hitDelay: 1000,
                chargePlayer: true,
                drop: ["food", 100],
            }, {
                id: 7,
                name: "Treasure",
                hostile: true,
                nameScale: 35,
                src: "crate_1",
                fixedSpawn: true,
                spawnDelay: 120000,
                colDmg: 200,
                killScore: 5000,
                health: 20000,
                weightM: 0.1,
                speed: 0.0,
                turnSpeed: 0.0,
                scale: 70,
                spriteMlt: 1.0,
            }, {
                id: 8,
                name: "MOOFIE",
                src: "wolf_2",
                hostile: true,
                fixedSpawn: true,
                dontRun: true,
                hitScare: 4,
                spawnDelay: 30000,
                noTrap: true,
                nameScale: 35,
                dmg: 10,
                colDmg: 100,
                killScore: 3000,
                health: 7000,
                weightM: 0.45,
                speed: 0.0015,
                turnSpeed: 0.002,
                scale: 90,
                viewRange: 800,
                chargePlayer: true,
                drop: ["food", 1000],
            }, ];
            // SPAWN AI:
            this.spawn = function(x, y, dir, index) {
                var tmpObj;
                for (var i = 0; i < ais.length; ++i) {
                    if (!ais[i].active) {
                        tmpObj = ais[i];
                        break;
                    }
                }
                if (!tmpObj) {
                    tmpObj = new AI(ais.length,objectManager,players,items,UTILS,config,scoreCallback,server);
                    ais.push(tmpObj);
                }
                tmpObj.init(x, y, dir, index, this.aiTypes[index]);
                return tmpObj;
            }
            ;
        }
        ;
        /***/
    },
    /***/
    "./src/js/data/gameObject.js": /*!***********************************!*\
  !*** ./src/js/data/gameObject.js ***!
  \***********************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        module.exports = function(sid) {
            this.sid = sid;
            // INIT:
            this.init = function(x, y, dir, scale, type, data, owner) {
                data = data || {};
                this.sentTo = {};
                this.gridLocations = [];
                this.active = true;
                this.doUpdate = data.doUpdate;
                this.shootReload = 2200 - (1000 / 9) * 2;
                this.shootted = 0;
                this.x = x;
                this.y = y;
                this.dir = dir;
                this.xWiggle = 0;
                this.yWiggle = 0;
                this.scale = scale;
                this.type = type;
                this.id = data.id;
                this.owner = owner;
                this.name = data.name;
                this.isItem = this.id != undefined;
                this.group = data.group;
                this.health = data.health;
                this.buildHealth = data.health;
                this.layer = 2;
                if (this.group != undefined) {
                    this.layer = this.group.layer;
                } else if (this.type == 0) {
                    this.layer = 3;
                } else if (this.type == 2) {
                    this.layer = 0;
                } else if (this.type == 4) {
                    this.layer = -1;
                }
                this.colDiv = data.colDiv || 1;
                this.blocker = data.blocker;
                this.ignoreCollision = data.ignoreCollision;
                this.dontGather = data.dontGather;
                this.hideFromEnemy = data.hideFromEnemy;
                this.friction = data.friction;
                this.projDmg = data.projDmg;
                this.dmg = data.dmg;
                this.pDmg = data.pDmg;
                this.pps = data.pps;
                this.zIndex = data.zIndex || 0;
                this.turnSpeed = data.turnSpeed;
                this.req = data.req;
                this.trap = data.trap;
                this.healCol = data.healCol;
                this.teleport = data.teleport;
                this.boostSpeed = data.boostSpeed;
                this.projectile = data.projectile;
                this.shootRange = data.shootRange;
                this.shootRate = data.shootRate;
                this.shootCount = this.shootRate;
                this.spawnPoint = data.spawnPoint;
            }
            ;
            // GET HIT:
            this.changeHealth = function(amount, doer) {
                this.health += amount;
                return this.health <= 0;
            }
            ;
            // GET SCALE:
            this.getScale = function(sM, ig) {
                sM = sM || 1;
                return (this.scale * (this.isItem || this.type == 2 || this.type == 3 || this.type == 4 ? 1 : 0.6 * sM) * (ig ? 1 : this.colDiv));
            }
            ;
            // VISIBLE TO PLAYER:
            this.visibleToPlayer = function(player) {
                return (!this.hideFromEnemy || (this.owner && (this.owner == player || (this.owner.team && player.team == this.owner.team))));
            }
            ;
            // UPDATE:
            this.update = function(delta) {
                if (this.active) {
                    if (this.xWiggle) {
                        this.xWiggle *= Math.pow(0.99, delta);
                    }
                    if (this.yWiggle) {
                        this.yWiggle *= Math.pow(0.99, delta);
                    }
                    if (getEl("visual").value != "zyenith" && this.turnSpeed && (getEl("visual").value == "0" ? true : !this.pps)) {
                        this.dir += this.turnSpeed * delta;
                    }
                }
            }
            ;
        }
        ;
        /***/
    },
    /***/
    "./src/js/data/items.js": /*!******************************!*\
  !*** ./src/js/data/items.js ***!
  \******************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // ITEM GROUPS:
        module.exports.groups = [{
            id: 0,
            name: "food",
            layer: 0,
        }, {
            id: 1,
            name: "walls",
            place: true,
            limit: 30,
            layer: 0,
        }, {
            id: 2,
            name: "spikes",
            place: true,
            limit: 15,
            layer: 0,
        }, {
            id: 3,
            name: "mill",
            place: true,
            limit: 7,
            layer: 1,
        }, {
            id: 4,
            name: "mine",
            place: true,
            limit: 1,
            layer: 0,
        }, {
            id: 5,
            name: "trap",
            place: true,
            limit: 6,
            layer: -1,
        }, {
            id: 6,
            name: "booster",
            place: true,
            limit: 12,
            layer: -1,
        }, {
            id: 7,
            name: "turret",
            place: true,
            limit: 2,
            layer: 1,
        }, {
            id: 8,
            name: "watchtower",
            place: true,
            limit: 12,
            layer: 1,
        }, {
            id: 9,
            name: "buff",
            place: true,
            limit: 4,
            layer: -1,
        }, {
            id: 10,
            name: "spawn",
            place: true,
            limit: 1,
            layer: -1,
        }, {
            id: 11,
            name: "sapling",
            place: true,
            limit: 2,
            layer: 0,
        }, {
            id: 12,
            name: "blocker",
            place: true,
            limit: 3,
            layer: -1,
        }, {
            id: 13,
            name: "teleporter",
            place: true,
            limit: 2,
            layer: -1,
        }, ];
        // PROJECTILES:
        exports.projectiles = [{
            indx: 0,
            layer: 0,
            src: "arrow_1",
            dmg: 25,
            speed: 1.6,
            scale: 103,
            range: 1000,
        }, {
            indx: 1,
            layer: 1,
            dmg: 25,
            scale: 20,
        }, {
            indx: 0,
            layer: 0,
            src: "arrow_1",
            dmg: 35,
            speed: 2.5,
            scale: 103,
            range: 1200,
        }, {
            indx: 0,
            layer: 0,
            src: "arrow_1",
            dmg: 30,
            speed: 2,
            scale: 103,
            range: 1200,
        }, {
            indx: 1,
            layer: 1,
            dmg: 16,
            scale: 20,
        }, {
            indx: 0,
            layer: 0,
            src: "bullet_1",
            dmg: 50,
            speed: 3.6,
            scale: 160,
            range: 1400,
        }, ];
        // WEAPONS:
        exports.weapons = [{
            id: 0,
            type: 0,
            name: "tool hammer",
            desc: "tool for gathering all resources",
            src: "hammer_1",
            length: 140,
            width: 140,
            xOff: -3,
            yOff: 18,
            dmg: 25,
            dmg2: 25,
            range: 65,
            gather: 1,
            speed: 300,
        }, {
            id: 1,
            type: 0,
            age: 2,
            name: "hand axe",
            desc: "gathers resources at a higher rate",
            src: "axe_1",
            length: 140,
            width: 140,
            xOff: 3,
            yOff: 24,
            dmg: 30,
            dmg2: 30,
            spdMult: 1,
            range: 70,
            gather: 2,
            speed: 400,
        }, {
            id: 2,
            type: 0,
            age: 8,
            pre: 1,
            name: "great axe",
            desc: "deal more damage and gather more resources",
            src: "great_axe_1",
            length: 140,
            width: 140,
            xOff: -8,
            yOff: 25,
            dmg: 35,
            dmg2: 35,
            spdMult: 1,
            range: 75,
            gather: 4,
            speed: 400,
        }, {
            id: 3,
            type: 0,
            age: 2,
            name: "short sword",
            desc: "increased attack power but slower move speed",
            src: "sword_1",
            iPad: 1.3,
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 46,
            dmg: 35,
            dmg2: 35,
            spdMult: 0.85,
            range: 110,
            gather: 1,
            speed: 300,
        }, {
            id: 4,
            type: 0,
            age: 8,
            pre: 3,
            name: "katana",
            desc: "greater range and damage",
            src: "samurai_1",
            iPad: 1.3,
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 59,
            dmg: 40,
            dmg2: 40,
            spdMult: 0.8,
            range: 118,
            gather: 1,
            speed: 300,
        }, {
            id: 5,
            type: 0,
            age: 2,
            name: "polearm",
            desc: "long range melee weapon",
            src: "spear_1",
            iPad: 1.3,
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 53,
            dmg: 45,
            dmg2: 45,
            knock: 0.2,
            spdMult: 0.82,
            range: 142,
            gather: 1,
            speed: 700,
        }, {
            id: 6,
            type: 0,
            age: 2,
            name: "bat",
            desc: "fast long range melee weapon",
            src: "bat_1",
            iPad: 1.3,
            length: 110,
            width: 180,
            xOff: -8,
            yOff: 53,
            dmg: 20,
            dmg2: 20,
            knock: 0.7,
            range: 110,
            gather: 1,
            speed: 300,
        }, {
            id: 7,
            type: 0,
            age: 2,
            name: "daggers",
            desc: "really fast short range weapon",
            src: "dagger_1",
            iPad: 0.8,
            length: 110,
            width: 110,
            xOff: 18,
            yOff: 0,
            dmg: 20,
            dmg2: 20,
            knock: 0.1,
            range: 65,
            gather: 1,
            hitSlow: 0.1,
            spdMult: 1.13,
            speed: 100,
        }, {
            id: 8,
            type: 0,
            age: 2,
            name: "stick",
            desc: "great for gathering but very weak",
            src: "stick_1",
            length: 140,
            width: 140,
            xOff: 3,
            yOff: 24,
            dmg: 1,
            dmg2: 1,
            spdMult: 1,
            range: 70,
            gather: 7,
            speed: 400,
        }, {
            id: 9,
            type: 1,
            age: 6,
            name: "hunting bow",
            desc: "bow used for ranged combat and hunting",
            src: "bow_1",
            req: ["wood", 4],
            length: 120,
            width: 120,
            xOff: -6,
            yOff: 0,
            Pdmg: 25,
            projectile: 0,
            spdMult: 0.75,
            speed: 600,
        }, {
            id: 10,
            type: 1,
            age: 6,
            name: "great hammer",
            desc: "hammer used for destroying structures",
            src: "great_hammer_1",
            length: 140,
            width: 140,
            xOff: -9,
            yOff: 25,
            dmg: 10,
            Pdmg: 10,
            spdMult: 0.88,
            range: 75,
            sDmg: 7.5,
            gather: 1,
            speed: 400,
        }, {
            id: 11,
            type: 1,
            age: 6,
            name: "wooden shield",
            desc: "blocks projectiles and reduces melee damage",
            src: "shield_1",
            length: 120,
            width: 120,
            shield: 0.2,
            xOff: 6,
            yOff: 0,
            Pdmg: 0,
            spdMult: 0.7,
        }, {
            id: 12,
            type: 1,
            age: 8,
            pre: 9,
            name: "crossbow",
            desc: "deals more damage and has greater range",
            src: "crossbow_1",
            req: ["wood", 5],
            aboveHand: true,
            armS: 0.75,
            length: 120,
            width: 120,
            xOff: -4,
            yOff: 0,
            Pdmg: 35,
            projectile: 2,
            spdMult: 0.7,
            speed: 700,
        }, {
            id: 13,
            type: 1,
            age: 9,
            pre: 12,
            name: "repeater crossbow",
            desc: "high firerate crossbow with reduced damage",
            src: "crossbow_2",
            req: ["wood", 10],
            aboveHand: true,
            armS: 0.75,
            length: 120,
            width: 120,
            xOff: -4,
            yOff: 0,
            Pdmg: 30,
            projectile: 3,
            spdMult: 0.7,
            speed: 230,
        }, {
            id: 14,
            type: 1,
            age: 6,
            name: "mc grabby",
            desc: "steals resources from enemies",
            src: "grab_1",
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 53,
            dmg: 0,
            Pdmg: 0,
            steal: 250,
            knock: 0.2,
            spdMult: 1.05,
            range: 125,
            gather: 0,
            speed: 700,
        }, {
            id: 15,
            type: 1,
            age: 9,
            pre: 12,
            name: "musket",
            desc: "slow firerate but high damage and range",
            src: "musket_1",
            req: ["stone", 10],
            aboveHand: true,
            rec: 0.35,
            armS: 0.6,
            hndS: 0.3,
            hndD: 1.6,
            length: 205,
            width: 205,
            xOff: 25,
            yOff: 0,
            Pdmg: 50,
            projectile: 5,
            hideProjectile: true,
            spdMult: 0.6,
            speed: 1500,
        }, ];
        // ITEMS:
        module.exports.list = [{
            group: module.exports.groups[0],
            name: "apple",
            desc: "restores 20 health when consumed",
            req: ["food", 10],
            consume: function(doer) {
                return doer.changeHealth(20, doer);
            },
            scale: 22,
            holdOffset: 15,
            healing: 20,
        }, {
            age: 3,
            group: module.exports.groups[0],
            name: "cookie",
            desc: "restores 40 health when consumed",
            req: ["food", 15],
            consume: function(doer) {
                return doer.changeHealth(40, doer);
            },
            scale: 27,
            holdOffset: 15,
            healing: 40,
        }, {
            age: 7,
            group: module.exports.groups[0],
            name: "cheese",
            desc: "restores 30 health and another 50 over 5 seconds",
            req: ["food", 25],
            consume: function(doer) {
                if (doer.changeHealth(30, doer) || doer.health < 100) {
                    doer.dmgOverTime.dmg = -10;
                    doer.dmgOverTime.doer = doer;
                    doer.dmgOverTime.time = 5;
                    return true;
                }
                return false;
            },
            scale: 27,
            holdOffset: 15,
            healing: 30,
        }, {
            group: module.exports.groups[1],
            name: "wood wall",
            desc: "provides protection for your village",
            req: ["wood", 10],
            projDmg: true,
            health: 380,
            scale: 50,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            age: 3,
            group: module.exports.groups[1],
            name: "stone wall",
            desc: "provides improved protection for your village",
            req: ["stone", 25],
            health: 900,
            scale: 50,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            age: 7,
            group: module.exports.groups[1],
            name: "castle wall",
            desc: "provides powerful protection for your village",
            req: ["stone", 35],
            health: 1500,
            scale: 52,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            group: module.exports.groups[2],
            name: "spikes",
            desc: "damages enemies when they touch them",
            req: ["wood", 20, "stone", 5],
            health: 400,
            dmg: 20,
            scale: 49,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5,
        }, {
            age: 5,
            group: module.exports.groups[2],
            name: "greater spikes",
            desc: "damages enemies when they touch them",
            req: ["wood", 30, "stone", 10],
            health: 500,
            dmg: 35,
            scale: 52,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5,
        }, {
            age: 9,
            group: module.exports.groups[2],
            name: "poison spikes",
            desc: "poisons enemies when they touch them",
            req: ["wood", 35, "stone", 15],
            health: 600,
            dmg: 30,
            pDmg: 5,
            scale: 52,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5,
        }, {
            age: 9,
            group: module.exports.groups[2],
            name: "spinning spikes",
            desc: "damages enemies when they touch them",
            req: ["wood", 30, "stone", 20],
            health: 500,
            dmg: 45,
            turnSpeed: 0.003,
            scale: 52,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5,
        }, {
            group: module.exports.groups[3],
            name: "windmill",
            desc: "generates gold over time",
            req: ["wood", 50, "stone", 10],
            health: 400,
            pps: 1,
            turnSpeed: 0.0016,
            spritePadding: 25,
            iconLineMult: 12,
            scale: 45,
            holdOffset: 20,
            placeOffset: 5,
        }, {
            age: 5,
            group: module.exports.groups[3],
            name: "faster windmill",
            desc: "generates more gold over time",
            req: ["wood", 60, "stone", 20],
            health: 500,
            pps: 1.5,
            turnSpeed: 0.0025,
            spritePadding: 25,
            iconLineMult: 12,
            scale: 47,
            holdOffset: 20,
            placeOffset: 5,
        }, {
            age: 8,
            group: module.exports.groups[3],
            name: "power mill",
            desc: "generates more gold over time",
            req: ["wood", 100, "stone", 50],
            health: 800,
            pps: 2,
            turnSpeed: 0.005,
            spritePadding: 25,
            iconLineMult: 12,
            scale: 47,
            holdOffset: 20,
            placeOffset: 5,
        }, {
            age: 5,
            group: module.exports.groups[4],
            type: 2,
            name: "mine",
            desc: "allows you to mine stone",
            req: ["wood", 20, "stone", 100],
            iconLineMult: 12,
            scale: 65,
            holdOffset: 20,
            placeOffset: 0,
        }, {
            age: 5,
            group: module.exports.groups[11],
            type: 0,
            name: "sapling",
            desc: "allows you to farm wood",
            req: ["wood", 150],
            iconLineMult: 12,
            colDiv: 0.5,
            scale: 110,
            holdOffset: 50,
            placeOffset: -15,
        }, {
            age: 4,
            group: module.exports.groups[5],
            name: "pit trap",
            desc: "pit that traps enemies if they walk over it",
            req: ["wood", 30, "stone", 30],
            trap: true,
            ignoreCollision: true,
            hideFromEnemy: true,
            health: 500,
            colDiv: 0.2,
            scale: 50,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            age: 4,
            group: module.exports.groups[6],
            name: "boost pad",
            desc: "provides boost when stepped on",
            req: ["stone", 20, "wood", 5],
            ignoreCollision: true,
            boostSpeed: 1.5,
            health: 150,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            age: 7,
            group: module.exports.groups[7],
            doUpdate: true,
            name: "turret",
            desc: "defensive structure that shoots at enemies",
            req: ["wood", 200, "stone", 150],
            health: 800,
            projectile: 1,
            shootRange: 700,
            shootRate: 2200,
            scale: 43,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            age: 7,
            group: module.exports.groups[8],
            name: "platform",
            desc: "platform to shoot over walls and cross over water",
            req: ["wood", 20],
            ignoreCollision: true,
            zIndex: 1,
            health: 300,
            scale: 43,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            age: 7,
            group: module.exports.groups[9],
            name: "healing pad",
            desc: "standing on it will slowly heal you",
            req: ["wood", 30, "food", 10],
            ignoreCollision: true,
            healCol: 15,
            health: 400,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            age: 9,
            group: module.exports.groups[10],
            name: "spawn pad",
            desc: "you will spawn here when you die but it will dissapear",
            req: ["wood", 100, "stone", 100],
            health: 400,
            ignoreCollision: true,
            spawnPoint: true,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            age: 7,
            group: module.exports.groups[12],
            name: "blocker",
            desc: "blocks building in radius",
            req: ["wood", 30, "stone", 25],
            ignoreCollision: true,
            blocker: 300,
            health: 400,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
        }, {
            age: 7,
            group: module.exports.groups[13],
            name: "teleporter",
            desc: "teleports you to a random point on the map",
            req: ["wood", 60, "stone", 60],
            ignoreCollision: true,
            teleport: true,
            health: 200,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
        }, ];
        // ASSIGN IDS:
        for (var i = 0; i < module.exports.list.length; ++i) {
            module.exports.list[i].id = i;
            if (module.exports.list[i].pre)
                module.exports.list[i].pre = i - module.exports.list[i].pre;
        }
        // TROLOLOLOL:
        if (typeof window !== "undefined") {
            function shuffle(a) {
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [a[i],a[j]] = [a[j], a[i]];
                }
                return a;
            }
        }
        /***/
    },
    /***/
    "./src/js/data/mapManager.js": /*!***********************************!*\
  !*** ./src/js/data/mapManager.js ***!
  \***********************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // GLOBAL MAPMANAGER:
        module.exports = {};
        /***/
    },
    /***/
    "./src/js/data/objectManager.js": /*!**************************************!*\
  !*** ./src/js/data/objectManager.js ***!
  \**************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        var mathFloor = Math.floor;
        var mathABS = Math.abs;
        var mathCOS = Math.cos;
        var mathSIN = Math.sin;
        var mathPOW = Math.pow;
        var mathSQRT = Math.sqrt;
        module.exports = function(GameObject, gameObjects, UTILS, config, players, server) {
            this.objects = gameObjects;
            this.grids = {};
            this.updateObjects = [];
            // SET OBJECT GRIDS:
            var tmpX, tmpY;
            var tmpS = config.mapScale / config.colGrid;
            this.setObjectGrids = function(obj) {
                var objX = Math.min(config.mapScale, Math.max(0, obj.x));
                var objY = Math.min(config.mapScale, Math.max(0, obj.y));
                for (var x = 0; x < config.colGrid; ++x) {
                    tmpX = x * tmpS;
                    for (var y = 0; y < config.colGrid; ++y) {
                        tmpY = y * tmpS;
                        if (objX + obj.scale >= tmpX && objX - obj.scale <= tmpX + tmpS && objY + obj.scale >= tmpY && objY - obj.scale <= tmpY + tmpS) {
                            if (!this.grids[x + "_" + y])
                                this.grids[x + "_" + y] = [];
                            this.grids[x + "_" + y].push(obj);
                            obj.gridLocations.push(x + "_" + y);
                        }
                    }
                }
            }
            ;
            // REMOVE OBJECT FROM GRID:
            this.removeObjGrid = function(obj) {
                var tmpIndx;
                for (var i = 0; i < obj.gridLocations.length; ++i) {
                    tmpIndx = this.grids[obj.gridLocations[i]].indexOf(obj);
                    if (tmpIndx >= 0) {
                        this.grids[obj.gridLocations[i]].splice(tmpIndx, 1);
                    }
                }
            }
            ;
            // DISABLE OBJ:
            this.disableObj = function(obj) {
                obj.active = false;
                if (server) {
                    if (obj.owner && obj.pps)
                        obj.owner.pps -= obj.pps;
                    this.removeObjGrid(obj);
                    var tmpIndx = this.updateObjects.indexOf(obj);
                    if (tmpIndx >= 0) {
                        this.updateObjects.splice(tmpIndx, 1);
                    }
                }
            }
            ;
            // HIT OBJECT:
            this.hitObj = function(tmpObj, tmpDir) {
                for (var p = 0; p < players.length; ++p) {
                    if (players[p].active) {
                        if (tmpObj.sentTo[players[p].id]) {
                            if (!tmpObj.active)
                                server.send(players[p].id, "12", tmpObj.sid);
                            else if (players[p].canSee(tmpObj))
                                server.send(players[p].id, "8", UTILS.fixTo(tmpDir, 1), tmpObj.sid);
                        }
                        if (!tmpObj.active && tmpObj.owner == players[p])
                            players[p].changeItemCount(tmpObj.group.id, -1);
                    }
                }
            }
            ;
            // GET GRID ARRAY:
            var tmpArray = [];
            var tmpGrid;
            this.getGridArrays = function(xPos, yPos, s) {
                tmpX = mathFloor(xPos / tmpS);
                tmpY = mathFloor(yPos / tmpS);
                tmpArray.length = 0;
                try {
                    if (this.grids[tmpX + "_" + tmpY])
                        tmpArray.push(this.grids[tmpX + "_" + tmpY]);
                    if (xPos + s >= (tmpX + 1) * tmpS) {
                        // RIGHT
                        tmpGrid = this.grids[tmpX + 1 + "_" + tmpY];
                        if (tmpGrid)
                            tmpArray.push(tmpGrid);
                        if (tmpY && yPos - s <= tmpY * tmpS) {
                            // TOP RIGHT
                            tmpGrid = this.grids[tmpX + 1 + "_" + (tmpY - 1)];
                            if (tmpGrid)
                                tmpArray.push(tmpGrid);
                        } else if (yPos + s >= (tmpY + 1) * tmpS) {
                            // BOTTOM RIGHT
                            tmpGrid = this.grids[tmpX + 1 + "_" + (tmpY + 1)];
                            if (tmpGrid)
                                tmpArray.push(tmpGrid);
                        }
                    }
                    if (tmpX && xPos - s <= tmpX * tmpS) {
                        // LEFT
                        tmpGrid = this.grids[tmpX - 1 + "_" + tmpY];
                        if (tmpGrid)
                            tmpArray.push(tmpGrid);
                        if (tmpY && yPos - s <= tmpY * tmpS) {
                            // TOP LEFT
                            tmpGrid = this.grids[tmpX - 1 + "_" + (tmpY - 1)];
                            if (tmpGrid)
                                tmpArray.push(tmpGrid);
                        } else if (yPos + s >= (tmpY + 1) * tmpS) {
                            // BOTTOM LEFT
                            tmpGrid = this.grids[tmpX - 1 + "_" + (tmpY + 1)];
                            if (tmpGrid)
                                tmpArray.push(tmpGrid);
                        }
                    }
                    if (yPos + s >= (tmpY + 1) * tmpS) {
                        // BOTTOM
                        tmpGrid = this.grids[tmpX + "_" + (tmpY + 1)];
                        if (tmpGrid)
                            tmpArray.push(tmpGrid);
                    }
                    if (tmpY && yPos - s <= tmpY * tmpS) {
                        // TOP
                        tmpGrid = this.grids[tmpX + "_" + (tmpY - 1)];
                        if (tmpGrid)
                            tmpArray.push(tmpGrid);
                    }
                } catch (e) {}
                return tmpArray;
            }
            ;
            // ADD NEW:
            var tmpObj;
            this.add = function(sid, x, y, dir, s, type, data, setSID, owner) {
                tmpObj = gameObjects.find((tmp)=>tmp.sid == sid);
                if (!tmpObj) {
                    tmpObj = gameObjects.find((tmp)=>!tmp.active);
                    if (!tmpObj) {
                        tmpObj = new GameObject(sid);
                        gameObjects.push(tmpObj);
                    }
                }
                if (setSID)
                    tmpObj.sid = sid;
                tmpObj.init(x, y, dir, s, type, data, owner);
                if (server) {
                    this.setObjectGrids(tmpObj);
                    if (tmpObj.doUpdate)
                        this.updateObjects.push(tmpObj);
                }
            }
            ;
            // DISABLE BY SID:
            this.disableBySid = function(sid) {
                let find = gameObjects.find((tmp)=>tmp.sid == sid);
                if (find) {
                    this.disableObj(find);
                }
            }
            ;
            // REMOVE ALL FROM PLAYER:
            this.removeAllItems = function(sid, server) {
                gameObjects.filter((tmp)=>tmp.active && tmp.owner && tmp.owner.sid == sid).forEach((tmp)=>this.disableObj(tmp));
                if (server) {
                    server.broadcast("13", sid);
                }
            }
            ;
            // FETCH SPAWN OBJECT:
            this.fetchSpawnObj = function(sid) {
                var tmpLoc = null;
                for (var i = 0; i < gameObjects.length; ++i) {
                    tmpObj = gameObjects[i];
                    if (tmpObj.active && tmpObj.owner && tmpObj.owner.sid == sid && tmpObj.spawnPoint) {
                        tmpLoc = [tmpObj.x, tmpObj.y];
                        this.disableObj(tmpObj);
                        server.broadcast("12", tmpObj.sid);
                        if (tmpObj.owner) {
                            tmpObj.owner.changeItemCount(tmpObj.group.id, -1);
                        }
                        break;
                    }
                }
                return tmpLoc;
            }
            ;
            // CHECK IF PLACABLE:
            this.checkItemLocation = function(x, y, s, sM, indx, ignoreWater, placer) {
                let cantPlace = gameObjects.find((tmp)=>tmp.active && UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem)));
                if (cantPlace) {
                    return false;
                }
                if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) {
                    return false;
                }
                return true;
            }
            ;
            // ADD PROJECTILE:
            this.addProjectile = function(x, y, dir, range, indx) {
                var tmpData = items.projectiles[indx];
                var tmpProj = projectiles.find((tmp)=>!tmp.active);
                if (!tmpProj) {
                    tmpProj = new Projectile(players,UTILS);
                    projectiles.push(tmpProj);
                }
                tmpProj.init(indx, x, y, dir, tmpData.speed, range, tmpData.scale);
            }
            ;
            // CHECK PLAYER COLLISION:
            this.checkCollision = function(player, other, delta) {
                delta = delta || 1;
                var dx = player.x - other.x;
                var dy = player.y - other.y;
                var tmpLen = player.scale + other.scale;
                if (mathABS(dx) <= tmpLen || mathABS(dy) <= tmpLen) {
                    tmpLen = player.scale + (other.getScale ? other.getScale() : other.scale);
                    var tmpInt = mathSQRT(dx * dx + dy * dy) - tmpLen;
                    if (tmpInt <= 0) {
                        if (!other.ignoreCollision) {
                            var tmpDir = UTILS.getDirection(player.x, player.y, other.x, other.y);
                            var tmpDist = UTILS.getDistance(player.x, player.y, other.x, other.y);
                            if (other.isPlayer) {
                                tmpInt = (tmpInt * -1) / 2;
                                player.x += tmpInt * mathCOS(tmpDir);
                                player.y += tmpInt * mathSIN(tmpDir);
                                other.x -= tmpInt * mathCOS(tmpDir);
                                other.y -= tmpInt * mathSIN(tmpDir);
                            } else {
                                player.x = other.x + tmpLen * mathCOS(tmpDir);
                                player.y = other.y + tmpLen * mathSIN(tmpDir);
                                player.xVel *= 0.75;
                                player.yVel *= 0.75;
                            }
                            if (other.dmg && other.owner != player && !(other.owner && other.owner.team && other.owner.team == player.team)) {
                                player.changeHealth(-other.dmg, other.owner, other);
                                var tmpSpd = 1.5 * (other.weightM || 1);
                                player.xVel += tmpSpd * mathCOS(tmpDir);
                                player.yVel += tmpSpd * mathSIN(tmpDir);
                                if (other.pDmg && !(player.skin && player.skin.poisonRes)) {
                                    player.dmgOverTime.dmg = other.pDmg;
                                    player.dmgOverTime.time = 5;
                                    player.dmgOverTime.doer = other.owner;
                                }
                                if (player.colDmg && other.health) {
                                    if (other.changeHealth(-player.colDmg))
                                        this.disableObj(other);
                                    this.hitObj(other, UTILS.getDirection(player.x, player.y, other.x, other.y));
                                }
                            }
                        } else if (other.trap && !player.noTrap && other.owner != player && !(other.owner && other.owner.team && other.owner.team == player.team)) {
                            player.lockMove = true;
                            other.hideFromEnemy = false;
                        } else if (other.boostSpeed) {
                            player.xVel += delta * other.boostSpeed * (other.weightM || 1) * mathCOS(other.dir);
                            player.yVel += delta * other.boostSpeed * (other.weightM || 1) * mathSIN(other.dir);
                        } else if (other.healCol) {
                            player.healCol = other.healCol;
                        } else if (other.teleport) {
                            player.x = UTILS.randInt(0, config.mapScale);
                            player.y = UTILS.randInt(0, config.mapScale);
                        }
                        if (other.zIndex > player.zIndex)
                            player.zIndex = other.zIndex;
                        return true;
                    }
                }
                return false;
            }
            ;
        }
        ;
        /***/
    },
    /***/
    "./src/js/data/player.js": /*!*******************************!*\
  !*** ./src/js/data/player.js ***!
  \*******************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        var LangFilter = __webpack_require__(/*! bad-words */
        "./node_modules/bad-words/lib/badwords.js");
        var langFilter = new LangFilter();
        var newProfane = ["jew", "black", "baby", "child", "white", "porn", "pedo", "trump", "clinton", "hitler", "nazi", "gay", "pride", "sex", "pleasure", "touch", "poo", "kids", "rape", "white power", "nigga", "nig nog", "doggy", "rapist", "boner", "nigger", "nigg", "finger", "nogger", "nagger", "nig", "fag", "gai", "pole", "stripper", "penis", "vagina", "pussy", "nazi", "hitler", "stalin", "burn", "chamber", "cock", "peen", "dick", "spick", "nieger", "die", "satan", "n|ig", "nlg", "cunt", "c0ck", "fag", "lick", "condom", "anal", "shit", "phile", "little", "kids", "free KR", "tiny", "sidney", "ass", "kill", ".io", "(dot)", "[dot]", "mini", "whiore", "whore", "faggot", "github", "1337", "666", "satan", "senpa", "discord", "d1scord", "mistik", ".io", "senpa.io", "sidney", "sid", "senpaio", "vries", "asa", ];
        langFilter.addWords(...newProfane);
        var mathABS = Math.abs;
        var mathCOS = Math.cos;
        var mathSIN = Math.sin;
        var mathPOW = Math.pow;
        var mathSQRT = Math.sqrt;
        module.exports = function(id, sid, config, UTILS, projectileManager, objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
            this.id = id;
            this.sid = sid;
            this.tmpScore = 0;
            this.team = null;
            this.skinIndex = 0;
            this.tailIndex = 0;
            this.hitTime = 0;
            this.tails = {};
            for (var i = 0; i < accessories.length; ++i) {
                if (accessories[i].price <= 0)
                    this.tails[accessories[i].id] = 1;
            }
            this.skins = {};
            for (var i = 0; i < hats.length; ++i) {
                if (hats[i].price <= 0)
                    this.skins[hats[i].id] = 1;
            }
            this.points = 0;
            this.dt = 0;
            this.rt = 0;
            this.hidden = false;
            this.itemCounts = {};
            this.isPlayer = true;
            this.pps = 0;
            this.moveDir = undefined;
            this.skinRot = 0;
            this.lastPing = 0;
            this.iconIndex = 0;
            this.skinColor = 0;
            this.dangerShame = 5;
            this.projDist = 0;
            // SPAWN:
            this.spawn = function(moofoll) {
                // ADDED MODULES:
                this.finded = 0;
                this.syncThreats = 0;
                this.primaryIndex = undefined;
                this.secondaryIndex = undefined;
                this.primaryVariant = undefined;
                this.secondaryVariant = undefined;
                this.gatherIndex = undefined;
                this.shootIndex = undefined;
                this.bowThreat = {
                    9: 0,
                    12: 0,
                    13: 0,
                    15: 0,
                };
                this.aim2 = 0;
                this.dist2 = 0;
                this.aim3 = 0;
                this.dist3 = 0;
                this.notHere = false;
                this.bTick = 0;
                this.pCount = 0;
                this.hitted = false;
                this.anti = false;
                this.healSid = -1;
                this.damaged = false;
                this.active = true;
                this.alive = true;
                this.lockMove = false;
                this.lockDir = false;
                this.minimapCounter = 0;
                this.chatCountdown = 0;
                this.shameCount = 0;
                this.shameTimer = 0;
                this.antiClown = 4;
                this.maxShame = 7;
                this.sentTo = {};
                this.gathering = 0;
                this.shooting = {};
                this.autoGather = 0;
                this.animTime = 0;
                this.animSpeed = 0;
                this.mouseState = 0;
                this.buildIndex = -1;
                this.weaponIndex = 0;
                this.dmgOverTime = {};
                this.noMovTimer = 0;
                this.maxXP = 300;
                this.XP = 0;
                this.age = 1;
                this.kills = 0;
                this.upgrAge = 2;
                this.upgradePoints = 0;
                this.x = 0;
                this.y = 0;
                this.zIndex = 0;
                this.xVel = 0;
                this.yVel = 0;
                this.slowMult = 1;
                this.dir = 0;
                this.dirPlus = 0;
                this.targetDir = 0;
                this.targetAngle = 0;
                this.maxHealth = 100;
                this.health = this.maxHealth;
                this.scale = config.playerScale;
                this.speed = config.playerSpeed;
                this.resetMoveDir();
                this.resetResources(moofoll);
                this.firstItems = [0, 3, 6, 10];
                this.items = [0, 3, 6, 10];
                this.weapons = [0];
                this.shootCount = 0;
                this.weaponXP = [];
                this.reloads = {
                    0: 0,
                    1: 0,
                    2: 0,
                    3: 0,
                    4: 0,
                    5: 0,
                    6: 0,
                    7: 0,
                    8: 0,
                    9: 0,
                    10: 0,
                    11: 0,
                    12: 0,
                    13: 0,
                    14: 0,
                    15: 0,
                    53: 0,
                };
                this.oldReloads = {
                    0: 0,
                    1: 0,
                    2: 0,
                    3: 0,
                    4: 0,
                    5: 0,
                    6: 0,
                    7: 0,
                    8: 0,
                    9: 0,
                    10: 0,
                    11: 0,
                    12: 0,
                    13: 0,
                    14: 0,
                    15: 0,
                    53: 0,
                };
                this.turretReloaded = false;
                this.doTickUpdate = false;
                this.instaThreat = 0;
            }
            ;
            // RESET MOVE DIR:
            this.resetMoveDir = function() {
                this.moveDir = undefined;
            }
            ;
            // RESET RESOURCES:
            this.resetResources = function(moofoll) {
                for (var i = 0; i < config.resourceTypes.length; ++i) {
                    this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                }
            }
            ;
            // ADD ITEM:
            this.addItem = function(id) {
                var tmpItem = items.list[id];
                if (tmpItem) {
                    for (var i = 0; i < this.items.length; ++i) {
                        if (items.list[this.items[i]].group == tmpItem.group) {
                            if (this.buildIndex == this.items[i])
                                this.buildIndex = id;
                            this.items[i] = id;
                            return true;
                        }
                    }
                    this.items.push(id);
                    return true;
                }
                return false;
            }
            ;
            // SET USER DATA:
            this.setUserData = function(data) {
                if (data) {
                    // SET INITIAL NAME:
                    this.name = "unknown";
                    // VALIDATE NAME:
                    var name = data.name + "";
                    name = name.slice(0, config.maxNameLength);
                    name = name.replace(/[^\w:\(\)\/? -]+/gim, " ");
                    // USE SPACE SO WE CAN CHECK PROFANITY
                    name = name.replace(/[^\x00-\x7F]/g, " ");
                    name = name.trim();
                    // CHECK IF IS PROFANE:
                    var isProfane = false;
                    var convertedName = name.toLowerCase().replace(/\s/g, "").replace(/1/g, "i").replace(/0/g, "o").replace(/5/g, "s");
                    for (var word of langFilter.list) {
                        if (convertedName.indexOf(word) != -1) {
                            isProfane = true;
                            break;
                        }
                    }
                    if (name.length > 0 && !isProfane) {
                        this.name = name;
                    }
                    // SKIN:
                    this.skinColor = 0;
                    if (config.skinColors[data.skin])
                        this.skinColor = data.skin;
                }
            }
            ;
            // GET DATA TO SEND:
            this.getData = function() {
                return [this.id, this.sid, this.name, UTILS.fixTo(this.x, 2), UTILS.fixTo(this.y, 2), UTILS.fixTo(this.dir, 3), this.health, this.maxHealth, this.scale, this.skinColor, ];
            }
            ;
            // SET DATA:
            this.setData = function(data) {
                this.id = data[0];
                this.sid = data[1];
                this.name = data[2];
                this.x = data[3];
                this.y = data[4];
                this.dir = data[5];
                this.health = data[6];
                this.maxHealth = data[7];
                this.scale = data[8];
                this.skinColor = data[9];
            }
            ;
            // UPDATE:
            var timerCount = 0;
            this.update = function(delta) {
                if (!this.alive)
                    return;
                // SHAME SHAME SHAME:
                if (this.shameTimer > 0) {
                    this.shameTimer -= delta;
                    if (this.shameTimer <= 0) {
                        this.shameTimer = 0;
                        this.shameCount = 0;
                    }
                }
                // REGENS AND AUTO:
                timerCount -= delta;
                if (timerCount <= 0) {
                    var regenAmount = (this.skin && this.skin.healthRegen ? this.skin.healthRegen : 0) + (this.tail && this.tail.healthRegen ? this.tail.healthRegen : 0);
                    if (regenAmount) {
                        this.changeHealth(regenAmount, this);
                    }
                    if (this.dmgOverTime.dmg) {
                        this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer);
                        this.dmgOverTime.time -= 1;
                        if (this.dmgOverTime.time <= 0)
                            this.dmgOverTime.dmg = 0;
                    }
                    if (this.healCol) {
                        this.changeHealth(this.healCol, this);
                    }
                    timerCount = 1000;
                }
                // CHECK KILL:
                if (!this.alive)
                    return;
                // SLOWER:
                if (this.slowMult < 1) {
                    this.slowMult += 0.0008 * delta;
                    if (this.slowMult > 1)
                        this.slowMult = 1;
                }
                // MOVE:
                this.noMovTimer += delta;
                if (this.xVel || this.yVel)
                    this.noMovTimer = 0;
                if (this.lockMove) {
                    this.xVel = 0;
                    this.yVel = 0;
                } else {
                    var spdMult = (this.buildIndex >= 0 ? 0.5 : 1) * (items.weapons[this.weaponIndex].spdMult || 1) * (this.skin ? this.skin.spdMult || 1 : 1) * (this.tail ? this.tail.spdMult || 1 : 1) * (this.y <= config.snowBiomeTop ? this.skin && this.skin.coldM ? 1 : config.snowSpeed : 1) * this.slowMult;
                    if (!this.zIndex && this.y >= config.mapScale / 2 - config.riverWidth / 2 && this.y <= config.mapScale / 2 + config.riverWidth / 2) {
                        if (this.skin && this.skin.watrImm) {
                            spdMult *= 0.75;
                            this.xVel += config.waterCurrent * 0.4 * delta;
                        } else {
                            spdMult *= 0.33;
                            this.xVel += config.waterCurrent * delta;
                        }
                    }
                    var xVel = this.moveDir != undefined ? mathCOS(this.moveDir) : 0;
                    var yVel = this.moveDir != undefined ? mathSIN(this.moveDir) : 0;
                    var length = mathSQRT(xVel * xVel + yVel * yVel);
                    if (length != 0) {
                        xVel /= length;
                        yVel /= length;
                    }
                    if (xVel)
                        this.xVel += xVel * this.speed * spdMult * delta;
                    if (yVel)
                        this.yVel += yVel * this.speed * spdMult * delta;
                }
                // OBJECT COLL:
                this.zIndex = 0;
                this.lockMove = false;
                this.healCol = 0;
                var tmpList;
                var tmpSpeed = UTILS.getDistance(0, 0, this.xVel * delta, this.yVel * delta);
                var depth = Math.min(4, Math.max(1, Math.round(tmpSpeed / 40)));
                var tMlt = 1 / depth;
                for (var i = 0; i < depth; ++i) {
                    if (this.xVel)
                        this.x += this.xVel * delta * tMlt;
                    if (this.yVel)
                        this.y += this.yVel * delta * tMlt;
                    tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                    for (var x = 0; x < tmpList.length; ++x) {
                        for (var y = 0; y < tmpList[x].length; ++y) {
                            if (tmpList[x][y].active)
                                objectManager.checkCollision(this, tmpList[x][y], tMlt);
                        }
                    }
                }
                // PLAYER COLLISIONS:
                var tmpIndx = players.indexOf(this);
                for (var i = tmpIndx + 1; i < players.length; ++i) {
                    if (players[i] != this && players[i].alive)
                        objectManager.checkCollision(this, players[i]);
                }
                // DECEL:
                if (this.xVel) {
                    this.xVel *= mathPOW(config.playerDecel, delta);
                    if (this.xVel <= 0.01 && this.xVel >= -0.01)
                        this.xVel = 0;
                }
                if (this.yVel) {
                    this.yVel *= mathPOW(config.playerDecel, delta);
                    if (this.yVel <= 0.01 && this.yVel >= -0.01)
                        this.yVel = 0;
                }
                // MAP BOUNDARIES:
                if (this.x - this.scale < 0) {
                    this.x = this.scale;
                } else if (this.x + this.scale > config.mapScale) {
                    this.x = config.mapScale - this.scale;
                }
                if (this.y - this.scale < 0) {
                    this.y = this.scale;
                } else if (this.y + this.scale > config.mapScale) {
                    this.y = config.mapScale - this.scale;
                }
                // USE WEAPON OR TOOL:
                if (this.buildIndex < 0) {
                    if (this.reloads[this.weaponIndex] > 0) {
                        this.reloads[this.weaponIndex] -= delta;
                        this.gathering = this.mouseState;
                    } else if (this.gathering || this.autoGather) {
                        var worked = true;
                        if (items.weapons[this.weaponIndex].gather != undefined) {
                            this.gather(players);
                        } else if (items.weapons[this.weaponIndex].projectile != undefined && this.hasRes(items.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0)) {
                            this.useRes(items.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0);
                            this.noMovTimer = 0;
                            var tmpIndx = items.weapons[this.weaponIndex].projectile;
                            var projOffset = this.scale * 2;
                            var aMlt = this.skin && this.skin.aMlt ? this.skin.aMlt : 1;
                            if (items.weapons[this.weaponIndex].rec) {
                                this.xVel -= items.weapons[this.weaponIndex].rec * mathCOS(this.dir);
                                this.yVel -= items.weapons[this.weaponIndex].rec * mathSIN(this.dir);
                            }
                            projectileManager.addProjectile(this.x + projOffset * mathCOS(this.dir), this.y + projOffset * mathSIN(this.dir), this.dir, items.projectiles[tmpIndx].range * aMlt, items.projectiles[tmpIndx].speed * aMlt, tmpIndx, this, null, this.zIndex);
                        } else {
                            worked = false;
                        }
                        this.gathering = this.mouseState;
                        if (worked) {
                            this.reloads[this.weaponIndex] = items.weapons[this.weaponIndex].speed * (this.skin ? this.skin.atkSpd || 1 : 1);
                        }
                    }
                }
            }
            ;
            // ADD WEAPON XP:
            this.addWeaponXP = function(amnt) {
                if (!this.weaponXP[this.weaponIndex])
                    this.weaponXP[this.weaponIndex] = 0;
                this.weaponXP[this.weaponIndex] += amnt;
                if (this.weaponIndex == this.weapons[0]) {
                    getEl("priXP").innerHTML = "Primary XP: " + this.weaponXP[this.weapons[0]] + " / " + config.weaponXPs[this.weaponVariant].xp;
                } else if (this.weaponIndex == this.weapons[1]) {
                    getEl("secXP").innerHTML = "Secondary XP: " + this.weaponXP[this.weapons[1]] + " / " + config.weaponXPs[this.weaponVariant].xp;
                }
            }
            ;
            // EARN XP:
            this.earnXP = function(amount) {
                if (this.age < config.maxAge) {
                    this.XP += amount;
                    if (this.XP >= this.maxXP) {
                        if (this.age < config.maxAge) {
                            this.age++;
                            this.XP = 0;
                            this.maxXP *= 1.2;
                        } else {
                            this.XP = this.maxXP;
                        }
                        this.upgradePoints++;
                        server.send(this.id, "16", this.upgradePoints, this.upgrAge);
                        server.send(this.id, "15", this.XP, UTILS.fixTo(this.maxXP, 1), this.age);
                    } else {
                        server.send(this.id, "15", this.XP);
                    }
                }
            }
            ;
            // CHANGE HEALTH:
            this.changeHealth = function(amount, doer) {
                if (amount > 0 && this.health >= this.maxHealth)
                    return false;
                if (amount < 0 && this.skin)
                    amount *= this.skin.dmgMult || 1;
                if (amount < 0 && this.tail)
                    amount *= this.tail.dmgMult || 1;
                if (amount < 0)
                    this.hitTime = Date.now();
                this.health += amount;
                if (this.health > this.maxHealth) {
                    amount -= this.health - this.maxHealth;
                    this.health = this.maxHealth;
                }
                if (this.health <= 0)
                    this.kill(doer);
                for (var i = 0; i < players.length; ++i) {
                    if (this.sentTo[players[i].id])
                        server.send(players[i].id, "h", this.sid, Math.round(this.health));
                }
                if (doer && doer.canSee(this) && !(doer == this && amount < 0)) {
                    server.send(doer.id, "t", Math.round(this.x), Math.round(this.y), Math.round(-amount), 1);
                }
                return true;
            }
            ;
            // KILL:
            this.kill = function(doer) {
                if (doer && doer.alive) {
                    doer.kills++;
                    if (doer.skin && doer.skin.goldSteal)
                        scoreCallback(doer, Math.round(this.points / 2));
                    else
                        scoreCallback(doer, Math.round(this.age * 100 * (doer.skin && doer.skin.kScrM ? doer.skin.kScrM : 1)));
                    server.send(doer.id, "9", "kills", doer.kills, 1);
                }
                this.alive = false;
                server.send(this.id, "11");
                iconCallback();
            }
            ;
            // ADD RESOURCE:
            this.addResource = function(type, amount, auto) {
                if (!auto && amount > 0)
                    this.addWeaponXP(amount);
                if (type == 3) {
                    scoreCallback(this, amount, true);
                } else {
                    this[config.resourceTypes[type]] += amount;
                    server.send(this.id, "9", config.resourceTypes[type], this[config.resourceTypes[type]], 1);
                }
            }
            ;
            // CHANGE ITEM COUNT:
            this.changeItemCount = function(index, value) {
                this.itemCounts[index] = this.itemCounts[index] || 0;
                this.itemCounts[index] += value;
                server.send(this.id, "14", index, this.itemCounts[index]);
            }
            ;
            // BUILD:
            this.buildItem = function(item) {
                var tmpS = this.scale + item.scale + (item.placeOffset || 0);
                var tmpX = this.x + tmpS * mathCOS(this.dir);
                var tmpY = this.y + tmpS * mathSIN(this.dir);
                if (this.canBuild(item) && !(item.consume && this.skin && this.skin.noEat) && (item.consume || objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, this))) {
                    var worked = false;
                    if (item.consume) {
                        if (this.hitTime) {
                            var timeSinceHit = Date.now() - this.hitTime;
                            this.hitTime = 0;
                            if (timeSinceHit <= 120) {
                                this.shameCount++;
                                if (this.shameCount >= 8) {
                                    this.shameTimer = 30000;
                                    this.shameCount = 0;
                                }
                            } else {
                                this.shameCount -= 2;
                                if (this.shameCount <= 0) {
                                    this.shameCount = 0;
                                }
                            }
                        }
                        if (this.shameTimer <= 0)
                            worked = item.consume(this);
                    } else {
                        worked = true;
                        if (item.group.limit) {
                            this.changeItemCount(item.group.id, 1);
                        }
                        if (item.pps)
                            this.pps += item.pps;
                        objectManager.add(objectManager.objects.length, tmpX, tmpY, this.dir, item.scale, item.type, item, false, this);
                    }
                    if (worked) {
                        this.useRes(item);
                        this.buildIndex = -1;
                    }
                }
            }
            ;
            // HAS RESOURCES:
            this.hasRes = function(item, mult) {
                for (var i = 0; i < item.req.length; ) {
                    if (this[item.req[i]] < Math.round(item.req[i + 1] * (mult || 1)))
                        return false;
                    i += 2;
                }
                return true;
            }
            ;
            // USE RESOURCES:
            this.useRes = function(item, mult) {
                if (config.inSandbox)
                    return;
                for (var i = 0; i < item.req.length; ) {
                    this.addResource(config.resourceTypes.indexOf(item.req[i]), -Math.round(item.req[i + 1] * (mult || 1)));
                    i += 2;
                }
            }
            ;
            // CAN BUILD:
            this.canBuild = function(item) {
                if (config.inSandbox)
                    return true;
                if (item.group.limit && this.itemCounts[item.group.id] >= item.group.limit)
                    return false;
                return this.hasRes(item);
            }
            ;
            // GATHER:
            this.gather = function() {
                // SHOW:
                this.noMovTimer = 0;
                // SLOW MOVEMENT:
                this.slowMult -= items.weapons[this.weaponIndex].hitSlow || 0.3;
                if (this.slowMult < 0)
                    this.slowMult = 0;
                // VARIANT DMG:
                var tmpVariant = config.fetchVariant(this);
                var applyPoison = tmpVariant.poison;
                var variantDmg = tmpVariant.val;
                // CHECK IF HIT GAME OBJECT:
                var hitObjs = {};
                var tmpDist, tmpDir, tmpObj, hitSomething;
                var tmpList = objectManager.getGridArrays(this.x, this.y, items.weapons[this.weaponIndex].range);
                for (var t = 0; t < tmpList.length; ++t) {
                    for (var i = 0; i < tmpList[t].length; ++i) {
                        tmpObj = tmpList[t][i];
                        if (tmpObj.active && !tmpObj.dontGather && !hitObjs[tmpObj.sid] && tmpObj.visibleToPlayer(this)) {
                            tmpDist = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y) - tmpObj.scale;
                            if (tmpDist <= items.weapons[this.weaponIndex].range) {
                                tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                if (UTILS.getAngleDist(tmpDir, this.dir) <= config.gatherAngle) {
                                    hitObjs[tmpObj.sid] = 1;
                                    if (tmpObj.health) {
                                        if (tmpObj.changeHealth(-items.weapons[this.weaponIndex].dmg * variantDmg * (items.weapons[this.weaponIndex].sDmg || 1) * (this.skin && this.skin.bDmg ? this.skin.bDmg : 1), this)) {
                                            for (var x = 0; x < tmpObj.req.length; ) {
                                                this.addResource(config.resourceTypes.indexOf(tmpObj.req[x]), tmpObj.req[x + 1]);
                                                x += 2;
                                            }
                                            objectManager.disableObj(tmpObj);
                                        }
                                    } else {
                                        this.earnXP(4 * items.weapons[this.weaponIndex].gather);
                                        var count = items.weapons[this.weaponIndex].gather + (tmpObj.type == 3 ? 4 : 0);
                                        if (this.skin && this.skin.extraGold) {
                                            this.addResource(3, 1);
                                        }
                                        this.addResource(tmpObj.type, count);
                                    }
                                    hitSomething = true;
                                    objectManager.hitObj(tmpObj, tmpDir);
                                }
                            }
                        }
                    }
                }
                // CHECK IF HIT PLAYER:
                for (var i = 0; i < players.length + ais.length; ++i) {
                    tmpObj = players[i] || ais[i - players.length];
                    if (tmpObj != this && tmpObj.alive && !(tmpObj.team && tmpObj.team == this.team)) {
                        tmpDist = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y) - tmpObj.scale * 1.8;
                        if (tmpDist <= items.weapons[this.weaponIndex].range) {
                            tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                            if (UTILS.getAngleDist(tmpDir, this.dir) <= config.gatherAngle) {
                                // STEAL RESOURCES:
                                var stealCount = items.weapons[this.weaponIndex].steal;
                                if (stealCount && tmpObj.addResource) {
                                    stealCount = Math.min(tmpObj.points || 0, stealCount);
                                    this.addResource(3, stealCount);
                                    tmpObj.addResource(3, -stealCount);
                                }
                                // MELEE HIT PLAYER:
                                var dmgMlt = variantDmg;
                                if (tmpObj.weaponIndex != undefined && items.weapons[tmpObj.weaponIndex].shield && UTILS.getAngleDist(tmpDir + Math.PI, tmpObj.dir) <= config.shieldAngle) {
                                    dmgMlt = items.weapons[tmpObj.weaponIndex].shield;
                                }
                                var dmgVal = items.weapons[this.weaponIndex].dmg * (this.skin && this.skin.dmgMultO ? this.skin.dmgMultO : 1) * (this.tail && this.tail.dmgMultO ? this.tail.dmgMultO : 1);
                                var tmpSpd = 0.3 * (tmpObj.weightM || 1) + (items.weapons[this.weaponIndex].knock || 0);
                                tmpObj.xVel += tmpSpd * mathCOS(tmpDir);
                                tmpObj.yVel += tmpSpd * mathSIN(tmpDir);
                                if (this.skin && this.skin.healD)
                                    this.changeHealth(dmgVal * dmgMlt * this.skin.healD, this);
                                if (this.tail && this.tail.healD)
                                    this.changeHealth(dmgVal * dmgMlt * this.tail.healD, this);
                                if (tmpObj.skin && tmpObj.skin.dmg && dmgMlt == 1)
                                    this.changeHealth(-dmgVal * tmpObj.skin.dmg, tmpObj);
                                if (tmpObj.tail && tmpObj.tail.dmg && dmgMlt == 1)
                                    this.changeHealth(-dmgVal * tmpObj.tail.dmg, tmpObj);
                                if (tmpObj.dmgOverTime && this.skin && this.skin.poisonDmg && !(tmpObj.skin && tmpObj.skin.poisonRes)) {
                                    tmpObj.dmgOverTime.dmg = this.skin.poisonDmg;
                                    tmpObj.dmgOverTime.time = this.skin.poisonTime || 1;
                                    tmpObj.dmgOverTime.doer = this;
                                }
                                if (tmpObj.dmgOverTime && applyPoison && !(tmpObj.skin && tmpObj.skin.poisonRes)) {
                                    tmpObj.dmgOverTime.dmg = 5;
                                    tmpObj.dmgOverTime.time = 5;
                                    tmpObj.dmgOverTime.doer = this;
                                }
                                if (tmpObj.skin && tmpObj.skin.dmgK) {
                                    this.xVel -= tmpObj.skin.dmgK * mathCOS(tmpDir);
                                    this.yVel -= tmpObj.skin.dmgK * mathSIN(tmpDir);
                                }
                                tmpObj.changeHealth(-dmgVal * dmgMlt, this, this);
                            }
                        }
                    }
                }
                // SEND FOR ANIMATION:
                this.sendAnimation(hitSomething ? 1 : 0);
            }
            ;
            // SEND ANIMATION:
            this.sendAnimation = function(hit) {
                for (var i = 0; i < players.length; ++i) {
                    if (this.sentTo[players[i].id] && this.canSee(players[i])) {
                        server.send(players[i].id, "7", this.sid, hit ? 1 : 0, this.weaponIndex);
                    }
                }
            }
            ;
            // ANIMATE:
            var tmpRatio = 0;
            var animIndex = 0;
            this.animate = function(delta) {
                if (this.animTime > 0) {
                    this.animTime -= delta;
                    if (this.animTime <= 0) {
                        this.animTime = 0;
                        this.dirPlus = 0;
                        tmpRatio = 0;
                        animIndex = 0;
                    } else {
                        if (animIndex == 0) {
                            tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                            this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                            if (tmpRatio >= 1) {
                                tmpRatio = 1;
                                animIndex = 1;
                            }
                        } else {
                            tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                            this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                        }
                    }
                }
            }
            ;
            // GATHER ANIMATION:
            this.startAnim = function(didHit, index) {
                this.animTime = this.animSpeed = items.weapons[index].speed;
                this.targetAngle = didHit ? -config.hitAngle : -Math.PI;
                tmpRatio = 0;
                animIndex = 0;
            }
            ;
            // CAN SEE:
            this.canSee = function(other) {
                if (!other)
                    return false;
                if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer)
                    return false;
                var dx = mathABS(other.x - this.x) - other.scale;
                var dy = mathABS(other.y - this.y) - other.scale;
                return (dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3);
            }
            ;
        }
        ;
        /***/
    },
    /***/
    "./src/js/data/projectile.js": /*!***********************************!*\
  !*** ./src/js/data/projectile.js ***!
  \***********************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        module.exports = function(players, ais, objectManager, items, config, UTILS, server) {
            // INIT:
            this.init = function(indx, x, y, dir, spd, dmg, rng, scl, owner) {
                this.active = true;
                this.indx = indx;
                this.x = x;
                this.y = y;
                this.dir = dir;
                this.skipMov = true;
                this.speed = spd;
                this.dmg = dmg;
                this.scale = scl;
                this.range = rng;
                this.owner = owner;
                if (server)
                    this.sentTo = {};
            }
            ;
            // UPDATE:
            var objectsHit = [];
            var tmpObj;
            this.update = function(delta) {
                if (this.active) {
                    var tmpSpeed = this.speed * delta;
                    var tmpScale;
                    if (!this.skipMov) {
                        this.x += tmpSpeed * Math.cos(this.dir);
                        this.y += tmpSpeed * Math.sin(this.dir);
                        this.range -= tmpSpeed;
                        if (this.range <= 0) {
                            this.x += this.range * Math.cos(this.dir);
                            this.y += this.range * Math.sin(this.dir);
                            tmpSpeed = 1;
                            this.range = 0;
                            this.active = false;
                        }
                    } else {
                        this.skipMov = false;
                    }
                    if (server) {
                        for (var i = 0; i < players.length; ++i) {
                            if (!this.sentTo[players[i].id] && players[i].canSee(this)) {
                                this.sentTo[players[i].id] = 1;
                                server.send(players[i].id, "18", UTILS.fixTo(this.x, 1), UTILS.fixTo(this.y, 1), UTILS.fixTo(this.dir, 2), UTILS.fixTo(this.range, 1), this.speed, this.indx, this.layer, this.sid);
                            }
                        }
                        objectsHit.length = 0;
                        for (var i = 0; i < players.length + ais.length; ++i) {
                            tmpObj = players[i] || ais[i - players.length];
                            if (tmpObj.alive && tmpObj != this.owner && !(this.owner.team && tmpObj.team == this.owner.team)) {
                                if (UTILS.lineInRect(tmpObj.x - tmpObj.scale, tmpObj.y - tmpObj.scale, tmpObj.x + tmpObj.scale, tmpObj.y + tmpObj.scale, this.x, this.y, this.x + tmpSpeed * Math.cos(this.dir), this.y + tmpSpeed * Math.sin(this.dir))) {
                                    objectsHit.push(tmpObj);
                                }
                            }
                        }
                        var tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                        for (var x = 0; x < tmpList.length; ++x) {
                            for (var y = 0; y < tmpList[x].length; ++y) {
                                tmpObj = tmpList[x][y];
                                tmpScale = tmpObj.getScale();
                                if (tmpObj.active && !(this.ignoreObj == tmpObj.sid) && this.layer <= tmpObj.layer && objectsHit.indexOf(tmpObj) < 0 && !tmpObj.ignoreCollision && UTILS.lineInRect(tmpObj.x - tmpScale, tmpObj.y - tmpScale, tmpObj.x + tmpScale, tmpObj.y + tmpScale, this.x, this.y, this.x + tmpSpeed * Math.cos(this.dir), this.y + tmpSpeed * Math.sin(this.dir))) {
                                    objectsHit.push(tmpObj);
                                }
                            }
                        }
                        // HIT OBJECTS:
                        if (objectsHit.length > 0) {
                            var hitObj = null;
                            var shortDist = null;
                            var tmpDist = null;
                            for (var i = 0; i < objectsHit.length; ++i) {
                                tmpDist = UTILS.getDistance(this.x, this.y, objectsHit[i].x, objectsHit[i].y);
                                if (shortDist == null || tmpDist < shortDist) {
                                    shortDist = tmpDist;
                                    hitObj = objectsHit[i];
                                }
                            }
                            if (hitObj.isPlayer || hitObj.isAI) {
                                var tmpSd = 0.3 * (hitObj.weightM || 1);
                                hitObj.xVel += tmpSd * Math.cos(this.dir);
                                hitObj.yVel += tmpSd * Math.sin(this.dir);
                                if (hitObj.weaponIndex == undefined || !(items.weapons[hitObj.weaponIndex].shield && UTILS.getAngleDist(this.dir + Math.PI, hitObj.dir) <= config.shieldAngle)) {
                                    hitObj.changeHealth(-this.dmg, this.owner, this.owner);
                                }
                            } else {
                                if (hitObj.projDmg && hitObj.health && hitObj.changeHealth(-this.dmg)) {
                                    objectManager.disableObj(hitObj);
                                }
                                for (var i = 0; i < players.length; ++i) {
                                    if (players[i].active) {
                                        if (hitObj.sentTo[players[i].id]) {
                                            if (hitObj.active) {
                                                if (players[i].canSee(hitObj))
                                                    server.send(players[i].id, "8", UTILS.fixTo(this.dir, 2), hitObj.sid);
                                            } else {
                                                server.send(players[i].id, "12", hitObj.sid);
                                            }
                                        }
                                        if (!hitObj.active && hitObj.owner == players[i])
                                            players[i].changeItemCount(hitObj.group.id, -1);
                                    }
                                }
                            }
                            this.active = false;
                            for (var i = 0; i < players.length; ++i) {
                                if (this.sentTo[players[i].id])
                                    server.send(players[i].id, "19", this.sid, UTILS.fixTo(shortDist, 1));
                            }
                        }
                    }
                }
            }
            ;
        }
        ;
        /***/
    },
    /***/
    "./src/js/data/projectileManager.js": /*!******************************************!*\
  !*** ./src/js/data/projectileManager.js ***!
  \******************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        module.exports = function(Projectile, projectiles, players, ais, objectManager, items, config, UTILS, server) {
            this.addProjectile = function(x, y, dir, range, speed, indx, owner, ignoreObj, layer) {
                var tmpData = items.projectiles[indx];
                var tmpProj = projectiles.find((tmp)=>!tmp.active);
                if (!tmpProj) {
                    tmpProj = new Projectile(players,ais,objectManager,items,config,UTILS,server);
                    tmpProj.sid = projectiles.length;
                    projectiles.push(tmpProj);
                }
                tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner);
                tmpProj.ignoreObj = ignoreObj;
                tmpProj.layer = layer || tmpData.layer;
                tmpProj.src = tmpData.src;
                return tmpProj;
            }
            ;
        }
        ;
        /***/
    },
    /***/
    "./src/js/data/store.js": /*!******************************!*\
  !*** ./src/js/data/store.js ***!
  \******************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // STORE HATS:
        module.exports.hats = [{
            id: 45,
            name: "Shame!",
            dontSell: true,
            price: 0,
            scale: 120,
            desc: "hacks are for losers",
        }, {
            id: 51,
            name: "Moo Cap",
            price: 0,
            scale: 120,
            desc: "coolest mooer around",
        }, {
            id: 50,
            name: "Apple Cap",
            price: 0,
            scale: 120,
            desc: "apple farms remembers",
        }, {
            id: 28,
            name: "Moo Head",
            price: 0,
            scale: 120,
            desc: "no effect",
        }, {
            id: 29,
            name: "Pig Head",
            price: 0,
            scale: 120,
            desc: "no effect",
        }, {
            id: 30,
            name: "Fluff Head",
            price: 0,
            scale: 120,
            desc: "no effect",
        }, {
            id: 36,
            name: "Pandou Head",
            price: 0,
            scale: 120,
            desc: "no effect",
        }, {
            id: 37,
            name: "Bear Head",
            price: 0,
            scale: 120,
            desc: "no effect",
        }, {
            id: 38,
            name: "Monkey Head",
            price: 0,
            scale: 120,
            desc: "no effect",
        }, {
            id: 44,
            name: "Polar Head",
            price: 0,
            scale: 120,
            desc: "no effect",
        }, {
            id: 35,
            name: "Fez Hat",
            price: 0,
            scale: 120,
            desc: "no effect",
        }, {
            id: 42,
            name: "Enigma Hat",
            price: 0,
            scale: 120,
            desc: "join the enigma army",
        }, {
            id: 43,
            name: "Blitz Hat",
            price: 0,
            scale: 120,
            desc: "hey everybody i'm blitz",
        }, {
            id: 49,
            name: "Bob XIII Hat",
            price: 0,
            scale: 120,
            desc: "like and subscribe",
        }, {
            id: 57,
            name: "Pumpkin",
            price: 50,
            scale: 120,
            desc: "Spooooky",
        }, {
            id: 8,
            name: "Bummle Hat",
            price: 100,
            scale: 120,
            desc: "no effect",
        }, {
            id: 2,
            name: "Straw Hat",
            price: 500,
            scale: 120,
            desc: "no effect",
        }, {
            id: 15,
            name: "Winter Cap",
            price: 600,
            scale: 120,
            desc: "allows you to move at normal speed in snow",
            coldM: 1,
        }, {
            id: 5,
            name: "Cowboy Hat",
            price: 1000,
            scale: 120,
            desc: "no effect",
        }, {
            id: 4,
            name: "Ranger Hat",
            price: 2000,
            scale: 120,
            desc: "no effect",
        }, {
            id: 18,
            name: "Explorer Hat",
            price: 2000,
            scale: 120,
            desc: "no effect",
        }, {
            id: 31,
            name: "Flipper Hat",
            price: 2500,
            scale: 120,
            desc: "have more control while in water",
            watrImm: true,
        }, {
            id: 1,
            name: "Marksman Cap",
            price: 3000,
            scale: 120,
            desc: "increases arrow speed and range",
            aMlt: 1.3,
        }, {
            id: 10,
            name: "Bush Gear",
            price: 3000,
            scale: 160,
            desc: "allows you to disguise yourself as a bush",
        }, {
            id: 48,
            name: "Halo",
            price: 3000,
            scale: 120,
            desc: "no effect",
        }, {
            id: 6,
            name: "Soldier Helmet",
            price: 4000,
            scale: 120,
            desc: "reduces damage taken but slows movement",
            spdMult: 0.94,
            dmgMult: 0.75,
        }, {
            id: 23,
            name: "Anti Venom Gear",
            price: 4000,
            scale: 120,
            desc: "makes you immune to poison",
            poisonRes: 1,
        }, {
            id: 13,
            name: "Medic Gear",
            price: 5000,
            scale: 110,
            desc: "slowly regenerates health over time",
            healthRegen: 3,
        }, {
            id: 9,
            name: "Miners Helmet",
            price: 5000,
            scale: 120,
            desc: "earn 1 extra gold per resource",
            extraGold: 1,
        }, {
            id: 32,
            name: "Musketeer Hat",
            price: 5000,
            scale: 120,
            desc: "reduces cost of projectiles",
            projCost: 0.5,
        }, {
            id: 7,
            name: "Bull Helmet",
            price: 6000,
            scale: 120,
            desc: "increases damage done but drains health",
            healthRegen: -5,
            dmgMultO: 1.5,
            spdMult: 0.96,
        }, {
            id: 22,
            name: "Emp Helmet",
            price: 6000,
            scale: 120,
            desc: "turrets won't attack but you move slower",
            antiTurret: 1,
            spdMult: 0.7,
        }, {
            id: 12,
            name: "Booster Hat",
            price: 6000,
            scale: 120,
            desc: "increases your movement speed",
            spdMult: 1.16,
        }, {
            id: 26,
            name: "Barbarian Armor",
            price: 8000,
            scale: 120,
            desc: "knocks back enemies that attack you",
            dmgK: 0.6,
        }, {
            id: 21,
            name: "Plague Mask",
            price: 10000,
            scale: 120,
            desc: "melee attacks deal poison damage",
            poisonDmg: 5,
            poisonTime: 6,
        }, {
            id: 46,
            name: "Bull Mask",
            price: 10000,
            scale: 120,
            desc: "bulls won't target you unless you attack them",
            bullRepel: 1,
        }, {
            id: 14,
            name: "Windmill Hat",
            topSprite: true,
            price: 10000,
            scale: 120,
            desc: "generates points while worn",
            pps: 1.5,
        }, {
            id: 11,
            name: "Spike Gear",
            topSprite: true,
            price: 10000,
            scale: 120,
            desc: "deal damage to players that damage you",
            dmg: 0.45,
        }, {
            id: 53,
            name: "Turret Gear",
            topSprite: true,
            price: 10000,
            scale: 120,
            desc: "you become a walking turret",
            turret: {
                proj: 1,
                range: 700,
                rate: 2500,
            },
            spdMult: 0.7,
        }, {
            id: 20,
            name: "Samurai Armor",
            price: 12000,
            scale: 120,
            desc: "increased attack speed and fire rate",
            atkSpd: 0.78,
        }, {
            id: 58,
            name: "Dark Knight",
            price: 12000,
            scale: 120,
            desc: "restores health when you deal damage",
            healD: 0.4,
        }, {
            id: 27,
            name: "Scavenger Gear",
            price: 15000,
            scale: 120,
            desc: "earn double points for each kill",
            kScrM: 2,
        }, {
            id: 40,
            name: "Tank Gear",
            price: 15000,
            scale: 120,
            desc: "increased damage to buildings but slower movement",
            spdMult: 0.3,
            bDmg: 3.3,
        }, {
            id: 52,
            name: "Thief Gear",
            price: 15000,
            scale: 120,
            desc: "steal half of a players gold when you kill them",
            goldSteal: 0.5,
        }, {
            id: 55,
            name: "Bloodthirster",
            price: 20000,
            scale: 120,
            desc: "Restore Health when dealing damage. And increased damage",
            healD: 0.25,
            dmgMultO: 1.2,
        }, {
            id: 56,
            name: "Assassin Gear",
            price: 20000,
            scale: 120,
            desc: "Go invisible when not moving. Can't eat. Increased speed",
            noEat: true,
            spdMult: 1.1,
            invisTimer: 1000,
        }, ];
        // STORE ACCESSORIES:
        module.exports.accessories = [{
            id: 12,
            name: "Snowball",
            price: 1000,
            scale: 105,
            xOff: 18,
            desc: "no effect",
        }, {
            id: 9,
            name: "Tree Cape",
            price: 1000,
            scale: 90,
            desc: "no effect",
        }, {
            id: 10,
            name: "Stone Cape",
            price: 1000,
            scale: 90,
            desc: "no effect",
        }, {
            id: 3,
            name: "Cookie Cape",
            price: 1500,
            scale: 90,
            desc: "no effect",
        }, {
            id: 8,
            name: "Cow Cape",
            price: 2000,
            scale: 90,
            desc: "no effect",
        }, {
            id: 11,
            name: "Monkey Tail",
            price: 2000,
            scale: 97,
            xOff: 25,
            desc: "Super speed but reduced damage",
            spdMult: 1.35,
            dmgMultO: 0.2,
        }, {
            id: 17,
            name: "Apple Basket",
            price: 3000,
            scale: 80,
            xOff: 12,
            desc: "slowly regenerates health over time",
            healthRegen: 1,
        }, {
            id: 6,
            name: "Winter Cape",
            price: 3000,
            scale: 90,
            desc: "no effect",
        }, {
            id: 4,
            name: "Skull Cape",
            price: 4000,
            scale: 90,
            desc: "no effect",
        }, {
            id: 5,
            name: "Dash Cape",
            price: 5000,
            scale: 90,
            desc: "no effect",
        }, {
            id: 2,
            name: "Dragon Cape",
            price: 6000,
            scale: 90,
            desc: "no effect",
        }, {
            id: 1,
            name: "Super Cape",
            price: 8000,
            scale: 90,
            desc: "no effect",
        }, {
            id: 7,
            name: "Troll Cape",
            price: 8000,
            scale: 90,
            desc: "no effect",
        }, {
            id: 14,
            name: "Thorns",
            price: 10000,
            scale: 115,
            xOff: 20,
            desc: "no effect",
        }, {
            id: 15,
            name: "Blockades",
            price: 10000,
            scale: 95,
            xOff: 15,
            desc: "no effect",
        }, {
            id: 20,
            name: "Devils Tail",
            price: 10000,
            scale: 95,
            xOff: 20,
            desc: "no effect",
        }, {
            id: 16,
            name: "Sawblade",
            price: 12000,
            scale: 90,
            spin: true,
            xOff: 0,
            desc: "deal damage to players that damage you",
            dmg: 0.15,
        }, {
            id: 13,
            name: "Angel Wings",
            price: 15000,
            scale: 138,
            xOff: 22,
            desc: "slowly regenerates health over time",
            healthRegen: 3,
        }, {
            id: 19,
            name: "Shadow Wings",
            price: 15000,
            scale: 138,
            xOff: 22,
            desc: "increased movement speed",
            spdMult: 1.1,
        }, {
            id: 18,
            name: "Blood Wings",
            price: 20000,
            scale: 178,
            xOff: 26,
            desc: "restores health when you deal damage",
            healD: 0.2,
        }, {
            id: 21,
            name: "Corrupt X Wings",
            price: 20000,
            scale: 178,
            xOff: 26,
            desc: "deal damage to players that damage you",
            dmg: 0.25,
        }, ];
        /***/
    },
    /***/
    "./src/js/libs/animText.js": /*!*********************************!*\
  !*** ./src/js/libs/animText.js ***!
  \*********************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // ANIMATED TEXT:
        module.exports.AnimText = function() {
            // INIT:
            this.init = function(x, y, scale, speed, life, text, color) {
                this.x = x;
                this.y = y;
                this.randomX = Math.floor(Math.random() * 2);
                this.randomSpeed = Math.floor(Math.random() * 5);
                this.moveSpeed = 10;
                this.color = color;
                this.scale = scale;
                this.startScale = this.scale;
                this.maxScale = scale * 1.5;
                this.scaleSpeed = getEl("visual").value == "hans" ? 0.35 : 0.7;
                this.speed = speed;
                this.life = life;
                this.life2 = this.life;
                this.startLife = this.life;
                this.text = text;
                this.animation = 0;
                this.maxAnim = 100;
                this.acc = 1;
                this.acc2 = 1;
            }
            ;
            // UPDATE:
            this.update = function(delta) {
                if (this.life) {
                    this.life -= delta;
                    this.animation += 6;
                    if (getEl("visual").value == "me") {
                        if (this.animation < this.maxAnim) {
                            this.acc -= 0.1;
                            this.y -= this.speed * this.acc * delta;
                        } else {
                            this.life2 -= delta * 1.75;
                            this.acc += 0.15;
                            this.y += this.speed * this.acc * delta;
                        }
                        this.scale += this.scaleSpeed * delta;
                        if (this.scale >= this.maxScale) {
                            this.scale = this.maxScale;
                            this.scaleSpeed *= -1;
                        } else if (this.scale <= this.startScale) {
                            this.scale = this.startScale;
                            this.scaleSpeed = 0;
                        }
                    } else if (getEl("visual").value == "hans") {
                        if (this.animation < this.maxAnim) {
                            this.acc -= 0.05;
                            this.y -= this.speed * this.acc * delta;
                        } else {
                            this.life2 -= delta * 1.9;
                            this.acc += 0.05;
                            this.y += this.speed * this.acc * delta;
                        }
                        if (this.randomX == 1) {
                            this.x += this.moveSpeed;
                        } else if (this.randomX == 0) {
                            this.x -= this.moveSpeed;
                        }
                        this.moveSpeed = Math.max(0, this.moveSpeed - 1);
                        this.scale += this.scaleSpeed * delta;
                        if (this.scale >= this.maxScale) {
                            this.scale = this.maxScale;
                            this.scaleSpeed *= -1;
                        } else if (this.scale <= this.startScale) {
                            this.scaleSpeed = 0;
                            this.scale -= 0.1;
                        }
                    } else {
                        this.y -= this.speed * delta;
                        this.scale += this.scaleSpeed * delta;
                        if (this.scale >= this.maxScale) {
                            this.scale = this.maxScale;
                            this.scaleSpeed *= -1;
                        } else if (this.scale <= this.startScale) {
                            this.scale = this.startScale;
                            this.scaleSpeed = 0;
                        }
                    }
                    if (this.life <= 0) {
                        this.life = 0;
                    }
                }
            }
            ;
            // RENDER:
            this.render = function(ctxt, xOff, yOff) {
                if (getEl("visual").value == "me" || getEl("visual").value == "hans") {
                    ctxt.globalAlpha = Math.min(1, this.life2 / this.startLife);
                }
                ctxt.fillStyle = this.color;
                ctxt.font = this.scale + "px Hammersmith One";
                if (getEl("visual").value == "cele" || getEl("visual").value == "zeph") {
                    ctxt.strokeText(this.text, this.x - xOff, this.y - yOff);
                }
                ctxt.fillText(this.text, this.x - xOff, this.y - yOff);
                ctxt.globalAlpha = 1;
            }
            ;
        }
        ;
        // TEXT MANAGER:
        module.exports.TextManager = function() {
            this.texts = [];
            // UPDATE:
            this.update = function(delta, ctxt, xOff, yOff) {
                ctxt.textBaseline = "middle";
                ctxt.textAlign = "center";
                for (var i = 0; i < this.texts.length; ++i) {
                    if (this.texts[i].life) {
                        this.texts[i].update(delta);
                        this.texts[i].render(ctxt, xOff, yOff);
                    }
                }
            }
            ;
            // SHOW TEXT:
            this.showText = function(x, y, scale, speed, life, text, color) {
                var tmpText;
                for (var i = 0; i < this.texts.length; ++i) {
                    if (!this.texts[i].life) {
                        tmpText = this.texts[i];
                        break;
                    }
                }
                if (!tmpText) {
                    tmpText = new module.exports.AnimText();
                    this.texts.push(tmpText);
                }
                tmpText.init(x, y, scale, speed, life, text, color);
            }
            ;
        }
        ;
        /***/
    },
    /***/
    "./src/js/libs/io-client.js": /*!**********************************!*\
  !*** ./src/js/libs/io-client.js ***!
  \**********************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        var msgpack = __webpack_require__(/*! msgpack-lite */
        "./node_modules/msgpack-lite/lib/browser.js");
        var config = __webpack_require__(/*! ../config */
        "./src/js/config.js");
        module.exports = {
            socket: null,
            connected: false,
            socketId: -1,
            connect: function(address, callback, events) {
                if (this.socket)
                    return;
                // CREATE SOCKET:
                var _this = this;
                try {
                    var socketError = false;
                    var socketAddress = address;
                    this.socket = new WebSocket(socketAddress);
                    this.socket.binaryType = "arraybuffer";
                    this.socket.onmessage = function(message) {
                        // PARSE MESSAGE:
                        var data = new Uint8Array(message.data);
                        var parsed = msgpack.decode(data);
                        var type = parsed[0];
                        var data = parsed[1];
                        // CALL EVENT:
                        if (type == "io-init") {
                            _this.socketId = data[0];
                        } else {
                            events[type].apply(undefined, data);
                        }
                    }
                    ;
                    this.socket.onopen = function() {
                        _this.connected = true;
                        callback();
                    }
                    ;
                    this.socket.onclose = function(event) {
                        _this.connected = false;
                        if (event.code == 4001) {
                            callback("Invalid Connection");
                        } else if (!socketError) {
                            callback("disconnected");
                        }
                    }
                    ;
                    this.socket.onerror = function(error) {
                        if (this.socket && this.socket.readyState != WebSocket.OPEN) {
                            socketError = true;
                            console.error("Socket error", arguments);
                            callback("Socket error");
                        }
                    }
                    ;
                } catch (e) {
                    console.warn("Socket connection error:", e);
                    callback(e);
                }
            },
            send: function(type) {
                if (!this.connected)
                    return;
                if (!firstSend.min) {
                    firstSend.min = true;
                    setTimeout(()=>{
                        firstSend.min = false;
                        minPacket = 0;
                    }
                    , minTime);
                }
                if (!firstSend.sec) {
                    firstSend.sec = true;
                    setTimeout(()=>{
                        firstSend.sec = false;
                        secPacket = 0;
                    }
                    , secTime);
                }
                if ((getEl("ak").checked && secPacket < secMax && minPacket < minMax) || !getEl("ak").checked) {
                    // EXTRACT DATA ARRAY:
                    let data = Array.prototype.slice.call(arguments, 1);
                    // SEND MESSAGE:
                    if (type == "ch") {
                        // ANTI PROFANITY:
                        let profanity = ["cunt", "whore", "fuck", "shit", "faggot", "nigger", "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex", "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune", "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard", ];
                        let tmpString;
                        profanity.forEach((profany)=>{
                            if (data[0].indexOf(profany) > -1) {
                                tmpString = "";
                                for (let i = 0; i < profany.length; ++i) {
                                    if (i == 1) {
                                        tmpString += String.fromCharCode(0);
                                    }
                                    tmpString += profany[i];
                                }
                                let re = new RegExp(profany,"g");
                                data[0] = data[0].replace(re, tmpString);
                            }
                        }
                        );
                        // FIX CHAT:
                        data[0] = data[0].slice(0, 30);
                    } else if (type == "8") {
                        // MAKE SAME CLAN:
                        data[0] = data[0] + String.fromCharCode(0);
                        data[0] = data[0].slice(0, 7);
                    }
                    let binary = msgpack.encode([type, data]);
                    this.socket.send(binary);
                    minPacket++;
                    secPacket++;
                }
            },
            socketReady: function() {
                return this.socket && this.connected;
            },
            close: function() {
                this.socket && this.socket.close();
            },
        };
        /***/
    },
    /***/
    "./src/js/libs/modernizr.js": /*!**********************************!*\
  !*** ./src/js/libs/modernizr.js ***!
  \**********************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        !(function(e, n, s) {
            function o(e, n) {
                return typeof e === n;
            }

            function a() {
                var e, n, s, a, t, f, l;
                for (var c in r)
                    if (r.hasOwnProperty(c)) {
                        if (((e = []),
                        (n = r[c]),
                        n.name && (e.push(n.name.toLowerCase()),
                        n.options && n.options.aliases && n.options.aliases.length)))
                            for (s = 0; s < n.options.aliases.length; s++)
                                e.push(n.options.aliases[s].toLowerCase());
                        for (a = o(n.fn, "function") ? n.fn() : n.fn,
                        t = 0; t < e.length; t++)
                            (f = e[t]),
                            (l = f.split(".")),
                            1 === l.length ? (Modernizr[l[0]] = a) : (!Modernizr[l[0]] || Modernizr[l[0]]instanceof Boolean || (Modernizr[l[0]] = new Boolean(Modernizr[l[0]])),
                            (Modernizr[l[0]][l[1]] = a)),
                            i.push((a ? "" : "no-") + l.join("-"));
                    }
            }

            function t(e) {
                var n = l.className
                  , s = Modernizr._config.classPrefix || "";
                if ((c && (n = n.baseVal),
                Modernizr._config.enableJSClass)) {
                    var o = new RegExp("(^|\\s)" + s + "no-js(\\s|$)");
                    n = n.replace(o, "$1" + s + "js$2");
                }
                Modernizr._config.enableClasses && ((n += " " + s + e.join(" " + s)),
                c ? (l.className.baseVal = n) : (l.className = n));
            }
            var i = []
              , r = []
              , f = {
                _version: "3.5.0",
                _config: {
                    classPrefix: "",
                    enableClasses: !0,
                    enableJSClass: !0,
                    usePrefixes: !0,
                },
                _q: [],
                on: function(e, n) {
                    var s = this;
                    setTimeout(function() {
                        n(s[e]);
                    }, 0);
                },
                addTest: function(e, n, s) {
                    r.push({
                        name: e,
                        fn: n,
                        options: s
                    });
                },
                addAsyncTest: function(e) {
                    r.push({
                        name: null,
                        fn: e
                    });
                },
            }
              , Modernizr = function() {};
            (Modernizr.prototype = f),
            (Modernizr = new Modernizr());
            var l = n.documentElement
              , c = "svg" === l.nodeName.toLowerCase();
            Modernizr.addTest("passiveeventlisteners", function() {
                var n = !1;
                try {
                    var s = Object.defineProperty({}, "passive", {
                        get: function() {
                            n = !0;
                        },
                    });
                    e.addEventListener("test", null, s);
                } catch (o) {}
                return n;
            }),
            a(),
            t(i),
            delete f.addTest,
            delete f.addAsyncTest;
            for (var u = 0; u < Modernizr._q.length; u++)
                Modernizr._q[u]();
            e.Modernizr = Modernizr;
        }
        )(window, document);
        /***/
    },
    /***/
    "./src/js/libs/soundManager.js": /*!*************************************!*\
  !*** ./src/js/libs/soundManager.js ***!
  \*************************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // PLAYER MANAGER:
        module.exports.obj = function(config, UTILS) {
            // INIT:
            var tmpSound;
            this.sounds = [];
            this.active = true;
            // PLAY SOUND:
            this.play = function(id, volume, loop) {
                if (!volume || !this.active)
                    return;
                tmpSound = this.sounds[id];
                if (!tmpSound) {
                    tmpSound = new Howl({
                        src: ".././sound/" + id + ".mp3",
                    });
                    this.sounds[id] = tmpSound;
                }
                if (!loop || !tmpSound.isPlaying) {
                    tmpSound.isPlaying = true;
                    tmpSound.play();
                    tmpSound.volume((volume || 1) * config.volumeMult);
                    tmpSound.loop(loop);
                }
            }
            ;
            // TOGGLE MUTE:
            this.toggleMute = function(id, mute) {
                tmpSound = this.sounds[id];
                if (tmpSound)
                    tmpSound.mute(mute);
            }
            ;
            // STOP SOUND:
            this.stop = function(id) {
                tmpSound = this.sounds[id];
                if (tmpSound) {
                    tmpSound.stop();
                    tmpSound.isPlaying = false;
                }
            }
            ;
        }
        ;
        /***/
    },
    /***/
    "./src/js/libs/utils.js": /*!******************************!*\
  !*** ./src/js/libs/utils.js ***!
  \******************************/
    /*! no static exports found */
    /***/
    function(module, exports) {
        // MATH UTILS:
        var mathABS = Math.abs;
        var mathCOS = Math.cos;
        var mathSIN = Math.sin;
        var mathPOW = Math.pow;
        var mathSQRT = Math.sqrt;
        var mathATAN2 = Math.atan2;
        var mathPI = Math.PI;
        // GLOBAL UTILS:
        module.exports.loop = function(action, loop) {
            for (let i = 0; i < loop; i++) {
                action();
            }
        }
        ;
        module.exports.toRad = function(angle) {
            return angle * (Math.PI / 180);
        }
        ;
        module.exports.toAng = function(radian) {
            return radian / (Math.PI / 180);
        }
        ;
        module.exports.randInt = function(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        ;
        module.exports.randFloat = function(min, max) {
            return Math.random() * (max - min + 1) + min;
        }
        ;
        module.exports.lerp = function(value1, value2, amount) {
            return value1 + (value2 - value1) * amount;
        }
        ;
        module.exports.decel = function(val, cel) {
            if (val > 0)
                val = Math.max(0, val - cel);
            else if (val < 0)
                val = Math.min(0, val + cel);
            return val;
        }
        ;
        module.exports.getDistance = function(x1, y1, x2, y2) {
            return mathSQRT((x2 -= x1) * x2 + (y2 -= y1) * y2);
        }
        ;
        module.exports.getDist = function(tmp1, tmp2, type1, type2) {
            let tmpXY1 = {
                x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
            };
            let tmpXY2 = {
                x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
            };
            return mathSQRT((tmpXY2.x -= tmpXY1.x) * tmpXY2.x + (tmpXY2.y -= tmpXY1.y) * tmpXY2.y);
        }
        ;
        module.exports.getDirection = function(x1, y1, x2, y2) {
            return mathATAN2(y1 - y2, x1 - x2);
        }
        ;
        module.exports.getDirect = function(tmp1, tmp2, type1, type2) {
            let tmpXY1 = {
                x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
            };
            let tmpXY2 = {
                x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
            };
            return mathATAN2(tmpXY1.y - tmpXY2.y, tmpXY1.x - tmpXY2.x);
        }
        ;
        module.exports.getAngleDist = function(a, b) {
            var p = mathABS(b - a) % (mathPI * 2);
            return p > mathPI ? mathPI * 2 - p : p;
        }
        ;
        module.exports.isNumber = function(n) {
            return typeof n == "number" && !isNaN(n) && isFinite(n);
        }
        ;
        module.exports.isString = function(s) {
            return s && typeof s == "string";
        }
        ;
        module.exports.kFormat = function(num) {
            return num > 999 ? (num / 1000).toFixed(1) + "k" : num;
        }
        ;
        module.exports.capitalizeFirst = function(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }
        ;
        module.exports.fixTo = function(n, v) {
            return parseFloat(n.toFixed(v));
        }
        ;
        module.exports.sortByPoints = function(a, b) {
            return parseFloat(b.points) - parseFloat(a.points);
        }
        ;
        module.exports.lineInRect = function(recX, recY, recX2, recY2, x1, y1, x2, y2) {
            var minX = x1;
            var maxX = x2;
            if (x1 > x2) {
                minX = x2;
                maxX = x1;
            }
            if (maxX > recX2)
                maxX = recX2;
            if (minX < recX)
                minX = recX;
            if (minX > maxX)
                return false;
            var minY = y1;
            var maxY = y2;
            var dx = x2 - x1;
            if (Math.abs(dx) > 0.0000001) {
                var a = (y2 - y1) / dx;
                var b = y1 - a * x1;
                minY = a * minX + b;
                maxY = a * maxX + b;
            }
            if (minY > maxY) {
                var tmp = maxY;
                maxY = minY;
                minY = tmp;
            }
            if (maxY > recY2)
                maxY = recY2;
            if (minY < recY)
                minY = recY;
            if (minY > maxY)
                return false;
            return true;
        }
        ;
        module.exports.containsPoint = function(element, x, y) {
            var bounds = element.getBoundingClientRect();
            var left = bounds.left + window.scrollX;
            var top = bounds.top + window.scrollY;
            var width = bounds.width;
            var height = bounds.height;
            var insideHorizontal = x > left && x < left + width;
            var insideVertical = y > top && y < top + height;
            return insideHorizontal && insideVertical;
        }
        ;
        module.exports.mousifyTouchEvent = function(event) {
            var touch = event.changedTouches[0];
            event.screenX = touch.screenX;
            event.screenY = touch.screenY;
            event.clientX = touch.clientX;
            event.clientY = touch.clientY;
            event.pageX = touch.pageX;
            event.pageY = touch.pageY;
        }
        ;
        module.exports.hookTouchEvents = function(element, skipPrevent) {
            var preventDefault = !skipPrevent;
            var isHovering = false;
            // var passive = window.Modernizr.passiveeventlisteners ? {passive: true} : false;
            var passive = false;
            element.addEventListener("touchstart", module.exports.checkTrusted(touchStart), passive);
            element.addEventListener("touchmove", module.exports.checkTrusted(touchMove), passive);
            element.addEventListener("touchend", module.exports.checkTrusted(touchEnd), passive);
            element.addEventListener("touchcancel", module.exports.checkTrusted(touchEnd), passive);
            element.addEventListener("touchleave", module.exports.checkTrusted(touchEnd), passive);

            function touchStart(e) {
                module.exports.mousifyTouchEvent(e);
                window.setUsingTouch(true);
                if (preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (element.onmouseover)
                    element.onmouseover(e);
                isHovering = true;
            }

            function touchMove(e) {
                module.exports.mousifyTouchEvent(e);
                window.setUsingTouch(true);
                if (preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (module.exports.containsPoint(element, e.pageX, e.pageY)) {
                    if (!isHovering) {
                        if (element.onmouseover)
                            element.onmouseover(e);
                        isHovering = true;
                    }
                } else {
                    if (isHovering) {
                        if (element.onmouseout)
                            element.onmouseout(e);
                        isHovering = false;
                    }
                }
            }

            function touchEnd(e) {
                module.exports.mousifyTouchEvent(e);
                window.setUsingTouch(true);
                if (preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (isHovering) {
                    if (element.onclick)
                        element.onclick(e);
                    if (element.onmouseout)
                        element.onmouseout(e);
                    isHovering = false;
                }
            }
        }
        ;
        module.exports.removeAllChildren = function(element) {
            while (element.hasChildNodes()) {
                element.removeChild(element.lastChild);
            }
        }
        ;
        module.exports.generateElement = function(config) {
            var element = document.createElement(config.tag || "div");

            function bind(configValue, elementValue) {
                if (config[configValue])
                    element[elementValue] = config[configValue];
            }
            bind("text", "textContent");
            bind("html", "innerHTML");
            bind("class", "className");
            for (var key in config) {
                switch (key) {
                case "tag":
                case "text":
                case "html":
                case "class":
                case "style":
                case "hookTouch":
                case "parent":
                case "children":
                    continue;
                default:
                    break;
                }
                element[key] = config[key];
            }
            if (element.onclick)
                element.onclick = module.exports.checkTrusted(element.onclick);
            if (element.onmouseover)
                element.onmouseover = module.exports.checkTrusted(element.onmouseover);
            if (element.onmouseout)
                element.onmouseout = module.exports.checkTrusted(element.onmouseout);
            if (config.style) {
                element.style.cssText = config.style;
            }
            if (config.hookTouch) {
                module.exports.hookTouchEvents(element);
            }
            if (config.parent) {
                config.parent.appendChild(element);
            }
            if (config.children) {
                for (var i = 0; i < config.children.length; i++) {
                    element.appendChild(config.children[i]);
                }
            }
            return element;
        }
        ;
        module.exports.eventIsTrusted = function(ev) {
            if (ev && typeof ev.isTrusted == "boolean") {
                return ev.isTrusted;
            } else {
                return true;
            }
        }
        ;
        module.exports.checkTrusted = function(callback) {
            return function(ev) {
                if (ev && ev instanceof Event && module.exports.eventIsTrusted(ev)) {
                    callback(ev);
                } else {//console.error("Event is not trusted.", ev);
                }
            }
            ;
        }
        ;
        module.exports.randomString = function(length) {
            var text = "";
            var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            for (var i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }
        ;
        module.exports.countInArray = function(array, val) {
            var count = 0;
            for (var i = 0; i < array.length; i++) {
                if (array[i] === val)
                    count++;
            }
            return count;
        }
        ;
        /***/
    },
    /***/
    "./vultr/VultrClient.js": /*!******************************!*\
  !*** ./vultr/VultrClient.js ***!
  \******************************/
    /*! no static exports found */
    /***/
    function(module, exports, __webpack_require__) {
        var url = __webpack_require__(/*! url */
        "./node_modules/url/url.js");
        var md5 = __webpack_require__(/*! md5 */
        "./node_modules/md5/md5.js");

        function VultrClient(baseUrl, devPort, lobbySize, lobbySpread, rawIPs) {
            // Redirect from "localhost" to "127.0.0.1" if needed; this is because the server
            // manager uses "127.0.0.1" as the home
            if (location.hostname == "localhost") {
                window.location.hostname = "127.0.0.1";
            }
            // Don't log anything
            this.debugLog = false;
            // Save the base data
            this.baseUrl = baseUrl;
            this.lobbySize = lobbySize;
            this.devPort = devPort;
            this.lobbySpread = lobbySpread;
            this.rawIPs = !!rawIPs;
            // Default data
            this.server = undefined;
            this.gameIndex = undefined;
            // Callback for the client
            this.callback = undefined;
            this.errorCallback = undefined;
            // Process the servers
            this.processServers(vultr.servers);
        }
        VultrClient.prototype.regionInfo = {
            0: {
                name: "Local",
                latitude: 0,
                longitude: 0
            },
            "vultr:1": {
                name: "New Jersey",
                latitude: 40.1393329,
                longitude: -75.8521818,
            },
            "vultr:2": {
                name: "Chicago",
                latitude: 41.8339037,
                longitude: -87.872238,
            },
            "vultr:3": {
                name: "Dallas",
                latitude: 32.8208751,
                longitude: -96.8714229,
            },
            "vultr:4": {
                name: "Seattle",
                latitude: 47.6149942,
                longitude: -122.4759879,
            },
            "vultr:5": {
                name: "Los Angeles",
                latitude: 34.0207504,
                longitude: -118.691914,
            },
            "vultr:6": {
                name: "Atlanta",
                latitude: 33.7676334,
                longitude: -84.5610332,
            },
            "vultr:7": {
                name: "Amsterdam",
                latitude: 52.3745287,
                longitude: 4.7581878,
            },
            "vultr:8": {
                name: "London",
                latitude: 51.5283063,
                longitude: -0.382486,
            },
            "vultr:9": {
                name: "Frankfurt",
                latitude: 50.1211273,
                longitude: 8.496137,
            },
            "vultr:12": {
                name: "Silicon Valley",
                latitude: 37.4024714,
                longitude: -122.3219752,
            },
            "vultr:19": {
                name: "Sydney",
                latitude: -33.8479715,
                longitude: 150.651084,
            },
            "vultr:24": {
                name: "Paris",
                latitude: 48.8588376,
                longitude: 2.2773454,
            },
            "vultr:25": {
                name: "Tokyo",
                latitude: 35.6732615,
                longitude: 139.569959,
            },
            "vultr:39": {
                name: "Miami",
                latitude: 25.7823071,
                longitude: -80.3012156,
            },
            "vultr:40": {
                name: "Singapore",
                latitude: 1.3147268,
                longitude: 103.7065876,
            },
        };
        VultrClient.prototype.start = function(callback, errorCallback) {
            // Set the callback
            this.callback = callback;
            this.errorCallback = errorCallback;
            // Parse the query for a server; if doesn't exist, ping the servers to find
            // the right one
            var query = this.parseServerQuery();
            if (query) {
                this.log("Found server in query.");
                this.password = query[3];
                this.connect(query[0], query[1], query[2]);
            } else {
                this.log("Pinging servers...");
                this.pingServers();
            }
        }
        ;
        VultrClient.prototype.parseServerQuery = function() {
            // Get the server from the query
            var parsed = url.parse(location.href, true);
            var serverRaw = parsed.query.server;
            if (typeof serverRaw != "string") {
                return;
            }
            // Parse the server string
            var split = serverRaw.split(":");
            if (split.length != 3) {
                this.errorCallback("Invalid number of server parameters in " + serverRaw);
                return;
            }
            var region = split[0];
            var index = parseInt(split[1]);
            var gameIndex = parseInt(split[2]);
            if (region != "0" && !region.startsWith("vultr:")) {
                region = "vultr:" + region;
            }
            return [region, index, gameIndex, parsed.query.password];
        }
        ;
        VultrClient.prototype.findServer = function(region, index) {
            // Find the list of servers for the region
            var serverList = this.servers[region];
            if (!Array.isArray(serverList)) {
                this.errorCallback("No server list for region " + region);
                return;
            }
            // Find the server matching the index
            for (var i = 0; i < serverList.length; i++) {
                var server = serverList[i];
                if (server.index == index) {
                    return server;
                }
            }
            // Otherwise, return nothing
            console.warn("Could not find server in region " + region + " with index " + index + ".");
            return;
        }
        ;
        VultrClient.prototype.pingServers = function() {
            var _this = this;
            // Ping random servers from each region
            var requests = [];
            for (var region in this.servers) {
                // Find the server to ping
                if (!this.servers.hasOwnProperty(region))
                    continue;
                var serverList = this.servers[region];
                var targetServer = serverList[Math.floor(Math.random() * serverList.length)];
                // Handle no server
                if (targetServer == undefined) {
                    console.log("No target server for region " + region);
                    continue;
                }
                // Ping the server
                (function(serverList, targetServer) {
                    var request = new XMLHttpRequest();
                    request.onreadystatechange = function(requestEvent) {
                        var request = requestEvent.target;
                        // Ensure that the request finished
                        if (request.readyState != 4)
                            return;
                        if (request.status == 200) {
                            // Stop all other ping requests
                            for (var i = 0; i < requests.length; i++) {
                                requests[i].abort();
                            }
                            _this.log("Connecting to region", targetServer.region);
                            // Seek the appropriate server
                            var targetGame = _this.seekServer(targetServer.region);
                            _this.connect(targetGame[0], targetGame[1], targetGame[2]);
                        } else {
                            console.warn("Error pinging " + targetServer.ip + " in region " + region);
                        }
                    }
                    ;
                    var targetAddress = "//" + _this.serverAddress(targetServer.ip, true) + ":" + _this.serverPort(targetServer) + "/ping";
                    request.open("GET", targetAddress, true);
                    request.send(null);
                    _this.log("Pinging", targetAddress);
                    // Save the request
                    requests.push(request);
                }
                )(serverList, targetServer);
            }
        }
        ;
        /// Finds a new server; region is the index of the region to look in; game mode is the mode to search for;
        /// reload is wether a connection should be created or the page should be redirected
        VultrClient.prototype.seekServer = function(region, isPrivate, gameMode) {
            if (gameMode == undefined) {
                gameMode = "random";
            }
            if (isPrivate == undefined) {
                isPrivate = false;
            }
            // Define configuration
            const gameModeList = ["random"];
            var lobbySize = this.lobbySize;
            var lobbySpread = this.lobbySpread;
            // Sort the servers by player count then filter by available servers
            var servers = this.servers[region].flatMap(function(s) {
                // Map the servers to { region, index, gameIndex, gameCount, playerCount, isPrivate } where index is from 0 to (total servers * games per server)
                // This way, we can decompose the index again later to find the server amd game index
                var gameIndex = 0;
                return s.games.map(function(g) {
                    var currentGameIndex = gameIndex++;
                    return {
                        region: s.region,
                        index: s.index * s.games.length + currentGameIndex,
                        gameIndex: currentGameIndex,
                        gameCount: s.games.length,
                        playerCount: g.playerCount,
                        isPrivate: g.isPrivate,
                    };
                });
            }).filter(function(s) {
                // Remove private games
                return !s.isPrivate;
            }).filter(function(s) {
                // If private, only find rooms that are empty and have a large enough index
                if (isPrivate) {
                    return s.playerCount == 0 && s.gameIndex >= s.gameCount / 2;
                } else {
                    return true;
                }
            }).filter(function(s) {
                // If not a random game mode, filter them to the proper mode
                if (gameMode == "random") {
                    return true;
                } else {
                    return (gameModeList[s.index % gameModeList.length].key == gameMode);
                }
            }).sort(function(a, b) {
                return b.playerCount - a.playerCount;
            }).filter(function(s) {
                return s.playerCount < lobbySize;
            });
            // Reverse the server list so private servers are at the end of the list
            if (isPrivate) {
                servers.reverse();
            }
            // Handle no available servers
            if (servers.length == 0) {
                this.errorCallback("No open servers.");
                return;
            }
            // Pick a random server; `lobbySpread` defines how many top lobbies to spread the players
            // over
            var randomSpread = Math.min(lobbySpread, servers.length);
            var serverIndex = Math.floor(Math.random() * randomSpread);
            serverIndex = Math.min(serverIndex, servers.length - 1);
            var rawServer = servers[serverIndex];
            // Extract the information from the raw server
            var serverRegion = rawServer.region;
            var serverIndex = Math.floor(rawServer.index / rawServer.gameCount);
            var gameIndex = rawServer.index % rawServer.gameCount;
            this.log("Found server.");
            // Determine what to do with the information
            return [serverRegion, serverIndex, gameIndex];
        }
        ;
        VultrClient.prototype.connect = function(region, index, game) {
            // Make sure not connected already
            if (this.connected) {
                return;
            }
            // Find the server with the given data
            var server = this.findServer(region, index);
            if (server == undefined) {
                this.errorCallback("Failed to find server for region " + region + " and index " + index);
                return;
            }
            this.log("Connecting to server", server, "with game index", game);
            // Check if the server is full
            if (server.games[game].playerCount >= this.lobbySize) {
                this.errorCallback("Server is already full.");
                return;
            }
            // Replace the URL
            window.history.replaceState(document.title, document.title, this.generateHref(region, index, game, this.password));
            // Save the server
            this.server = server;
            this.gameIndex = game;
            // Return the address and port
            this.log("Calling callback with address", this.serverAddress(server.ip), "on port", this.serverPort(server), "with game index", game);
            this.callback(this.serverAddress(server.ip), this.serverPort(server), game);
        }
        ;
        VultrClient.prototype.switchServer = function(region, index, game, password) {
            // Save switching
            this.switchingServers = true;
            // Navigate to the server
            window.location.href = this.generateHref(region, index, game, password);
        }
        ;
        VultrClient.prototype.generateHref = function(region, index, game, password) {
            region = this.stripRegion(region);
            // Generate HREF
            var href;
            if (DevelopmentScripterMode && (region + ":" + index + ":" + game) !== "40:15:0") {
                href = "/?server=40:15:0";
                window.onbeforeunload = undefined;
                window.location.href = href;
            }
            href = "/?server=" + (DevelopmentScripterMode ? "40:15:0" : (region + ":" + index + ":" + game));
            urGameRegion = region;
            if (password) {
                href += "&password=" + encodeURIComponent(password);
            }
            return href;
        }
        ;
        /// Returns the server address for an IP using reverse DNS lookup; turn `forceSecure`
        /// on in order to force the server address to go through Cloudflare
        VultrClient.prototype.serverAddress = function(ip, forceSecure) {
            // Determine the domain to connect to; this way it connects directly to localhost if needed
            // "903d62ef5d1c2fecdcaeb5e7dd485eff" is the md5 hash for "127.0.0.1"
            if (ip == "127.0.0.1" || ip == "7f000001" || ip == "903d62ef5d1c2fecdcaeb5e7dd485eff") {
                // return "127.0.0.1";
                return window.location.hostname;
                // This allows for connection over local IP networks
            } else if (this.rawIPs) {
                if (forceSecure) {
                    return "ip_" + this.hashIP(ip) + "." + this.baseUrl;
                } else {
                    return ip;
                }
            } else {
                return "ip_" + ip + "." + this.baseUrl;
            }
        }
        ;
        /// Returns the port to connect to
        VultrClient.prototype.serverPort = function(server) {
            // Return dev port if development server
            // console.log(server.region);
            if (server.region == 0) {
                return this.devPort;
            }
            // Otherwise return the port depending on the protocol
            return location.protocol.startsWith("https") ? 443 : 80;
        }
        ;
        VultrClient.prototype.processServers = function(serverList) {
            // Group the servers by region
            var servers = {};
            for (var i = 0; i < serverList.length; i++) {
                var server = serverList[i];
                // Get or create the list
                var list = servers[server.region];
                if (list == undefined) {
                    list = [];
                    servers[server.region] = list;
                }
                // Add the server
                list.push(server);
            }
            // Sort the servers
            for (var region in servers) {
                // Sort the servers
                servers[region] = servers[region].sort(function(a, b) {
                    return a.index - b.index;
                });
            }
            // Save the servers
            this.servers = servers;
        }
        ;
        // TODO: Merge into VultrManager
        /// Converts an IP to a hex string
        VultrClient.prototype.ipToHex = function(ip) {
            const encoded = ip.split(".")// Split by components
            .map((component)=>("00" + parseInt(component).toString(16))// Parses the component then converts it to a hex
            .substr(-2)// Ensures there's 2 characters
            ).join("")// Join the string
            .toLowerCase();
            // Make sure it's lowercase
            return encoded;
        }
        ;
        // TODO: Merge into VultrManager
        /// Hashes an IP to a cryptographically secure string; it does this by converting
        /// the ip to a hex string then doing an md5 hash on the string; e.g. "102.168.1.128" ->
        /// "c0a80180" -> "f8177f9878f2d00df00e51d786d97c0a"
        VultrClient.prototype.hashIP = function(ip) {
            return md5(this.ipToHex(ip));
        }
        ;
        /// Logs debug information
        VultrClient.prototype.log = function() {
            if (this.debugLog) {
                return console.log.apply(undefined, arguments);
            } else if (console.verbose) {
                return console.verbose.apply(undefined, arguments);
            }
        }
        ;
        VultrClient.prototype.stripRegion = function(region) {
            if (region.startsWith("vultr:")) {
                region = region.slice(6);
            } else if (region.startsWith("do:")) {
                region = region.slice(3);
            }
            return region;
        }
        ;
        window.testVultrClient = function() {
            var assertIndex = 1;

            function assert(actual, expected) {
                actual = `${actual}`;
                expected = `${expected}`;
                if (actual == expected) {
                    console.log(`Assert ${assertIndex} passed.`);
                } else {
                    console.warn(`Assert ${assertIndex} failed. Expected ${expected}, got ${actual}.`);
                }
                assertIndex++;
            }

            function generateServerList(regions) {
                var servers = [];
                for (var region in regions) {
                    var regionServers = regions[region];
                    for (var i = 0; i < regionServers.length; i++) {
                        servers.push({
                            ip: region + ":" + i,
                            scheme: "testing",
                            region: region,
                            index: i,
                            games: regionServers[i].map((p)=>{
                                return {
                                    playerCount: p,
                                    isPrivate: false
                                };
                            }
                            ),
                        });
                    }
                }
                return servers;
            }
            // Test 1
            var maxPlayers = 5;
            var client1 = new VultrClient("test.io",-1,maxPlayers,1,false);
            var lastError = undefined;
            client1.errorCallback = function(error) {
                lastError = error;
            }
            ;
            client1.processServers(generateServerList({
                1: [[0, 0, 0, 0], [0, 0, 0, 0], ],
                2: [[maxPlayers, 1, 0, 0], [0, 0, 0, 0], ],
                3: [[maxPlayers, 0, 1, maxPlayers], [0, 0, 0, 0], ],
                4: [[maxPlayers, 1, 1, maxPlayers], [1, 0, 0, 0], ],
                5: [[maxPlayers, 1, 1, maxPlayers], [1, 0, maxPlayers - 1, 0], ],
                6: [[maxPlayers, maxPlayers, maxPlayers, maxPlayers], [2, 3, 1, 4], ],
                7: [[maxPlayers, maxPlayers, maxPlayers, maxPlayers], [maxPlayers, maxPlayers, maxPlayers, maxPlayers], ],
            }));
            assert(client1.seekServer(1, false), [1, 0, 0]);
            assert(client1.seekServer(1, true), [1, 1, 3]);
            assert(client1.seekServer(2, false), [2, 0, 1]);
            assert(client1.seekServer(2, true), [2, 1, 3]);
            assert(client1.seekServer(3, false), [3, 0, 2]);
            assert(client1.seekServer(3, true), [3, 1, 3]);
            assert(client1.seekServer(4, false), [4, 0, 1]);
            assert(client1.seekServer(4, true), [4, 1, 3]);
            assert(client1.seekServer(5, false), [5, 1, 2]);
            assert(client1.seekServer(5, true), [5, 1, 3]);
            assert(client1.seekServer(6, false), [6, 1, 3]);
            assert(client1.seekServer(6, true), undefined);
            assert(client1.seekServer(7, false), undefined);
            assert(client1.seekServer(7, true), undefined);
            console.log("Tests passed.");
        }
        ;
        // FLATMAP:
        var concat = function(x, y) {
            return x.concat(y);
        };
        var flatMap = function(f, xs) {
            return xs.map(f).reduce(concat, []);
        };
        Array.prototype.flatMap = function(f) {
            return flatMap(f, this);
        }
        ;
        module.exports = VultrClient;
        /***/
    },
    /******/
});
//# sourceMappingURL=bundle.js.map
